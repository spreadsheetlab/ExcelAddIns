<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>yFilesAlgorithms</name>
  </assembly>
  <members>
    <member name="T:yWorks.yFiles.Algorithms.AlgorithmAbortedException">
      <summary>
            Exception that gets thrown by an algorithm when
            the thread executing the algorithm was interrupted.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.AlgorithmAbortedException" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.AlgorithmAbortedException" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.Check">
      <summary>
            Throws an AlgorithmInterruptedException if
            the current Thread has been interrupted.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.Check(System.String)">
      <summary>
            Throws an AlgorithmInterruptedException if
            the current Thread has been interrupted.
            </summary>
      <param name="msg">Exception message if raised</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Bfs">
      <summary>This class provides services that center around breadth first search (BFS)</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Bfs" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)"></see>
            , but this time the core nodes
            are identified by a boolean predicate.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Boolean,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Boolean,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
      <param name="graph">the graph the bfs is running on</param>
      <param name="coreNodes">contains the nodes the bfs run starts from</param>
      <param name="directed">true: only outgoing edges are attended, false: all edges</param>
      <param name="layerIDMap">is used to store the layer depths informations in</param>
      <param name="maxLayers">number of layers that will be returned. "0" for all layers</param>
      <returns>
            an array of
            <see cref="T:yWorks.yFiles.Algorithms.NodeList"></see>
            s representing the layers
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Bipartitions">
      <summary>Responsible for graph bipartition problems.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bipartitions.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Bipartitions" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Bipartitions.Blue">
      <summary>Marker for a node that belongs to the blue partition</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bipartitions.GetBipartition(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Calculates a bipartition of the given graph if one exists.</summary>
      <returns>
        <c>isBipartite(graph)</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bipartitions.IsBipartite(yWorks.yFiles.Algorithms.Graph)">
      <summary>Tests whether or not the given graph is bipartite.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Bipartitions.Red">
      <summary>Marker for a node that belongs to the red partition</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Centrality">
      <summary>This class provides methods to determine various centrality indices of nodes or edges of a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Centrality" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.ClosenessCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes the closeness centrality for the nodes of a graph.</summary>
      <param name="graph">- the input graph.</param>
      <param name="closeness">- return value. a map which hold the centrality value of type <c>double</c> for every node.</param>
      <param name="directed">- whether or not consider the edges as directed.</param>
      <param name="edgeCosts">
            - when <see langword="null"></see> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.DegreeCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Boolean)">
      <summary>Computes the degree centrality for the nodes of a graph.</summary>
      <param name="graph">- the input graph.</param>
      <param name="centrality">- return value. a map which provides the degree centrality as <c>double</c> value for every node.</param>
      <param name="considerInEdges">
      </param>
      <param name="considerOutEdges">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.EdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes betweenness centrality for each edge of a given graph.</summary>
      <param name="centrality">- return value. a EdgeMap which will hold a non-negative centrality value of type <c>double</c> for each edge.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.GraphCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes the graph centrality for the nodes of a graph.</summary>
      <param name="graph">- the input graph.</param>
      <param name="centrality">- return value. a map which hold the centrality value of type <c>double</c> for every node.</param>
      <param name="directed">- whether or not consider the edges as directed.</param>
      <param name="edgeCosts">
            - when <see langword="null"></see> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.NodeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes betweenness centrality for each node of a given graph.</summary>
      <param name="graph">- the input graph.</param>
      <param name="centrality">- return value. a NodeMap which will hold a non-negative centrality value of type <c>double</c> for each node.</param>
      <param name="directed">
            - whether or not to consider the edges of the graph as directed or not.
            If false, the algorithm traverse every edge in both direction regardless the direction of the edge.
            </param>
      <param name="edgeCosts">
            - when <see langword="null"></see> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.NodeEdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes betweenness centrality for each node and edge of a given graph.</summary>
      <param name="nodeCentrality">- return value. a NodeMap which will hold the centrality value of type <c>double</c> for every node.</param>
      <param name="edgeCentrality">- return value. a EdgeMap which will hold the centrality value of type <c>double</c> for every edge.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)"></see>
            , but for EdgeMap.
            </summary>
      <param name="graph">- the input graph</param>
      <param name="map">- return value that holds <c>double</c> values between zero and one.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>This method normalizes the <c>double</c> values of a node map by dividing all values by the maximum of all values (maximum norm).</summary>
      <param name="graph">- the input graph</param>
      <param name="map">- return value that holds <c>double</c> values between zero and one.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.WeightCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes the weight centrality for the nodes of a graph.</summary>
      <param name="graph">The input graph.</param>
      <param name="centrality">
            Return value.
            A map which provides the value centrality as <c>double</c> value for
            every node.
            </param>
      <param name="considerInEdges">Whether the weights associated with incoming edges should be considered.</param>
      <param name="considerOutEdges">Whether the weights associated with outgoing edges should be considered.</param>
      <param name="edgeWeights">
            When <see langword="null"></see> the edges of the graph are considered to have uniform
            weight of 1.0.
            Otherwise it must provide a non-negative <c>double</c> value (the weight)
            for every edge.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Cycles">
      <summary>Responsible for finding cycles within a graph that have certain properties.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Cycles" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindAllCycleEdges(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>Returns all edges that are part of a directed or undirected cycle.</summary>
      <param name="graph">the input graph</param>
      <param name="directed">whether or not to look for edges on directed cycles</param>
      <returns>all edges that belong to a cycle</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycle(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>
            Returns an edge list that contains the edges of a cycle
            found in the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            This method marks edges of a given graph whose removal or reversal would make
            that graph acyclic.
            </summary>
      <param name="graph">the input graph</param>
      <param name="cycleEdges">
            return value. cycleEdge.getBool(e) == true  iff
            e is a detected cycle edge.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            This method is similar to
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)"></see>
            , but instead of minimizing the
            number of marked edges it tries to find a set of marked edges, for which the associated
            cost is minimal.
            </summary>
      <param name="costDP">
            data provider that yields the reversal cost for each edge. The reversal cost
            for each edge must be a non-negative value of type <c>double</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdgesDFS(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)"></see>
            this method marks
            edges of a given graph whose removal or reversal would make
            that graph acyclic.
            </summary>
      <param name="graph">the input graph</param>
      <param name="cycleEdges">
            return value. cycleEdge.getBool(e) == true  iff
            e is a detected cycle edge.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Dfs">
      <summary>Framework class for depth first search (DFS) based algorithms.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.#ctor">
      <summary>Instantiates a new Dfs object.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.Black">
      <summary>Node state specifier.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Dfs.DirectedMode">
      <summary>
            Specifies whether or not to interpret the edges of the graph
            as directed.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.Gray">
      <summary>Node state specifier.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.LookFurther(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Callback method that will be invoked whenever dfs continues
            its search at a new root node.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Dfs.LookFurtherMode">
      <summary>
            Specifies whether or not to continue the depth first search
            after all nodes reachable from the first node were
            visited.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PostTraverse(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Callback method that will be invoked after the search returns
            from the given node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PostVisit(yWorks.yFiles.Algorithms.Node,System.Int32,System.Int32)">
      <summary>
            Callback method that will be invoked whenever a node visit has
            been completed.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PreTraverse(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Callback method that will be invoked if the given edge
            will be looked at in the search the first (and only) time.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PreVisit(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>
            Callback method that will be invoked whenever a formerly unvisited node
            gets visited the first time.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.Start(yWorks.yFiles.Algorithms.Graph)">
      <summary>Starts a depth first search on the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.Start(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Starts a depth first search on the given graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.stateMap">
      <summary>
            NodeMap that indicates the state of the nodes as they
            are visited by this algorithm.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.White">
      <summary>Node state specifier.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Edge">
      <summary>
            Represents an edge, i.e., a directed connection between two nodes (represented
            by instances of class
            <see cref="T:yWorks.yFiles.Algorithms.Node"></see>
            ) in the directed graph data type
            <see cref="T:yWorks.yFiles.Algorithms.Graph"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>Creates a new edge that belongs to the given graph.</summary>
      <param name="v">
            
            The source node of the edge.
            </param>
      <param name="e1">
            
            An edge with source node <c>v</c>.
            </param>
      <param name="w">
            
            The target node of the edge.
            </param>
      <param name="e2">
            
            An edge with target node <c>w</c>.
            </param>
      <param name="d1">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
      <param name="d2">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.CreateCopy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a copy of this edge that will be inserted into the given graph connecting
            the given source and target nodes.
            </summary>
      <param name="g">
            
            The graph the created edge will belong to.
            </param>
      <param name="v">
            
            The source node of the created edge.
            </param>
      <param name="w">
            
            The target node of the created edge.
            </param>
      <returns>
            
            The newly created Edge object.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Graph">
      <summary>The graph this edge belongs to.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Index">
      <summary>The index of this edge within its graph G.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.NextInEdge">
      <summary>
            The successor of this edge in the list of incoming edges at its target
            node.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.NextOutEdge">
      <summary>
            The successor of this edge in the list of outgoing edges at its source
            node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.OnReinsert">
      <summary>
            Callback method that is invoked from a graph just before this edge will be
            reinserted into that graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.Opposite(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the node at the opposite edge end with respect to the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.PrevInEdge">
      <summary>
            The predecessor of this edge in the list of incoming edges at its target
            node.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.PrevOutEdge">
      <summary>
            The predecessor of this edge in the list of outgoing edges at its source
            node.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.SelfLoop">
      <summary>
        <see langword="true">
        </see> if and only if this edge is a self-loop.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Source">
      <summary>The source node connected to this edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Target">
      <summary>The target node connected to this edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.ToString">
      <summary>Returns a String representation of this edge.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.EdgeList">
      <summary>
            Specialized list implementation for instances of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor">
      <summary>Creates an empty edge list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates a list that is initialized with a single edge provided.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Creates a list that is initialized with the edges provided by the given array
            of edges.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Creates a list that is initialized with an EdgeList.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>
            Creates a list that is initialized with the edges provided by the given EdgeCursor
            object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.IEdgeCursor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a list that is initialized with those edges from the given EdgeCursor
            object for which the given data provider returns <see langword="true"></see> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </summary>
      <param name="ec">
            
            An edge cursor providing edges that should be added to this list.
            </param>
      <param name="predicate">
            
            A data provider that acts as a inclusion predicate for each edge accessible
            by the given edge cursor.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Util.IIterator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            Iterator object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.Edges">
      <summary>Returns an edge cursor for this edge list.</summary>
      <returns>
            
            An edge cursor granting access to the edges within this list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.FirstEdge">
      <summary>
            Returns the first edge in this list, or <see langword="null"></see> when the list is
            empty.
            </summary>
      <returns>
            
            The first edge in the list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.GetEnumerator"></member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.LastEdge">
      <summary>Returns the last edge in this list, or <see langword="null"></see> when the list is empty.</summary>
      <returns>
            
            The last edge in the list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.PopEdge">
      <summary>Removes the first edge from this list and returns it.</summary>
      <returns>
            
            The first edge from the list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.ToEdgeArray">
      <summary>Returns an edge array containing all elements of this list in the canonic order.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Graph">
      <summary>This class implements a directed graph structure.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.#ctor">
      <summary>Instantiates an empty Graph object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Instantiates a new Graph object as a copy of the given graph.</summary>
      <param name="argGraph">
            
            The graph to be copied.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Instantiates a new Graph object as a partial copy of the given graph.</summary>
      <param name="graph">
            
            The graph to be (partially) copied.
            </param>
      <param name="subNodes">
            
            A cursor to iterate over the nodes that actually induce the subgraph to be
            copied.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.AddDataProvider(System.Object,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Registers the given data provider using the given look-up key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.AddGraphListener(yWorks.yFiles.Algorithms.IGraphListener)">
      <summary>Registers the given graph listener with this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ChangeEdge(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be changed.
            </param>
      <param name="e1">
            
            Reference edge for insertion at a new source node.
            </param>
      <param name="e2">
            
            Reference edge for insertion at a new target node.
            </param>
      <param name="d1">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
      <param name="d2">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ChangeEdge(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be changed.
            </param>
      <param name="newSource">
            
            The new source node.
            </param>
      <param name="sourceReference">
            
            Reference edge for insertion at the new source node.
            </param>
      <param name="sourceD">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
      <param name="newTarget">
            
            The new target node.
            </param>
      <param name="targetReference">
            
            Reference edge for insertion at the new target node.
            </param>
      <param name="targetD">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ChangeEdge(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be changed.
            </param>
      <param name="newSource">
            
            The new source node of the given edge.
            </param>
      <param name="newTarget">
            
            The new target node of the given edge.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Clear">
      <summary>
            Removes all nodes and edges from this graph and fires corresponding notification
            events to inform registered listeners.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Contains(yWorks.yFiles.Algorithms.Edge)">
      <summary>Whether or not this graph contains the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Whether or not this graph contains the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ContainsEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not this graph contains an edge that connects the given
            nodes.
            </summary>
      <param name="source">
            
            The source node.
            </param>
      <param name="target">
            
            The target node.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateCopy">
      <summary>Creates a copy of this graph.</summary>
      <returns>The newly created Graph object.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>
            Creates a new edge in this graph and fires a corresponding notification event
            to inform registered listeners.
            </summary>
      <param name="v">
            
            The source node of the edge.
            </param>
      <param name="e1">
            
            An edge with source node <c>v</c>.
            </param>
      <param name="w">
            
            The target node of the edge.
            </param>
      <param name="e2">
            
            An edge with target node <c>w</c>.
            </param>
      <param name="d1">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
      <param name="d2">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before"></see>
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After"></see>
            .
            </param>
      <returns>The newly created Edge object.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a new edge in this graph and fires a corresponding notification event
            to inform registered listeners.
            </summary>
      <param name="v">
            
            The source node of the edge.
            </param>
      <param name="w">
            
            The target node of the edge.
            </param>
      <returns>
            
            The newly created Edge object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateEdgeMap">
      <summary>Returns a newly created edge map that is valid for the edges in this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateGraph">
      <summary>Creates an empty base object of the same type as this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateGraphCopyFactory">
      <summary>
            Factory method that is called by
            <see cref="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory"></see>
            to create a (possibly shared) instance.
            </summary>
      <returns>the (possibly shared) instance.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateNode">
      <summary>
            Creates a new node in this graph and fires a corresponding notification event
            to inform registered listeners.
            </summary>
      <returns>
            
            The newly created Node object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateNodeMap">
      <summary>Returns a newly created node map that is valid for the nodes in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.DataProviderKeys">
      <summary>
            An array of all data provider look-up keys that are registered with
            this graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.DisposeEdgeMap(yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Informs the graph that the given edge map is no longer needed.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.DisposeNodeMap(yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Informs the graph that the given node map is no longer needed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.E">
      <summary>The number of edges in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.EdgeCount">
      <summary>The number of edges in this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.EdgeObjects">
      <summary>Returns an iterator that provides access to all edges residing in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.Edges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>s that can be used to iterate over the edges that are contained in this instance.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.Empty">
      <summary>
        <see langword="true">
        </see> if this graph contains no nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FireGraphEvent(yWorks.yFiles.Algorithms.GraphEvent)">
      <summary>Propagates the given graph event to all registered graph listeners.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent">
      <summary>Propagates a so-called POST event to all registered graph listeners.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent(System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent"></see>
            .
            </summary>
      <param name="id">
            
            An identifying tag for the event.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent">
      <summary>Propagates a so-called PRE event to all registered graph listeners.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent(System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent"></see>
            .
            </summary>
      <param name="id">
            
            An identifying tag for the event.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.FirstEdge">
      <summary>The first edge in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.FirstNode">
      <summary>The first node in this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirstOutEdge(yWorks.yFiles.Algorithms.Node)">
      <summary>Low-level iteration support for adjacent edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetDataProvider(System.Object)">
      <summary>
            Returns the data provider that is registered with the graph using the given
            look-up key.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetEdgeArray">
      <summary>Returns an array containing all edges of this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetEdgeCursor">
      <summary>Provides access to the edges of the graph.</summary>
      <returns>
            
            An EdgeCursor to iterate over the edges in the graph.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetNodeArray">
      <summary>Returns an array containing all nodes of this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetNodeCursor">
      <summary>Provides access to the nodes of the graph.</summary>
      <returns>
            
            A NodeCursor to iterate over the nodes in the graph.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetSource(System.Object)">
      <summary>Returns the source node associated with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetTarget(System.Object)">
      <summary>Returns the target node associated with the given edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory">
      <summary>The copy factory that is associated with this instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.GraphListeners">
      <summary>An iterator that grants access to all registered graph listeners.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.HasListeners">
      <summary>Determines whether there are listeners registered with this instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Hide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Hides the given edge from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Hide(yWorks.yFiles.Algorithms.Node)">
      <summary>Hides the given node from this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.LastEdge">
      <summary>The last edge in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.LastNode">
      <summary>The last node in this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveSubGraph(yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.Graph)">
      <summary>Moves an induced subgraph to another graph.</summary>
      <param name="subNodes">
            
            A list of nodes that induce the subgraph to be moved.
            </param>
      <param name="targetGraph">
            
            The graph where the subgraph is moved to.
            </param>
      <returns>
            
            A list of removed edges that connected the induced subgraph to this graph.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToFirst(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Moves the given edge to the first position within the sequence of edges in
            this graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToFirst(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Moves the given node to the first position within the sequence of nodes in
            this graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToLast(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Moves the given edge to the last position within the sequence of edges in this
            graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToLast(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Moves the given node to the last position within the sequence of nodes in this
            graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.N">
      <summary>The number of nodes in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.NodeCount">
      <summary>The number of nodes in this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.NodeObjects">
      <summary>Returns an iterator that provides access to all nodes residing in this graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.Nodes">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Node"></see>s that can be used to iterate over the nodes that are contained in this instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.PrintNodeSlotSize">
      <summary>For internal debugging purposes only.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.RegisteredEdgeMaps">
      <summary>
            All edge maps that have been created by this graph but have not yet
            been disposed.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.RegisteredNodeMaps">
      <summary>
            All node maps that have been created by this graph but have not yet
            been disposed.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ReInsertEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Reinserts a formerly removed edge into this graph and fires a corresponding
            notification event to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be reinserted.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ReInsertNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Reinserts a formerly removed node into this graph and fires a corresponding
            notification event to inform registered listeners.
            </summary>
      <param name="v">
            
            The node to be reinserted.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveDataProvider(System.Object)">
      <summary>Removes the data provider that is registered using the given look-up key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Removes the given edge from this graph and fires a corresponding notification
            event to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be removed.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveGraphListener(yWorks.yFiles.Algorithms.IGraphListener)">
      <summary>Removes the given graph listener from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this graph.</summary>
      <param name="v">
            
            The node to be removed from this graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ReverseEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Reverses the given edge and fires corresponding notification events to inform
            registered listeners.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.SortEdges(System.Collections.IComparer)">
      <summary>Sorts the internally held list of edges.</summary>
      <param name="comp">The comparator used for the edges.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.SortEdges(System.Collections.IComparer,System.Collections.IComparer)">
      <summary>Sorts incoming and outgoing edges at each node of the graph.</summary>
      <param name="inComp">
            
            The comparator used for the incoming edges at each node.
            </param>
      <param name="outComp">
            
            The comparator used for the outgoing edges at each node.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.SortNodes(System.Collections.IComparer)">
      <summary>Sorts the internally held list of nodes.</summary>
      <param name="comp">The comparator used for the nodes.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ToString">
      <summary>Returns a String representation of this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Unhide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Unhides the given edge in this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Unhide(yWorks.yFiles.Algorithms.Node)">
      <summary>Unhides the given node in this graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphChecker">
      <summary>
            Provides methods that check structural properties of
            a given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsAcyclic(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains to directed cycle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsBiconnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph his biconnected.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsBipartite(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph his bipartite.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is connected.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsCyclic(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains a directed cycle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsForest(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is a forest, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsMultipleEdgeFree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains multiple edges, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsNaryTree(yWorks.yFiles.Algorithms.Graph,System.Int32)">
      <summary>
            Checks whether or not the given graph is a rooted tree
            where each node has a maximum of <c>n</c> children.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsPlanar(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is planar.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsRootedTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is a rooted tree.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsSelfLoopFree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains self-loops.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsSimple(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is simple, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsStronglyConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is strongly connected.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is an undirected tree.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphConnectivity">
      <summary>Provides algorithms for determining certain connectivity components within a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.GraphConnectivity" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph)">
      <summary>Calculates the biconnected components of a given undirected graph.</summary>
      <param name="graph">the input graph</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Calculates the biconnected components of a given undirected graph.</summary>
      <param name="graph">the input graph</param>
      <param name="compNum">
            return value that provides for each edge a zero-based index of the
            biconnected component it belongs to.
            </param>
      <returns>the number of biconnected components found</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)"></see>
            .
            </summary>
      <param name="aPoint">
            return value that provides for each node  a boolean value
            indicating whether or not it is an articulation point.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            an array of NodeLists each of which contains the nodes that belong to
            a common connected component of the graph.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="compNum">
            return value that will hold the zero-based number
            of the connected component that it belongs to. The component number of
            Node <c>v</c> is <c>compNum.getInt()</c>.
            </param>
      <returns>the number of connected components of this graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.GetNeighbors(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>Determines the direct or indirect neighbors of a given set of nodes.</summary>
      <param name="graph">the graph to act upon</param>
      <param name="startNodes">contains the node the search is started from</param>
      <param name="maxDistance">
            limits the distance between a start node and a returned node. For all returned
            nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
            Setting maxDistance to <c>1</c> will only yield the direct neighbors of all start nodes. On the other hand,
            setting maxDistance to <c>graph.N()</c> or larger, will yield all neighbors of all start nodes.
            </param>
      <returns>
            a NodeList that contains all direct and indirect neighbors of a node.
            The order of the returned nodes follows is determined by a breadth first search.
            No start node will be part of the resulting set.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.GetPredecessors(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>Determines the direct or indirect predecessors of a given set of nodes.</summary>
      <param name="graph">the graph to act upon</param>
      <param name="startNodes">contains the node the search is started from</param>
      <param name="maxDistance">
            limits the distance between a start node and a returned node. For all returned
            nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
            Setting maxDistance to <c>1</c> will only yield the direct predecessors of all start nodes. On the other hand,
            setting maxDistance to <c>graph.N()</c> or larger, will yield all predecessors of all start nodes.
            </param>
      <returns>
            a NodeList that contains all direct and indirect predecessors of a node. The order
            of the returned nodes follows is determined by a breadth first search.
            No start node will be part of the resulting set.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.GetSuccessors(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>Determines the direct or indirect successors of a given set of nodes.</summary>
      <param name="graph">the graph to act upon</param>
      <param name="startNodes">contains the node the search is started from</param>
      <param name="maxDistance">
            limits the distance between a start node and a returned node. For all returned
            nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
            Setting maxDistance to <c>1</c> will only yield the direct successors of all start nodes. On the other hand,
            setting maxDistance to <c>graph.N()</c> or larger, will yield all successors of all start nodes.
            </param>
      <returns>
            a NodeList that contains all direct and indirect successors of a node. The order
            of the returned nodes follows is determined by a breadth first search.
            No start node will be part of the resulting set.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.IsBiconnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph his biconnected.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.IsConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is connected.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.IsStronglyConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is strongly connected.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.MakeBiconnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Makes the given graph biconnected by inserting a minimum number of edges
            in the graph.
            </summary>
      <param name="graph">the input graph</param>
      <returns>an edge list containing the edges added to this graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.MakeConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Makes a graph connected by adding additional edges to the graph.</summary>
      <param name="graph">the input graph</param>
      <returns>an edge list containing the edges added to this graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[])">
      <summary>
            Determines the set of nodes that can be reached in the given graph when starting
            from a given node.
            </summary>
      <param name="graph">the graph the search is performed on</param>
      <param name="start">the node the search is started from</param>
      <param name="directed">
            traverses edges only from source to target if <see langword="true"></see>. Otherwise
            traverses edges in both directions.
            </param>
      <param name="reached">
            the return value. a boolean array that has value <see langword="true"></see> at field
            <c>v.index()</c> iff node v can be reached by the dfs search.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[],System.Boolean[])">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[])"></see>
            .
            </summary>
      <param name="graph">the graph DFS is performed on</param>
      <param name="start">the node DFS is started from</param>
      <param name="directed">
            traverses edges only from source to target if <see langword="true"></see>. Otherwise
            traverses edges in both directions.
            </param>
      <param name="forbidden">
            marks edges that may not be traversed by DFS. An edge <c>e</c>
            is marked as forbidden if <c>forbidden[e.index()] == true</c>.
            </param>
      <param name="reached">
            the return value. a boolean array that has value <see langword="true"></see> at field
            <c>v.index()</c> iff node v can be reached by the dfs search.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            an array of NodeLists each of which contains the nodes that belong to
            a common connected component of the graph.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="compNum">
            return value that will hold the zero-based number
            of the strongly connected component that it belongs to. The component number of
            Node <c>v</c> is <c>compNum.getInt()</c>.
            </param>
      <returns>the number of strongly connected components of this graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ToEdgeListArray(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Int32)">
      <summary>
            Transforms the return values of
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)"></see>
            to
            an array of type EdgeList, like it is returned by
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ToNodeListArray(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>
            Transforms the return values of
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)"></see>
            to
            an array of type NodeList, like it is returned by
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph)"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphCopyFactory">
      <summary>
            Very simple default implementation of a Copy Factory that creates
            <see cref="T:yWorks.yFiles.Algorithms.Graph"></see>
            instances
            and simply delegates to the
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNode"></see>
            and
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)"></see>
            method.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.GraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="newSource">the source node in the target graph to use for the newly created edge</param>
      <param name="newTarget">the target node in the target graph to use for the newly created edge</param>
      <param name="originalEdge">the original edge from the source graph</param>
      <returns>the newly created edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="originalNode">the original node from the source graph</param>
      <returns>the newly created node</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.CreateGraph">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Algorithms.Graph"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>This implementation does nothing.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>This implementation does nothing.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphElementInsertion">
      <summary>Object insertion specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before">
      <summary>
            Object insertion specifier.
            An object gets inserted before another one.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After">
      <summary>
            Object insertion specifier.
            An object gets inserted after another one.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphEvent">
      <summary>An event which indicates that a graph structure change occurred.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphEvent.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.GraphEventType,System.Object)">
      <summary>Creates a new GraphEvent instance with given type and data.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.GraphEvent.Data">
      <summary>The data object associated with this graph event.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.GraphEvent.Graph">
      <summary>The graph that is the emitter of this event.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphEvent.ToString">
      <summary>Returns a String representation of this GraphEvent object's type.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.GraphEvent.Type">
      <summary>The type of this GraphEvent.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphEventType"></member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.NodeCreation">
      <summary>
            Type constant that identifies an event that gets fired immediately after a
            node has been created.
            The data of the event is the newly created node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.EdgeCreation">
      <summary>
            Type constant that identifies an event that gets fired immediately after an
            edge has been created.
            The data of the event is the newly created edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreNodeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately before a
            node will be removed from the graph.
            The data of the event is the node to be removed.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostNodeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately after a
            node has been removed from the graph.
            The data of the event is the removed node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreEdgeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately before an
            edge will be removed from the graph.
            The data of the event is the edge to be removed.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostEdgeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately after an
            edge has been removed from the graph.
            The data of the event is the removed edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.NodeReinsertion">
      <summary>
            Type constant that identifies an event that gets fired immediately after a
            node has been reinserted into the graph.
            The data of the event is the reinserted node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.EdgeReinsertion">
      <summary>
            Type constant that identifies an event that gets fired immediately after an
            edge has been reinserted into the graph.
            The data of the event is the reinserted edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreEdgeChange">
      <summary>
            Type constant that identifies an event that gets fired immediately before the
            end points of an edge will be changed.
            The data of the event is the edge to be redefined.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostEdgeChange">
      <summary>
            Type constant that identifies an event that gets fired immediately after the
            end points of an edge have been changed.
            The data of the event is the redefined edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphInsertion">
      <summary>
            Type constant that identifies an event that gets fired after a subgraph of
            a graph G has been moved to the emitting graph.
            The data of the event is a
            <see cref="T:yWorks.yFiles.Algorithms.NodeList"></see>
            containing the nodes that induce
            the moved subgraph.
            <p></p>
            This event gets fired just after the
            <see cref="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphRemoval"></see>
            event got fired
            on the subgraph's original graph G.
            Note that at the time the event gets fired, the nodes from the node list are
            already part of the emitting graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphRemoval">
      <summary>
            Type constant that identifies an event that gets fired after a subgraph of
            the emitting graph has been moved to a graph G.
            The data of the event is a
            <see cref="T:yWorks.yFiles.Algorithms.NodeList"></see>
            containing the nodes that induce
            the moved subgraph.
            <p></p>
            This event gets fired just before the
            <see cref="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphInsertion"></see>
            event will
            be fired on the subgraph's new graph G.
            Note that at the time the event gets fired, the nodes from the node list are
            already part of graph G.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreEvent">
      <summary>
            Type constant that signals the start of a some logically coherent event sequence.
            If specified, the data of this event is its ID.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostEvent">
      <summary>
            Type constant that signals the end of a some logically coherent event sequence.
            If specified, the data of this event is its ID.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphObject">
      <summary>
            Common base type for both <see cref="T:yWorks.yFiles.Algorithms.Node"></see> and <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Groups">
      <summary>This class provides methods for automatically partitioning nodes of a graph into groups.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Groups.BiconnectedComponentGrouping(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>This method partitions the graph by analyzing its biconnected component structure.</summary>
      <param name="graph">- the input graph.</param>
      <param name="groupIDs">- return value. this map holds a cluster ID of integer type for every node.</param>
      <returns>the number of different groups found.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Groups.EdgeBetweennessClustering(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            This method partitions the graph into groups using edge betweenness centrality
            (see
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.EdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)"></see>
            .
            </summary>
      <param name="graph">- the input graph.</param>
      <param name="clusterIDs">- return value. this map holds a cluster ID of integer type for every node.</param>
      <param name="directed">- whether or not to consider the edges of the graph as directed.</param>
      <param name="minGroupCount">- the minimum number of groups to be returned. The smaller this value is chosen the</param>
      <param name="maxGroupCount">
            - the maximum number of groups to be returned. The smaller this value is chosen the
            faster the overall computation time. Note that the upper bound on the number of groups is <c>graph.N()</c>.
            Note, that the number of returned groups is never less than the number of connected components of the graph.
            </param>
      <param name="edgeCosts">
            - when <see langword="null"></see> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
      <returns>the number of different groups found.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.ICursor">
      <summary>A general interface for iterating over a collection of objects.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ICursor.Current">
      <summary>The object currently pointed on.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.Next">
      <summary>Moves this cursor one position forward.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ICursor.Ok">
      <summary>
        <see langword="true">
        </see> if the current cursor position is valid.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.Prev">
      <summary>Moves this cursor one position backward (optional).</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ICursor.Size">
      <summary>The number of elements that can be accessed with this cursor.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.ToFirst">
      <summary>Moves this cursor to the first valid cursor position (optional).</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.ToLast">
      <summary>Moves this cursor to the last valid cursor position (optional).</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IDataAcceptor">
      <summary>A general interface for setting data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.Set(System.Object,System.Object)">
      <summary>Sets an object value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetBool(System.Object,System.Boolean)">
      <summary>Sets a boolean value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetDouble(System.Object,System.Double)">
      <summary>Sets a double value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">
      <summary>Sets an integer value associated with the given data holder.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IDataMap">
      <summary>
            Interface that combines the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor"></see>
            interfaces.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IDataProvider">
      <summary>A general interface for data provision.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)">
      <summary>Returns an object value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">
      <summary>Returns a boolean value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.GetDouble(System.Object)">
      <summary>Returns a double value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)">
      <summary>Returns an integer value associated with the given data holder.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IEdgeCursor">
      <summary>A cursor interface for iterating over edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeCursor.CyclicNext">
      <summary>Moves the cursor to the cyclic next element of the underlying sequence.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeCursor.CyclicPrev">
      <summary>Moves the cursor to the cyclic previous element of the underlying sequence.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.IEdgeCursor.Edge">
      <summary>The edge at the current location of the cursor.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IEdgeMap">
      <summary>Provides access to data associated with an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.Get(System.Object)">
      <summary>Returns the value bound to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given edge.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IGraphInterface">
      <summary>
            An interface that describes the structural information of a graph and the data
            that is associated with its nodes and edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.IGraphInterface.DataProviderKeys">
      <summary>
            An array of all data provider look-up keys that are registered with
            the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.EdgeObjects">
      <summary>Returns an iterator that provides access to all edges residing in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.GetDataProvider(System.Object)">
      <summary>
            Returns the data provider that is registered with the graph using the given
            look-up key.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.GetSource(System.Object)">
      <summary>Returns the source node associated with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.GetTarget(System.Object)">
      <summary>Returns the target node associated with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.NodeObjects">
      <summary>Returns an iterator that provides access to all nodes residing in the graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IGraphListener">
      <summary>The listener interface for receiving graph events.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphListener.OnGraphEvent(yWorks.yFiles.Algorithms.GraphEvent)">
      <summary>Invoked when the structure of the graph has changed.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IndependentSets">
      <summary>This class provides methods for calculating independent sets.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IndependentSets.GetIndependentSet(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calculates an independent set for a given conflict graph (each pair of nodes of the independent set is non-adjacent
            in the conflict graph).
            </summary>
      <param name="conflictGraph">the input graph.</param>
      <returns>a NodeList containing an independent set of nodes</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IndependentSets.GetIndependentSets(yWorks.yFiles.Algorithms.Graph)">
      <summary>Partitions the vertex set of the given conflict graph into independent sets.</summary>
      <param name="conflictGraph">the input graph.</param>
      <returns>a NodeList array where each entry contains an independent set of nodes.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.INodeCursor">
      <summary>A cursor interface for iterating over nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeCursor.CyclicNext">
      <summary>Moves the cursor to the cyclic next element of the underlying sequence.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeCursor.CyclicPrev">
      <summary>Moves the cursor to the cyclic previous element of the underlying sequence.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.INodeCursor.Node">
      <summary>The node at the current location of the cursor.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.INodeMap">
      <summary>Provides access to data associated with a node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.INodeSequencer">
      <summary>
            Generic Interface for classes that provide an ordering
            for the nodes of a graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeSequencer.Nodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a cursor that grants access to <b>all</b> nodes of the given
            graph in some order.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.InvalidGraphStructureException">
      <summary>Exception thrown when a graph-structural precondition is violated.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.InvalidGraphStructureException.#ctor(System.String)">
      <summary>Constructs a WrongGraphStructure exception with the specified message.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.ListCell">
      <summary>
            Represents a so-called "cell" or "link" of the doubly linked list implementation
            <see cref="T:yWorks.yFiles.Algorithms.YList"></see>
            .
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ListCell.Info">
      <summary>The element stored in this cell.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ListCell.Pred">
      <summary>Returns the predecessor cell of this cell.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ListCell.Succ">
      <summary>Returns the successor cell of this cell.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.NetworkFlows">
      <summary>
            Provides sophisticated algorithms for solving classical network flow problems
            like MinCostFlow or MaxFlow.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.NetworkFlows" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Solves a maximum flow problem using the preflow-push method.</summary>
      <param name="graph">the network.</param>
      <param name="source">the source of the network.</param>
      <param name="sink">the sink of the network.</param>
      <param name="eCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <returns>the maxflow value.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlowMinCut(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)"></see>
            this method
            solves a maximum flow problem.
            </summary>
      <param name="sourceCutNM">
            return value. This map will provide a boolean value for each node
            that indicates whether or not a node belongs to the cut set associated
            with the source of the network.
            </param>
      <returns>
            the maxflow value which also corresponds to the capacity
            of all edges that cross from the cut set associated with the network source
            to the cut set associated with the network sink.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.MinCostFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Solves a minimum cost flow problem with a capacity scaling algorithm.</summary>
      <param name="graph">the network.</param>
      <param name="lCapDP">
            the lower bound on the arc flow.
            May be <see langword="null"></see>.
            </param>
      <param name="uCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="cost0DP">the costs of the arcs.</param>
      <param name="supplyDP">
            the supply/demand of the nodes.
            Supply is denoted by a positive value, demand by a
            negative value.
            </param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <param name="dualsNM">
            here the resulting dual values are stored.
            Dual values are also referred as potentials.
            May be <see langword="null"></see>.
            </param>
      <returns>the cost of the flow.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.MinCostFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Solves a min-cost flow optimization problem.</summary>
      <param name="graph">the network.</param>
      <param name="uCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="cost0DP">the costs of the arcs.</param>
      <param name="supplyDP">
            the supply/demand of the nodes.
            Supply is denoted by a positive value, demand by a
            negative value.
            </param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <param name="dualsNM">
            here the resulting dual values are stored.
            Dual values are also referred as potentials.
            </param>
      <returns>the cost of the flow.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.MinCostFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Solves a min-cost maxflow optimization problem.</summary>
      <param name="graph">the network.</param>
      <param name="s">source of the network.</param>
      <param name="t">sink of the network.</param>
      <param name="uCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="cost0DP">the costs of the arcs.</param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <param name="dualsNM">
            here the resulting dual values are stored.
            Dual values are also referred as potentials.
            </param>
      <returns>the cost of the flow.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Node">
      <summary>
            Represents a so-called node in the directed graph data type
            <see cref="T:yWorks.yFiles.Algorithms.Graph"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Instantiates a new Node object that will be part of the given graph.</summary>
      <param name="g">
            
            The graph that the created node will belong to.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.CreateCopy(yWorks.yFiles.Algorithms.Graph)">
      <summary>Creates a copy of this node that will be inserted into the given graph.</summary>
      <param name="g">
            
            The graph that the created node will belong to.
            </param>
      <returns>
            
            The newly created Node object.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Degree">
      <summary>The overall number of incoming and outgoing edges at this node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Edges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>s that can be used to iterate over the adjacent edges at this instance.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.FirstInEdge">
      <summary>
            The first incoming edge at this node, or <see langword="null"></see> if it does
            not exist.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.FirstOutEdge">
      <summary>
            The first outgoing edge at this node, or <see langword="null"></see> if it does
            not exist.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdge(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns an edge that connects this node with the given node, if such an edge
            exists.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdgeCursor">
      <summary>Returns an edge cursor for all incoming and outgoing edges at this node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdgeFrom(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns an incoming edge that connects the given node with this node, if such
            an edge exists.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdgeTo(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns an outgoing edge that connects this node with the given node, if such
            an edge exists.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor">
      <summary>Returns an edge cursor for all incoming edges at this node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns an edge cursor for incoming edges at this node.</summary>
      <param name="startEdge">
            
            The first edge being accessed by the returned cursor.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetNeighborCursor">
      <summary>Returns a node cursor for all neighbor nodes of this node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor">
      <summary>Returns an edge cursor for all outgoing edges at this node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns an edge cursor for outgoing edges at this node.</summary>
      <param name="startEdge">
            
            The first edge being accessed by the returned cursor.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetPredecessorCursor">
      <summary>Returns a node cursor for all predecessor nodes of this node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetSuccessorCursor">
      <summary>Returns a node cursor for all successor nodes of this node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Graph">
      <summary>The graph this node belongs to.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.InDegree">
      <summary>The number of incoming edges at this node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Index">
      <summary>The index of this node within its graph G.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.InEdges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>s that can be used to iterate over ingoing edges at this instance.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.LastInEdge">
      <summary>
            The last incoming edge at this node, or <see langword="null"></see> if it does
            not exist.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.LastOutEdge">
      <summary>
            The last outgoing edge at this node, or <see langword="null"></see> if it does
            not exist.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Neighbors">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Node"></see>s that can be used to iterate over the opposite sides of adjacent adjacent edges at this instance.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.OutDegree">
      <summary>The number of outgoing edges at this node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.OutEdges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>s that can be used to iterate over outgoing edges at this instance.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Predecessors">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Node"></see>s that can be used to iterate over the opposite sides of adjacent incoming edges at this instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.SortInEdges(System.Collections.IComparer)">
      <summary>Sorts incoming edges at this node according to the given comparator.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">
      <summary>Sorts outgoing edges at this node according to the given comparator.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Successors">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1"></see>
            for <see cref="T:yWorks.yFiles.Algorithms.Node"></see>s that can be used to iterate over the opposite sides of adjacent outgoing edges at this instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.ToString">
      <summary>Returns a String representation of this node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.NodeList">
      <summary>
            Specialized list implementation for instances of type
            <see cref="T:yWorks.yFiles.Algorithms.Node"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor">
      <summary>Creates an empty node list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>
            Creates a list that is initialized with the nodes provided by the given NodeCursor
            object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a list that is initialized with those nodes from the given NodeCursor
            object for which the given data provider returns <see langword="true"></see> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </summary>
      <param name="nc">
            
            A node cursor providing nodes that should be added to this list.
            </param>
      <param name="predicate">
            
            A data provider that acts as a inclusion predicate for each node accessible
            by the given node cursor.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.Node)">
      <summary>Creates a list that is initialized with a single node provided.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.Node[])">
      <summary>
            Creates a list that is initialized with the nodes provided by the given array
            of nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.NodeList)">
      <summary>Creates a list that is initialized with the entries of the given list.</summary>
      <param name="list">the values are added to the new list</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Util.IIterator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            Iterator object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.FirstNode">
      <summary>
            Returns the first node in this list, or <see langword="null"></see> when the list is
            empty.
            </summary>
      <returns>
            
            The first node in the list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.GetEnumerator"></member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.LastNode">
      <summary>Returns the last node in this list, or <see langword="null"></see> when the list is empty.</summary>
      <returns>
            
            The last node in the list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.Nodes">
      <summary>Returns a node cursor for this node list.</summary>
      <returns>
            
            A node cursor granting access to the nodes within this list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.PopNode">
      <summary>Removes the first node from this list and returns it.</summary>
      <returns>
            
            The first node from the list.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.ToNodeArray">
      <summary>Returns a node array containing all elements of this list in the canonic order.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.NodeOrders">
      <summary>
            Provides graph algorithms that order the nodes of a graph
            by a specific criterion.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.NodeOrders" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph,System.Int32[])"></see>
            but the result is returned
            as a NodeList.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>
            This method calculates a node order that is identical with
            the order of node completion events in a depth first search.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])"></see>
            but the result is returned as
            a NodeList.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>Assigns an ST-order to the nodes of a biconnected graph.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="stOrder">
            result value that holds for each node <c>v</c> the
            zero-based index within the calculated order,
            i.e <c>stOrder[v.index()] == 5</c>
            means that <c>v</c> is the 6-th node within the order.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[],yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])"></see>
            .
            </summary>
      <param name="stEdge">an edge that connects the first node of the ordering with the last node of the ordering.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.ToNodeList(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>
            Converts an array-based result yield by a method of this class
            to a NodeList that contains all nodes of the order in the
            correct sequence.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.ToNodeMap(yWorks.yFiles.Algorithms.Graph,System.Int32[],yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Copies an array-based result yield by a method of this class
            to a NodeMap that will provide values of basic type <c>int</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.ToNodeMap(yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Copies a list-based result yield by a method of this class
            to a NodeMap.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.Topological(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns a topological node order of an acyclic graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.Topological(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>Assigns a topological order to the nodes of an acyclic graph.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="order">
            result value that holds for each node <c>v</c> the
            zero-based index within the calculated order,
            i.e <c>topOrder[v.index()] == 5</c>
            means that <c>v</c> is the 6-th node within the order.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Paths">
      <summary>
            Responsible for finding paths within a graph that have
            certain properties.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Paths" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.ConstructNodePath(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Constructs a node path from a given edge path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllChains(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>Returns all chains present in the given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            an array of EdgeList objects, each of which has at least length 2.
            An edge list contains the edges that make up a chain. Method
            <see cref="M:yWorks.yFiles.Algorithms.Paths.ConstructNodePath(yWorks.yFiles.Algorithms.EdgeList)"></see>
            can be used to convert an edge path
            to a node path.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Marks all edges that belong to a directed path from <c>start</c> to <c>end</c> node.</summary>
      <param name="g">the input graph</param>
      <param name="start">the start node</param>
      <param name="end">the end node</param>
      <param name="pathEdges">
            the result. For each edge a boolean value will indicate whether or not
            it belongs to a path connecting the two nodes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongestPath(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the longest directed path within the given acyclic graph.</summary>
      <param name="g">a directed acyclic graph</param>
      <returns>
            an edge list representing the longest directed path within
            the given graph
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongestPath(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns the longest directed path within a given acyclic weighted
            graph.
            </summary>
      <param name="g">a directed acyclic graph</param>
      <param name="edgeLength">
            a data provider that must provide the length of each
            edge as an int value
            </param>
      <returns>
            an edge list representing the longest directed path within
            the given graph
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Calculates the longest path from one vertex to all other vertices
            in a given acyclic graph
            </summary>
      <param name="g">a directed acyclic graph.</param>
      <param name="startNode">the node, for which the distances are calculated.</param>
      <param name="dist">the distances for the edges.</param>
      <param name="maxDist">here the result will be stored.</param>
      <param name="predicate">only edges for which predicate is true are considered.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongPath(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns an edge list that contains the edges of a
            undirected simple path within the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindPath(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Returns an edge list that contains the edges of a path
            from the given start node to the given end node,
            if such a path exists.
            </summary>
      <param name="graph">the input graph</param>
      <param name="startNode">the first node of the path</param>
      <param name="endNode">the last node of the path</param>
      <param name="directed">whether to search for a directed or undirected path</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindPath(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Returns whether or not there is a directed path from one node to another node
            in an acyclic graph
            </summary>
      <param name="g">the acyclic graph which contains the two nodes.</param>
      <param name="topSort">a topological sorting of the nodes of the graph.</param>
      <param name="predicate">only edges for which predicate is true are considered.</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.RankAssignments">
      <summary>Provides algorithms for solving the rank assignment problem.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.RankAssignments" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simple(yWorks.yFiles.Algorithms.Graph,System.Int32[],System.Int32[])">
      <summary>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </summary>
      <param name="g">
            the graph, where all the edges have directions, such that
            rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
            </param>
      <param name="rank">the initial ranking</param>
      <param name="minLength">
            the minimal (tight) lengths for each edge. Values must be
            non-negative.
            </param>
      <returns>the number of layers.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simple(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </summary>
      <param name="g">
            the graph, where all the edges have directions, such that
            rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
            </param>
      <param name="rank">the initial ranking</param>
      <param name="minLength">
            the minimal (tight) lengths for each edge. Values must be
            non-negative.
            </param>
      <returns>the number of layers.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Solves the rank assignment problem using the simplex method.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the ranking is stored.</param>
      <param name="w">here the weight of an edge is stored.</param>
      <param name="minLength">here the minimal length of an edge is stored.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)"></see>
            .
            </summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the ranking is stored.</param>
      <param name="w">here the weight of an edge is stored.</param>
      <param name="minLength">here the minimal length of an edge is stored.</param>
      <param name="validRanking">
            if <see langword="true"></see>, the argument
            <c>layer</c> contains a valid ranking.
            </param>
      <param name="tree">may contain a valid tree solution.</param>
      <param name="_root">the root of the tree solution.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.ShortestPaths">
      <summary>
            Provides diverse algorithms and helper methods for solving the shortest path problem
            on weighted graphs.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for <b>acyclic</b> directed graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>
        <see langword="false">
        </see> if the input graph was not acyclic.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[])"></see>
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.AllPairs(yWorks.yFiles.Algorithms.Graph,System.Boolean,System.Double[],System.Double[][])">
      <summary>
            This method solves the all-pairs shortest path problem for graphs with arbitrary
            edge costs.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest path distances from all pairs of
            nodes <c>s</c> and <c>t</c> in the graph.
            The distance from <c>s</c> to <c>t</c> is
            <c>dist[s.index()][t.index()]</c>. If there is no path from <c>s</c> to <c>t</c>
            then <c>dist[s.index()][t.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>whether or not the given graph contains a negative cost cycle.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for arbitrary graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>
        <see langword="false">
        </see> if this weighted graph contains a negative cost cycle,
            <see langword="true"></see> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])"></see>
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Conveniance method that constructs an explicit edge path from the
            result yielded by one of the shortest paths methods defined in this class.
            </summary>
      <param name="s">
            the start node of the shortest path. This must be the
            same start node that was specified when <c>pred</c> was calculated.
            </param>
      <param name="t">the end node of the path</param>
      <param name="pred">
            the shortest path edge result array returned by one of the
            shortest path edge methods defined in this class.
            </param>
      <returns>
            an edge list that holds the edges on the shortest path
            from <c>s</c> to <c>t</c> in the correct order. If there
            is no path from <c>s</c> to <c>t</c> then an empty
            list is returned.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])"></see>
            with the difference that
            the path edges are given by a DataProvider.
            </summary>
      <param name="pred">
            the shortest path edge result DataProvider returned by one of the
            shortest path edge methods defined in this class.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Conveniance method that constructs an explicit node path from the
            result yielded by one of the shortest paths methods defined in this class.
            </summary>
      <param name="s">
            the start node of the shortest path. This must be the
            same start node that was specified when <c>pred</c> was calculated.
            </param>
      <param name="t">the end node of the path</param>
      <param name="pred">
            the shortest path edge result array returned by one of the
            shortest path edge methods defined in this class.
            </param>
      <returns>
            a node list that holds the nodes on the shortest path
            from <c>s</c> to <c>t</c> in the correct order. If there
            is no path from <c>s</c> to <c>t</c> then an empty
            list is returned.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])"></see>
            with the difference that
            the path edges are given by a DataProvider.
            </summary>
      <param name="pred">
            the shortest path edge result DataProvider returned by one of the
            shortest path edge methods defined in this class.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for arbitrary graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])"></see>
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.FindShortestUniformPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,System.Boolean,System.Int32,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.NodeList)">
      <summary>
            Finds all nodes and edges that belong to a shortest path from <c>start</c> to a set of target nodes in the graph not
            farther away than a given distance.
            </summary>
      <param name="graph">the input graph</param>
      <param name="start">the start node</param>
      <param name="targetMap">
            a boolean dataprovider that marks the target nodes. If the dataprovider is <see langword="null"></see>
            all nodes in the graph are assumed to be target nodes.
            </param>
      <param name="directed">whether or not to work on directed edges</param>
      <param name="maxLength">
            the maximum edge length of the shortest paths. Shortest paths
            that are longer than this value will not be considered.
            </param>
      <param name="pathEdges">the result. Contains all edges that belong to the detected shortest paths.</param>
      <param name="pathNodes">the result. Contains all nodes that belong to the detected shortest paths.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.FindShortestUniformPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Marks all edges that belong to a shortest path from <c>start</c> to <c>end</c> node.</summary>
      <param name="graph">the input graph</param>
      <param name="start">the start node</param>
      <param name="end">the end node</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="pathMap">
            the result. For each edge a boolean value will indicate whether or not
            it belongs to a shortest path connecting the two nodes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>
            This method finds the <c>k</c> shortest paths
            connecting a pair of nodes in a directed graph with non-negative edge costs.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="costDP">
            a data provider that provides a double-valued cost for each edge
            of the input graph.
            </param>
      <param name="start">start node of the shortest paths</param>
      <param name="end">the end node of the shortest paths</param>
      <param name="k">
      </param>
      <returns>
            a list of EdgeList objects each of which representing a path from
            <c>start</c> to <c>end</c> node. The i-th path in the
            list contains the i-th shortest path between <c>start</c> and <c>end</c>
            node. Note that the returned list may contain less than <c>k</c> paths in case
            there are fewer directed paths between start and end node.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPathsCursor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)"></see>
            
            that returns its result not as a list but as a special cursor that calculates
            the next path in the sequence only when needed.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for arbitrary graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>
        <see langword="false">
        </see> if this weighted graph contains a negative cost cycle,
            <see langword="true"></see> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])"></see>
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            
            but instead of returning the shortest distance between the source and sink
            the actual shortest edge path between these nodes will be returned.
            </summary>
      <returns>a shortest path between source and sink</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            This method solves the single-source single-sink shortest path problem
            for arbitrary graphs.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the source node for the shortest path search</param>
      <param name="t">the sink   node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="pred">
            return value that holds for each node <c>v</c> on the
            the shortest the path from <c>s</c> to <c>t</c> an edge
            <c>pred[v.index()]</c> which is the last edge on
            the shortest path from <c>s</c> to <c>v</c>. If <c>v == s</c> or if there
            is no shortest path from <c>s</c> to <c>v</c> then
            <c>pred[v.index()] == null</c>.
            </param>
      <returns>
            the distance between <c>s</c> and <c>t</c> if a path between these two
            nodes exist and <c>Double.POSITIVE_INFINITY</c> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)"></see>
            
            but instead of returning the shortest distance between the source and sink
            the actual shortest edge path between these nodes will be returned.
            </summary>
      <returns>a shortest path between source and sink</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])">
      <summary>
            This method solves the single-source shortest path problem for arbitrary graphs
            where each edge has a <b>uniform cost of 1.0</b>.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])"></see>
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])"></see>
            but uses NodeMaps instead of
            arrays.
            </summary>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.UniformCost(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Conveniance method that returns an array containing
            uniform edge costs of <c>1.0</c> for each edge
            of the given graph.
            </summary>
      <returns>
            an array <c>cost[]</c> that contains uniform
            edge costs of 1.0 for each edge <c>e: cost[e.index()] == 1.0</c>.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Sorting">
      <summary>
            This class provides methods for efficiently sorting graph elements in graph
            structures.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Sorting.SortNodesByDegree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Sort nodes by degree in ascending order</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Sorting.SortNodesByIntKey(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Sort nodes by an integer key associated to each node through the given data provider.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.SpanningTrees">
      <summary>Provides (minimum) spanning tree algorithms for graphs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.SpanningTrees" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Cost(yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns the overall cost of a previously calculated minimum
            spanning tree.
            </summary>
      <param name="treeEdges">edges that make up a minimum spanning tree.</param>
      <param name="edgeCost">
            a data provider that returns the double valued
            cost of each of the tree edges.
            </param>
      <returns>the overall cost of the tree edges.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Kruskal(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates a minimum spanning tree for the given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="cost">
            a data provider that must return a double value  for each
            edge in the graph.
            </param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Minimum(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Calculates a minimum spanning tree for the given graph using our
            favorite algorithm for that problem.
            </summary>
      <param name="graph">the input graph</param>
      <param name="cost">
            a data provider that must return a double value  for each
            edge in the graph.
            </param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Prim(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates a minimum spanning tree for the given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="cost">
            a data provider that must return a double value  for each
            edge in the graph.
            </param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Uniform(yWorks.yFiles.Algorithms.Graph)">
      <summary>Calculates a spanning tree for the given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Transitivity">
      <summary>
            Provides algorithms to compute reachability information for directed, acyclic
            graphs:
            <ul><li>transitive closure</li><li>transitive reduction</li></ul></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Transitivity" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calculates the transitive closure for a directed acyclic graph.<br></br><br></br>
            The reflexive, transitive closure is defined as follows:<br></br>
            Let <c>G = (V,E)</c> be an directed acyclic graph.<br></br>
            The directed acyclic graph <c>G* = (V,E*)</c> is the <em>reflexive,
            transitive closure</em> of <c>G</c>,<br></br>
            if <c>(v,w) in E*</c> iff there is a path from <c>v</c> to
            <c>w</c> in <c>G</c>.<br></br><br></br><b>REMARK:</b><br></br>
            Note, that this implementation produces the transitive closure and
            not the reflexive, transitive closure of the specified graph, since
            no self-loops are added to the specified graph.
            </summary>
      <param name="graph">input graph to which this method will add transitive edges if necessary.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph)"></see>
            , additionally this method returns the edges
            that have been added to the graph.
            </summary>
      <param name="graph">input graph to which this method will add transitive edges if necessary.</param>
      <param name="addedEdges">contains edges that have been added to the graph by this method.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph)">
      <summary>Calculates the transitive reduction for a directed acyclic graph.</summary>
      <param name="graph">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph)"></see>
            this method calculates the transitive reduction
            of a graph.
            </summary>
      <param name="graph">the input graph</param>
      <param name="transitiveEdges">
            returns the result. It will contain all transitive
            edges of the given graph. Removal of these edges will yield the transitive
            reduction of the graph.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Trees">
      <summary>
            Provides diverse algorithms and services
            for tree-structured graphs or subgraphs.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.DirectTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Reverses the edges of the given tree such that it is
            a directed rooted tree afterwards.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.DirectTree(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Reverses the edges of the given tree such that it is
            a directed rooted tree with the given node as root element.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetCenterRoot(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the center node of an undirected unrooted tree.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetLeafNodes(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>Returns all leaf nodes of the given tree.</summary>
      <param name="rooted">
            whether or not to consider the tree
            as rooted.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetNearestCommonAncestor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.NodeList)">
      <summary>Returns the nearest common ancestor of a subset of nodes within a directed rooted tree.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetRoot(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns the root node of a rooted tree (or reversed rooted tree) or
            a maximum weight center node as defined in
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph)"></see>
            or another node if the graph is not a tree.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetSubTreeDepths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns for a rooted directed tree the depths of each of its subtrees.</summary>
      <param name="tree">a rooted directed tree graph</param>
      <param name="subtreeDepthMap">
            node map that will hold for each node the depth of the subtree rooted at it. The resulting
            depth values can be retrieved using the
            map method
            <see cref="M:yWorks.yFiles.Algorithms.INodeMap.GetInt(System.Object)"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetSubTreeSizes(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns for a rooted directed tree the size (number of nodes) of each of its subtrees.</summary>
      <param name="tree">a rooted directed tree graph</param>
      <param name="subtreeSizeMap">
            node map that will hold for each node the size of the subtree rooted at it. The resulting
            size values can be retrieved using the
            map method
            <see cref="M:yWorks.yFiles.Algorithms.INodeMap.GetInt(System.Object)"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns an array of EdgeList objects each containing edges
            of the given graph that belong to maximal tree leaves
            of the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph)"></see>
            but more efficient if
            the treeNodes where calculated before by
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)"></see>
            .
            </summary>
      <param name="treeNodes">
            An array of NodeLists formerly calculated by
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a list of NodeList objects each containing nodes
            of the given graph that belong to a maximal subtree
            of the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetUndirectedTreeNodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a list of NodeList objects each containing nodes
            of the given graph that belong to a maximal subtree
            of the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Finds a node which is used by the greatest number of all paths interconnecting
            all nodes with each other.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Finds a node which is used by the greatest number of all paths interconnecting
            all nodes with each other.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsForest(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether the given graph is a forest, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsNaryTree(yWorks.yFiles.Algorithms.Graph,System.Int32)">
      <summary>
            Checks whether the given graph is a rooted tree where each
            node has a maximum of <c>n</c> successors.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsRootedTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether the given graph is a rooted tree.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is an undirected tree.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.YList">
      <summary>
            An implementation of a doubly linked list that provides direct access to the
            cells that store the elements.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor">
      <summary>Creates an empty doubly linked list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(System.Collections.IEnumerator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            enumerator object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(System.Object[])">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            array of objects.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Algorithms.ICursor)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            YCursor object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Algorithms.ICursor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a list that is initialized with those elements from the given YCursor
            object for which the given data provider returns <see langword="true"></see> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </summary>
      <param name="c">
            
            A cursor providing objects that should be added to this list.
            </param>
      <param name="predicate">
            
            A data provider that acts as a inclusion predicate for each object accessible
            by the given cursor.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Util.ICollection)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            Collection object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Util.IIterator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            iterator object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Add(System.Int32,System.Object)">
      <summary>Inserts the specified object into this Vector at the specified location.</summary>
      <param name="location">the index at which to insert</param>
      <param name="object">the object to add</param>
      <exception cref="T:System.NotSupportedException">when adding to this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of the object is inappropriate for this
            List
            </exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to this List</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Add(System.Object)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.YList.AddLast(System.Object)"></see>
            .
            </summary>
      <returns>
        <see langword="true">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddAll(System.Int32,yWorks.yFiles.Util.ICollection)">
      <summary>
            Inserts the objects in the specified Collection at the specified location
            in this List.
            </summary>
      <param name="location">the index at which to insert</param>
      <param name="collection">the Collection of objects</param>
      <returns>true if this List is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when adding to this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of an object is inappropriate for this List</exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this List</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddAll(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Appends all elements provided by the given cursor to this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>Appends all elements provided by the given collection to this list.</summary>
      <returns>Whether there have been elements appended.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddFirst(System.Object)">
      <summary>Inserts the given object at the head of this list.</summary>
      <returns>
            
            The newly created ListCell object that stores the given object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddFirstCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Adds a formerly removed ListCell object at the head of this list.</summary>
      <param name="cell">
            
            A list cell which is not part of any list.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddLast(System.Object)">
      <summary>Inserts the given object at the tail of this list.</summary>
      <returns>
            
            The newly created ListCell object that stores the given object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddLastCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Adds a formerly removed ListCell object at the tail of this list.</summary>
      <param name="cell">
            
            A list cell which is not part of any list.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Clear">
      <summary>Removes all elements from this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Contains(System.Object)">
      <summary>Whether or not this list contains the given element.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ContainsAll(yWorks.yFiles.Util.ICollection)">
      <summary>Whether or not this list contains all the elements in the given collection.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CopyTo(System.Array,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CopyTo(System.Object[],System.Int32)"></member>
    <member name="P:yWorks.yFiles.Algorithms.YList.Count">
      <summary>The number of elements in this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Cursor">
      <summary>Returns a cursor for this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CyclicPred(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the cyclic predecessor cell of the given list cell.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CyclicSucc(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the cyclic successor cell of the given list cell.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ElementAt(System.Int32)">
      <summary>Returns the i-th element of this list.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.Empty">
      <summary>Checks whether this list contains elements.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Equals(System.Object)">
      <summary>
                    Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
                </summary>
      <param name="obj">
                    The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. 
                </param>
      <param name="object">Object the object to compare with this object.</param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
                </returns>
      <exception cref="T:System.NullReferenceException">
                    The <paramref name="obj" /> parameter is null.
                </exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.FindCell(System.Object)">
      <summary>
            Returns the
            <see cref="T:yWorks.yFiles.Algorithms.ListCell"></see>
            where object <c>o</c> is stored.
            </summary>
      <returns>
            the ListCell that contains the element or <see langword="null"></see> if no
            such ListCell was found
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.First">
      <summary>The first element of this list.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.FirstCell">
      <summary>The first cell of this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Get(System.Int32)">
      <summary>Answers the element at the specified location in this List.</summary>
      <param name="location">the index of the element to return</param>
      <returns>the element at the specified location</returns>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetCell(System.Int32)">
      <summary>Gets the cell at the given index.</summary>
      <param name="index">the zero-based index of the cell in this list.</param>
      <returns>The cell.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
            if the index is negative or greater or equal than the
            <see cref="P:yWorks.yFiles.Algorithms.YList.Count"></see></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetEnumerator"></member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetInfo(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the element stored in the given list cell.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.IndexOf(System.Object)">
      <summary>Returns the zero-based index of the given element in this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Insert(System.Int32,System.Object)"></member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertAfter(System.Object,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts the given object into this list with respect to a given reference list
            cell.
            </summary>
      <param name="o">
            
            The object to be inserted.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
      <returns>
            
            The newly created ListCell object that stores object <c>o</c>.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertBefore(System.Object,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts the given object into this list with respect to a given reference list
            cell.
            </summary>
      <param name="o">
            
            The object to be inserted.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
      <returns>
            
            The newly created ListCell object that stores object <c>o</c>.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertCellAfter(yWorks.yFiles.Algorithms.ListCell,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts a formerly removed ListCell object into this list with respect to a
            given reference list cell.
            </summary>
      <param name="cellToInsert">
            
            A list cell which is not part of any list.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertCellBefore(yWorks.yFiles.Algorithms.ListCell,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts a formerly removed ListCell object into this list with respect to a
            given reference list cell.
            </summary>
      <param name="cellToInsert">
            
            A list cell which is not part of any list.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.IsFixedSize"></member>
    <member name="P:yWorks.yFiles.Algorithms.YList.IsSynchronized"></member>
    <member name="P:yWorks.yFiles.Algorithms.YList.Item(System.Int32)"></member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Iterator">
      <summary>Returns an iterator for that list.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.Last">
      <summary>The last element of this list.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.LastCell">
      <summary>The last cell of this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.LastIndexOf(System.Object)">
      <summary>
            Searches this List for the specified object and returns the index of the
            last occurrence.
            </summary>
      <param name="object">the object to search for</param>
      <returns>the index of the last occurrence of the object</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListIterator">
      <summary>Answers a ListIterator on the elements of this List.</summary>
      <returns>a ListIterator on the elements of this List</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListIterator(System.Int32)">
      <summary>Answers a ListIterator on the elements of this List.</summary>
      <param name="location">the index at which to start the iteration</param>
      <returns>a ListIterator on the elements of this List</returns>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.NewInstance``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Creates a list that is initialized with the elements stored in the given
            collection.
            </summary>
      <typeparam name="T">
        <p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[Missing &lt;typeparam name="T"/&gt; documentation for "M:yWorks.yFiles.Algorithms.YList.NewInstance``1(System.Collections.Generic.ICollection{``0})"]</p>
      </typeparam>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.NewInstance(System.Collections.ICollection)">
      <summary>
            Creates a list that is initialized with the elements stored in the given
            collection.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Peek">
      <summary>
            Equivalent to
            <see cref="P:yWorks.yFiles.Algorithms.YList.First"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Pop">
      <summary>Removes the first element from this list and returns it.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.PopLast">
      <summary>Removes the last element from this list and returns it.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.PredCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the predecessor cell of the given list cell.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Push(System.Object)">
      <summary>
            Equivalent to
            <see cref="M:yWorks.yFiles.Algorithms.YList.AddFirst(System.Object)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Remove(System.Int32)">
      <summary>Removes the object at the specified location from this List.</summary>
      <param name="location">the index of the object to remove</param>
      <returns>the removed object</returns>
      <exception cref="T:System.NotSupportedException">when removing from this List is not supported</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Remove(System.Object)">
      <summary>Removes the given object from this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>Removes the given collection of objects from this list.</summary>
      <returns>
            
            Whether there have been elements removed.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RemoveAt(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Removes the element pointed to by the given YCursor object.</summary>
      <returns>
            
            The removed element.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RemoveCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Removes the given list cell, and hence the element stored in it, from this
            list.
            </summary>
      <returns>
            
            The element that is stored in the removed cell.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RetainAll(yWorks.yFiles.Util.ICollection)">
      <summary>Retains only those elements in this list which are contained in the given collection.</summary>
      <returns>Whether there have been elements removed.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Reverse">
      <summary>Reverses the sequence of elements in this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Set(System.Int32,System.Object)">
      <summary>
            Replaces the element at the specified location in this List with the
            specified object.
            </summary>
      <param name="location">the index at which to put the specified object</param>
      <param name="object">the object to add</param>
      <returns>the previous element at the index</returns>
      <exception cref="T:System.NotSupportedException">when replacing elements in this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of an object is inappropriate for this List</exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this List</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.SetInfo(yWorks.yFiles.Algorithms.ListCell,System.Object)">
      <summary>Updates the element stored in the given list cell with the given object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Sort">
      <summary>
            Sorts the elements in this list into ascending order, according to their natural
            ordering.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Sort(System.Collections.IComparer)">
      <summary>Sorts the elements in this list according to the given comparator.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Splice(yWorks.yFiles.Algorithms.YList)">
      <summary>Transfers the contents of the given list to the end of this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.SubList(System.Int32,System.Int32)">
      <summary>
            Answers a List of the specified portion of this List from the start index
            to one less than the end index.
            </summary>
      <param name="start">the index at which to start the sublist</param>
      <param name="end">the index one past the end of the sublist</param>
      <returns>a List of a portion of this List</returns>
      <exception cref="T:System.IndexOutOfRangeException">
            when <c>start &lt; 0, start &gt; end</c> or
            <c>end &gt; size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.SuccCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the successor cell of the given list cell.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.SyncRoot"></member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ToArray">
      <summary>Returns an array representation of this list.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ToArray(System.Array)">
      <summary>Returns an array containing all list elements in the correct order.</summary>
      <param name="a">
            
            The array into which the elements of the list are to be stored, if it is big
            enough.
            Otherwise, a new array of the same runtime type is allocated for this purpose.
            </param>
      <returns>
            
            An array containing the elements of the list.
            </returns>
      <exception cref="T:System.ArrayTypeMismatchException">
            if the runtime type of the specified array <c>a</c>
            is not a supertype of the runtime type of every element in this list.
            </exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ToString">
      <summary>Returns a string representation of this List.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.YList.ListCursorImpl">
      <summary>Cursor implementation for class YList.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.#ctor(yWorks.yFiles.Algorithms.YList)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.YList.ListCursorImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Current">
      <summary>The object currently pointed on.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Next">
      <summary>Moves this cursor one position forward.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Ok">
      <summary>
        <see langword="true">
        </see> if the current cursor position is valid.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Prev">
      <summary>Moves this cursor one position backward (optional).</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Size">
      <summary>The number of elements that can be accessed with this cursor.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.ToFirst">
      <summary>Moves this cursor to the first valid cursor position (optional).</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.ToLast">
      <summary>Moves this cursor to the last valid cursor position (optional).</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.AffineLine">
      <summary>This class represents a line in the 2D-dimensional affine space.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Creates an affine line which is defined by two points.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Creates an affine line which is defined by a point
            and a vector.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.AffineLine.A">
      <summary>A from ax+by+c = 0</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.AffineLine.B">
      <summary>B from ax+by+c = 0</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.AffineLine.C">
      <summary>C from ax+by+c = 0</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.GetCrossing(yWorks.yFiles.Algorithms.Geometry.AffineLine,yWorks.yFiles.Algorithms.Geometry.AffineLine)">
      <summary>Returns the crossing of two lines.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.GetXProjection(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Projects an point on the line in direction of the X-axis.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.GetYProjection(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Projects an point on the line in direction of the Y-axis.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.ToString">
      <summary>Returns the equation of the line as String</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.BorderLine">
      <summary>
            This class can be used to easily model an orthogonal
            border line or sky-line.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.#ctor(System.Double)">
      <summary>
            Creates a new BorderLine with the given value
            from -Double.MAX_VALUE to Double.MAX_VALUE.
            </summary>
      <param name="value">the value of the segment</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.#ctor(System.Double,System.Double,System.Double)">
      <summary>Creates a new BorderLine from a single segment.</summary>
      <param name="min">the beginning of this borderline</param>
      <param name="max">the ending of this borderline</param>
      <param name="value">the value of the segment</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.AddOffset(System.Double)">
      <summary>Adds the given offset to the segments' positions.</summary>
      <param name="delta">the delta to add to the positions</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.AddValueOffset(System.Double)">
      <summary>
            Adds the given offset to the current values of
            the whole borderline.
            </summary>
      <param name="delta">the delta to add to the values</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.AdoptValues(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Convenience method that copies the actual data from the given
            argument to this instance.
            </summary>
      <param name="other">the argument to retrieve the values from</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.CreateCopy(System.Boolean,System.Boolean)">
      <summary>Creates a copy of this borderline.</summary>
      <param name="negateValues">whether the values are negated</param>
      <param name="negateOffsets">whether the offsets are negated</param>
      <returns>the copy of the borderline</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.CreateMax(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "maximum" policy.
            </summary>
      <param name="other">the other borderline</param>
      <returns>a new borderline that is the result of the merge</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.CreateMin(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "minimum" policy.
            </summary>
      <param name="other">the other borderline</param>
      <returns>a new borderline that is the result of the merge</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.FirstSegment">
      <summary>
            Returns the first segment or <see langword="null"></see> if there is
            no such segment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetDistanceTo(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>Calculates the minimal distance between this borderline and the other one.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMax(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>Returns the maximum position of the given segment.</summary>
      <param name="s">the segment</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMaxValue(System.Double,System.Double)">
      <summary>Calculates the maximum value in the interval from-&gt;to.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMin(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>Returns the minimum position of the given segment.</summary>
      <param name="s">the segment</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMinValue(System.Double,System.Double)">
      <summary>Calculates the minimum value in the interval from-&gt;to.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetSegmentAt(System.Double)">
      <summary>Returns the segment at the given position.</summary>
      <param name="pos">the position</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValue(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>Returns the value of the given segment.</summary>
      <param name="s">the segment</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValueAt(System.Double)">
      <summary>
            Returns the value that is set on this borderline
            at the specified position.
            </summary>
      <param name="pos">the position</param>
      <returns>the value</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Grow(System.Double,System.Double,System.Boolean)">
      <summary>
            Grows this BorderLine horizontally, so that the
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValue(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">values</see>
            of the BorderLine stay the same however their
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMin(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">start</see>
            and
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMax(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">end</see>
            points are moved in the direction of <c>toMin</c>
            and <c>toMax</c>.
            </summary>
      <param name="toMin">the delta by which the border should be extended towards -Infinity</param>
      <param name="toMax">the delta by which the border should be extended towards +Infinity</param>
      <param name="positive">
            whether the BorderLine should be interpreted to point in positive direction. This influences the
            direction into which a segment's border is extended.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.LastSegment">
      <summary>
            Returns the last segment or <see langword="null"></see> if there is
            no such segment.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.Max">
      <summary>The greatest position of this borderline</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.MaxValue">
      <summary>The maximum value that is set on this borderline</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.MergeWithMax(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "maximum" policy.
            </summary>
      <param name="other">the other borderline</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.MergeWithMin(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "minimum" policy.
            </summary>
      <param name="other">the other borderline</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.Min">
      <summary>The smallest position of this borderline</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.MinValue">
      <summary>The minimum value that is set on this borderline</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Next(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
            Returns the next segment or <see langword="null"></see> if there is
            no such segment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Prev(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
            Returns the previous segment or <see langword="null"></see> if there is
            no such segment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.SetMaxValue(System.Double,System.Double,System.Double)">
      <summary>Assures that all values in the given interval are greater or equal than the given value.</summary>
      <param name="min">the lower end of the interval</param>
      <param name="max">the upper end of the interval</param>
      <param name="value">the smallest possible value for the interval</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.SetMinValue(System.Double,System.Double,System.Double)">
      <summary>Assures that all values in the given interval are less or equal than the given value.</summary>
      <param name="min">the lower end of the interval</param>
      <param name="max">the upper end of the interval</param>
      <param name="value">the greatest possible value for the interval</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.SetValue(System.Double,System.Double,System.Double)">
      <summary>Sets a specific interval to a given value.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.ToString">
      <summary>Returns a lengthy String representation of this borderline.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment">
      <summary>The handle of a segment of a borderline.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment.Next">
      <summary>
            Returns the next segment or <see langword="null"></see> if there is
            no such segment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment.Prev">
      <summary>
            Returns the previous segment or <see langword="null"></see> if there is
            no such segment.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.Geom">
      <summary>
            This class provides useful geometric primitives and advanced
            geometric algorithms.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.CalcConvexHull(yWorks.yFiles.Algorithms.YList)">
      <summary>Calculates the convex hull for a set of points.</summary>
      <param name="points">a list of YPoint objects</param>
      <returns>
            a list of YPoint objects that constitute the convex hull of the given
            points. The list contains points in counterclockwise order around the hull.
            the first point is the one with the smallest <c>x</c> coordinate.
            If two such points exist then of these points the one with the smallest
            <c>y</c> coordinate is chosen as the first one.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.CalcIntersection(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Intersects the pair of specified source <c>Rectangle2D</c>
            objects and puts the result into the specified destination
            <c>Rectangle2D</c> object.
            </summary>
      <param name="r1">
            the first of a pair of <c>Rectangle2D</c>
            objects to be intersected with each other
            </param>
      <param name="r2">
            the second of a pair of <c>Rectangle2D</c>
            objects to be intersected with each other
            </param>
      <param name="dest">
            the <c>Rectangle2D</c> that holds the
            results of the intersection of <c>r1</c> and
            <c>r2</c></param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.CalcUnion(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Unions the pair of source <c>Rectangle2D</c> objects
            and puts the result into the specified destination
            <c>Rectangle2D</c> object.
            </summary>
      <param name="r1">
            the first of a pair of <c>Rectangle2D</c>
            objects to be combined with each other
            </param>
      <param name="r2">
            the second of a pair of <c>Rectangle2D</c>
            objects to be combined with each other
            </param>
      <param name="dest">
            the <c>Rectangle2D</c> that holds the
            results of the union of <c>r1</c> and
            <c>r2</c></param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Collinear(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns <see langword="true"></see> iff the given points are collinear, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.DistanceToLineSegment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Determines the distance of the point <c>p</c> to the line segment
            <c>[l1, l2]</c>.
            </summary>
      <param name="pointX">the x coordinate of p</param>
      <param name="pointY">the y coordinate of p</param>
      <param name="lineX1">the x coordinate of l1</param>
      <param name="lineY1">the y coordinate of l1</param>
      <param name="lineX2">the x coordinate of l2</param>
      <param name="lineY2">the y coordinate of l2</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.LeftTurn(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) &gt; 0</see></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.LinesIntersect(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Same as
            <see cref="!:yWorks.yFiles.Util.Geom.Line2D.LinesIntersect(double,double,double,double,double,double,double,double)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)"></see>
            with double values as arguments.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns the orientation of point <c>r</c> relative to the directed
            line  from point <c>p</c> to point <c>q</c>.
            </summary>
      <returns>
        <b>+1</b> in the case of positive orientation, <b>-1</b> in the
            case of  negative orientation and <b>0</b> in the case of zero
            orientation.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Projection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Determines the projection of the point <c>p</c> onto the line
            segment <c>[l1, l2]</c>.
            </summary>
      <param name="pointX">the x coordinate of p</param>
      <param name="pointY">the y coordinate of p</param>
      <param name="lineX1">the x coordinate of l1</param>
      <param name="lineY1">the y coordinate of l1</param>
      <param name="lineX2">the x coordinate of l2</param>
      <param name="lineY2">the y coordinate of l2</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.RightTurn(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) &lt; 0</see></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.SideOfCircle(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns +1 if point <c>d</c> lies left of the directed circle through
            points <c>a</c>, <c>b</c>, and <c>c</c>,
            0 if <c>a,b,c</c> and <c>d</c> are cocircular, and -1 otherwise.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.ToDegrees(System.Double)">
      <summary>
            Same as
            <see cref="!:System.Math.ToDegrees(double)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.ToRadians(System.Double)">
      <summary>
            Same as
            <see cref="!:System.Math.ToRadians(double)"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.ILineSegmentCursor">
      <summary>This is an interface for a sequence of instances of LineSegment.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.ILineSegmentCursor.LineSegment">
      <summary>The instance of LineSegment the cursor is currently pointing on.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm">
      <summary>
            This class calculates the intersection of rectangles in the plane with
            the help of a sweep-line algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.CreateXStruct(yWorks.yFiles.Algorithms.YList)">
      <summary>Initializes the sweepline data structures from a set of objects.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.Intersect(yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler)">
      <summary>Calculates the intersections of rectangles in the plane.</summary>
      <param name="objects">a list of <c>PlaneObject</c> objects.</param>
      <param name="iHandler">intersections are reported to this class.</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler">
      <summary>
            An instance of this interface handles intersections found by the
            <c>IntersectionAlgorithm</c>,
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler.CheckIntersection(System.Object,System.Object)">
      <summary>This method is called at every intersection.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IPlaneObject">
      <summary>
            This interface describes a 2-dimensional object which has a finite
            bounding box.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.IPlaneObject.BoundingBox">
      <summary>The smallest Rectangle which contains the object.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IPointCursor">
      <summary>This is an interface for a sequence of instances of YPoint.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.IPointCursor.Point">
      <summary>The instance of YPoint the cursor is currently pointing on.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.LineSegment">
      <summary>This class represents a line segment in the plane.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns a new LineSegment.</summary>
      <param name="p1">the first end point of the line segment.</param>
      <param name="p2">the second end point of the line segment.</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.BoundingBox">
      <summary>The smallest Rectangle which contains the object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(yWorks.yFiles.Algorithms.Geometry.YRectangle,System.Double,System.Double,System.Double,System.Double)">
      <summary>Checks whether a line segment intersects a box.</summary>
      <param name="box">A rectangle</param>
      <param name="x1">X-coordinate of start point of vector</param>
      <param name="y1">Y-coordinate of start point of vector</param>
      <param name="x2">X-coordinate of target point of vector</param>
      <param name="y2">Y-coordinate of target point of vector</param>
      <returns>
        <see langword="true">
        </see> if the line segments intersects the box,
            <see langword="false"></see> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Checks whether a line segment intersects a box.</summary>
      <param name="box">A rectangle.</param>
      <param name="s">first end point of the line segment.</param>
      <param name="t">second end point of the line segment.</param>
      <returns>
        <see langword="true">
        </see> if the line segments intersects the box,
            <see langword="false"></see> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Contains(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Checks whether a given point lies on  this line segment.</summary>
      <param name="point">an arbitrary point.</param>
      <returns>
        <see langword="true">
        </see> if the line segments intersects the box,
            <see langword="false"></see> otherwise.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.FirstEndPoint">
      <summary>The first end point of the line segment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.GetIntersection(yWorks.yFiles.Algorithms.Geometry.LineSegment,yWorks.yFiles.Algorithms.Geometry.LineSegment)">
      <summary>
            Returns intersection point between the two line segments, if there is
            one or <see langword="null"></see> if the two line segments do not intersect.
            </summary>
      <param name="s1">first line segment</param>
      <param name="s2">second line segment</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Intersects(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Checks whether the line segment intersects a point.</summary>
      <param name="p">a point</param>
      <returns>
        <see langword="true">
        </see> if the line segments intersects the box,
            <see langword="false"></see> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Intersects(yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Checks whether the line segment intersects a box.</summary>
      <param name="box">A rectangle.</param>
      <returns>
        <see langword="true">
        </see> if the line segments intersects the box,
            <see langword="false"></see> otherwise.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.IsInXIntervall(System.Double)">
      <summary>
            Returns if the projection on the X axis of the line segment
            covers a certain point on the X Axis.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.IsInYIntervall(System.Double)">
      <summary>
            Returns if the projection on the Y axis of the line segment
            covers a certain point on the Y Axis.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Length">
      <summary>
            Returns the length of the line segment,
            this is the value of the Euclidean norm.
            </summary>
      <returns>an value &gt; 0.</returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.Scope">
      <summary>The scope of the line segment.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.SecondEndPoint">
      <summary>The second end point of the line segment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.ToAffineLine">
      <summary>
            Returns the affine line defined by the end points of the
            line segment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.ToString">
      <summary>String representation of the line.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.ToYVector">
      <summary>
            Returns the vector pointing from the first end point to the second
            end point of the line segment.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.XOffset">
      <summary>The y value of the line on x coordinate 0.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.Triangulator">
      <summary>
            This class provides algorithms for the triangulation of point
            sets in the plane.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Geometry.Triangulator" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.CalcDelauneyTriangulation(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Computes a Delauney triangulation of the given points.</summary>
      <param name="result">
            a graph whose nodes represent the points that need
            to be triangulated.
            </param>
      <param name="pointData">must provide the location (YPoint) for each node in the given graph.</param>
      <param name="revMap">
            a node map that will contain for each edge its reverse
            edge. If this argument is <see langword="null"></see> then no reverse edge information
            will be available.
            </param>
      <returns>an edge on the outer face of the result graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.TriangulatePoints(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Computes a triangulation of the given points.</summary>
      <param name="result">
            a graph whose nodes represent the points that need
            to be triangulated.
            </param>
      <param name="pointData">must provide the location (YPoint) for each node in the given graph.</param>
      <param name="reverseEdgeMap">
            a node map that will contain for each edge its reverse
            edge. If this argument is <see langword="null"></see> then no reverse edge information
            will be available.
            </param>
      <returns>an edge on the outer face of the result graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.TriangulatePoints(yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Computes a triangulation of the given points.</summary>
      <param name="points">
            the point set to be triangulated. The points must be provided
            as a YList of YPoints.
            </param>
      <param name="result">the resulting triangulation</param>
      <param name="resultMap">the node map that forms the link between a point and a node.</param>
      <param name="reverseEdgeMap">
            a node map that will contain for each edge its reverse
            edge. If this argument is <see langword="null"></see> then no reverse edge information
            will be available.
            </param>
      <returns>an edge on the outer face of the result graph.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YDimension">
      <summary>This class represents the size of an object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.#ctor(System.Double,System.Double)">
      <summary>Creates a new YDimension2D object for given size.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.CompareTo(System.Object)">
      <summary>
                    Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
                </summary>
      <param name="obj">
                    An object to compare with this instance. 
                </param>
      <returns>
                    A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: 
                
                    Value 
                
                    Meaning 
                
                    Less than zero 
                
                    This instance is less than <paramref name="obj" />. 
                
                    Zero 
                
                    This instance is equal to <paramref name="obj" />. 
                
                    Greater than zero 
                
                    This instance is greater than <paramref name="obj" />. 
                </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. 
                </exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.Equals(System.Object)">
      <summary>Tests a dimension to equality to another dimension.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YDimension.Height">
      <summary>The height of the dimension object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.ToString">
      <summary>Returns the size in the form: "W: width H: height"</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YDimension.Width">
      <summary>The width of the dimension object.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YPoint">
      <summary>This class represents a point in the plane with double coordinates.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.#ctor">
      <summary>Creates a new YPoint at location (0,0)</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.#ctor(System.Double,System.Double)">
      <summary>Creates a new YPoint object for a given position.</summary>
      <param name="x">the x coordinate of the point.</param>
      <param name="y">the y coordinate of the point.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Add(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Adds two points and return the result.</summary>
      <param name="p1">an arbitrary instance of YPoint.</param>
      <param name="p2">an arbitrary instance of YPoint.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.CompareTo(System.Object)">
      <summary>Comparable implementation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Distance(System.Double,System.Double,System.Double,System.Double)">
      <summary>Returns the euclidean distance between two points.</summary>
      <param name="x1">x-coord of first point</param>
      <param name="y1">y-coord of first point</param>
      <param name="x2">x-coord of second point</param>
      <param name="y2">y-coord of second point</param>
      <returns>the euclidean distance between first and second point</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Distance(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns the euclidean distance between two points.</summary>
      <param name="p1">an arbitrary point</param>
      <param name="p2">an arbitrary point</param>
      <returns>the Euclidean distance between p1 and p2.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.DistanceTo(System.Double,System.Double)">
      <summary>Returns the euclidean distance between this point and a given point.</summary>
      <param name="x">the x coordinate of an arbitrary point</param>
      <param name="y">the y coordinate of an arbitrary point</param>
      <returns>the Euclidean distance between this point and the point (x,y).</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.DistanceTo(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns the euclidean distance between this point and a given point.</summary>
      <param name="p">an arbitrary point</param>
      <returns>the Euclidean distance between this point and p.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Equals(System.Object)">
      <summary>Tests a point to equality to another point.</summary>
      <param name="o">an arbitrary instance.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.MidPoint(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns a point that geometrically lies in
            in the middle of the line formed by the given points.
            </summary>
      <param name="p1">an arbitrary instance of YPoint.</param>
      <param name="p2">an arbitrary instance of YPoint.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.MoveBy(System.Double,System.Double)">
      <summary>Returns the point, got by moving this point to another position.</summary>
      <param name="x">the value which is added on the x-coordinate of the point.</param>
      <param name="y">the value which is added on the y-coordinate of the point.</param>
      <returns>
            a new instance of YPoint which is the result of the moving
            operation.
            </returns>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Geometry.YPoint.Origin">
      <summary>A YPoint constant with coordinates (0,0).</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Swap(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns a copy of the given point with exchanged
            x- and y-coordinates.
            </summary>
      <param name="p">an arbitrary instance of YPoint.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.ToString">
      <summary>Returns the coordinates of the point as string.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPoint.X">
      <summary>The x-coordinate of the point object.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPoint.Y">
      <summary>The y-coordinate of the point object.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YPointPath">
      <summary>This class represents an ordered list of points in the plane.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.#ctor">
      <summary>Creates a new path from a vector.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint[])">
      <summary>Creates a new path from an array of points.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.CalculateLength">
      <summary>Calculate the (geometric) length of the path (sum of lengths of all line segements)</summary>
      <returns>the (geometric) length of the path</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.CreateReverse">
      <summary>Create a point path with reverse ordering of the points.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Cursor">
      <summary>Get the points in the path.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Geometry.YPointPath.EmptyPath">
      <summary>Defines a path with no points.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPointPath.First">
      <summary>The first point in the path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.GetLineSegment(System.Int32)">
      <summary>Returns a line segment in the path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Iterator">
      <summary>Get the points in the path.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPointPath.Last">
      <summary>The last point in the path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Length">
      <summary>Get the number of points in the path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.LineSegments">
      <summary>Get the points in the path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Points">
      <summary>Get the points in the path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.ToArray">
      <summary>Get the points in the list as array.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YRectangle">
      <summary>This class defines a rectangle and provides utility methods for it.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.#ctor">
      <summary>Creates a new rectangle with upper left corner (0,0) and size (0,0).</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new rectangle with given upper left corner and size.</summary>
      <param name="x">x-coordinate of upper left corner of the rectangle.</param>
      <param name="y">y-coordinate of upper left corner of the rectangle.</param>
      <param name="width">width of the rectangle.</param>
      <param name="height">height of the rectangle.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Creates a new rectangle with given upper left corner and size.</summary>
      <param name="pos">upper left corner of the rectangle.</param>
      <param name="size">size of the rectangle.</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.BoundingBox">
      <summary>This object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.CompareTo(System.Object)">
      <summary>
                    Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
                </summary>
      <param name="obj">
                    An object to compare with this instance. 
                </param>
      <returns>
                    A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: 
                
                    Value 
                
                    Meaning 
                
                    Less than zero 
                
                    This instance is less than <paramref name="obj" />. 
                
                    Zero 
                
                    This instance is equal to <paramref name="obj" />. 
                
                    Greater than zero 
                
                    This instance is greater than <paramref name="obj" />. 
                </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. 
                </exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double)">
      <summary>
            checks whether or not this <c>YRectangle</c> contains the
            given point.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            checks whether or not this <c>YRectangle</c> contains the
            rectangle defined by the given frame.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            checks whether or not this <c>YRectangle</c> contains the
            given point.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>
            checks whether or not this <c>YRectangle</c> contains the
            given rectangle.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Equals(System.Object)">
      <summary>Tests a dimension to equality to another dimension.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Intersects(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Returns whether or not the given rectangles intersect.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.Location">
      <summary>Coordinates of upper left corner.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.ToString">
      <summary>Returns a string representation of this rectangle</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.X">
      <summary>X-coordinate of upper left corner.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.Y">
      <summary>Y-coordinate of upper left corner.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YVector">
      <summary>This class represents a vector in the 2-dimensional real vector space.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(System.Double,System.Double)">
      <summary>Creates a new vector with given direction.</summary>
      <param name="dx">the first coordinate</param>
      <param name="dy">the second coordinate</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new vector, whose direction is given by two points.</summary>
      <param name="x1">the X-coordinate of the first point.</param>
      <param name="y1">the Y-coordinate of the first point.</param>
      <param name="x2">the X-coordinate of the second point.</param>
      <param name="y2">the Y-coordinate of the second point.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Creates a new vector, whose direction is given by a point.</summary>
      <param name="p1">the point.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Creates a new vector, whose direction is given by two points.</summary>
      <param name="p1">the first point.</param>
      <param name="p2">the second point.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Creates a new vector which is a copy of another vector.</summary>
      <param name="v">the vector, whose values are copied.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Add(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Adds the vector to a point and returns the resulting point.</summary>
      <param name="p">a point.</param>
      <param name="v">the vector to add to the point.</param>
      <returns>p+v</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Add(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Adds a vector to this vector.</summary>
      <param name="v">the vector to add.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Add(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Adds two vectors and returns the result.</summary>
      <param name="v">first vector to sum.</param>
      <param name="w">second vector to sum.</param>
      <returns>v+w</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Angle(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Returns the angle between two vectors in counter clockwise order from
            v1 to v2.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.GetNormal(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Returns this vector with unit length.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Length">
      <summary>Returns the length of the vector, this is the value of the euclidean norm.</summary>
      <returns>a value &gt; 0.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Norm">
      <summary>Assigns unit length to the vector.<br></br></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.OrthoNormal(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Returns the vector which is orthogonal to the given one and has unit
            length.
            </summary>
      <param name="v">a vector.</param>
      <returns>a vector which is orthogonal to v with unit length.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.RightOf(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Returns true if vector v1 is on the right side of v2.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.ScalarProduct(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Returns the value of the scalar product of two vectors.</summary>
      <param name="v1">the first vector.</param>
      <param name="v2">the second vector.</param>
      <returns>
        <c>v1.x * v2.x + v1.y * v2.y</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Scale(System.Double)">
      <summary>Scales the vector by an factor.</summary>
      <param name="factor">the scale factor, with which the length is multiplied.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.ToString">
      <summary>Returns a string representation of this vector.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YVector.X">
      <summary>The first coordinate of the vector.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YVector.Y">
      <summary>The second coordinate of the vector.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ">
      <summary>
            Implements a priority queue for nodes based on a
            array with bucket lists.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,System.Int32)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="maxSize">the maximum value of a node in the priority queue</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a new Priority-Queue initialized with all nodes of the graph.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="_initValues">the initial priority values of the nodes.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="_valueMap">here the priority values are stored</param>
      <param name="maxSize">the maximum value of a node in the priority queue</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Inserts a node into the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Changes the value of a node in the queue to a certain value.</summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the value of a node in the queue to a certain value.<br></br></summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.GetList(System.Int32)">
      <summary>Returns the list for a given slot.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Increases the value of a node in the queue to a certain value.<br></br></summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Min">
      <summary>The node with the minimal value in the queue.<br></br></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Removes a node from the priority queue.<br></br>
            Time complexity in worst-case O(maxSize).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.RemoveMin">
      <summary>
            Removes the node with the minimal value from the queue.<br></br>
            Time complexity like
            <see cref="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ">
      <summary>
            This class implements a priority queue for nodes whose priority
            values are of type double.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Adds the given node with with given priority to this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Changes the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Decreases the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Dispose">
      <summary>Does nothing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Double)"></member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ">
      <summary>
            This class implements a priority queue for nodes whose priority
            values are of type int.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Adds the given node with with given priority to this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Changes the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Dispose">
      <summary>Does nothing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Increases the priority value of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.BHeapNodePQ">
      <summary>
            This class represents a priority queue for nodes where
            the priority values are of type Object
            The implementation is based on binary heaps.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,System.Collections.IComparer)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,System.Collections.IComparer,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Adds the given node with with given priority to this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Changes the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Decreases the priority value of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Object)"></member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Comparators">
      <summary>
            This class provides access to some Comparator instances
            that are commonly used in yFiles.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateComparableComparator">
      <summary>
            Returns a comparator that compares to Objects of type
            Comparable.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateComparableDataComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a comparator that compares objects of arbitrary type.</summary>
      <param name="dp">
            a data provider that must return a Comparable for
            each object that is being compared by this comparator.
            </param>
      <returns>a comparator that compares arbitrary objects.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateDoubleDataComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a comparator that compares objects of arbitrary type.</summary>
      <param name="dp">
            a data provider that must return a double value for
            each object that is being compared by this comparator.
            </param>
      <returns>a comparator that compares arbitrary objects.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateDoubleDataSourceComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
      <param name="dp">
            a data provider that must return a double value for
            the source node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateDoubleDataTargetComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
      <param name="dp">
            a data provider that must return a double value for
            the target node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateIntDataComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a comparator that compares objects of arbitrary type.</summary>
      <param name="dp">
            a data provider that must return an int value for
            each object that is being compared by this comparator.
            </param>
      <returns>a comparator that compares arbitrary objects.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateIntDataSourceComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
      <param name="dp">
            a data provider that must return an int value for
            the source node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateIntDataTargetComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
      <param name="dp">
            a data provider that must return an int value for
            the target node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Cursors">
      <summary>
            This class contains only static methods, that can be used in conjunction with
            objects of type
            <see cref="T:yWorks.yFiles.Algorithms.ICursor"></see>
            and
            <see cref="T:yWorks.yFiles.Util.IIterator"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateCursor``1(System.Collections.Generic.ICollection{``0})">
      <typeparam name="T">
        <p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[Missing &lt;typeparam name="T"/&gt; documentation for "M:yWorks.yFiles.Algorithms.Util.Cursors.CreateCursor``1(System.Collections.Generic.ICollection{``0})"]</p>
      </typeparam>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateCursor(yWorks.yFiles.Util.ICollection)">
      <summary>Creates a YCursor view of the given collection.</summary>
      <param name="c">
            
            The collection.
            </param>
      <returns>
            
            The cursor view of the given collection.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateIterator(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a first-to-last <c>Iterator</c> view of the given cursor.</summary>
      <param name="cursor">The cursor.</param>
      <returns>The iterator view of the given cursor.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateReverseIterator(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a last-to-first <c>Iterator</c> view of the given cursor.</summary>
      <param name="cursor">The cursor.</param>
      <returns>The iterator view of the given cursor.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.ToArray(yWorks.yFiles.Algorithms.ICursor,System.Object[])">
      <summary>Creates or fills an array with the values provided by the cursor</summary>
      <param name="cursor">the cursor</param>
      <param name="dest">
            the array to fill with the values or <see langword="null"></see> if the
            method should create the array itself
            </param>
      <returns>dest or a newly created array filled with the values from cursor</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter">
      <summary>An abstract adapter class for accepting data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.Defined(System.Object)">
      <summary>Returns <see langword="false"></see> for all data holders.</summary>
      <returns>
        <see langword="false">
        </see>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.Set(System.Object,System.Object)">
      <summary>
            Subclasses may override this
            method to set object values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.SetBool(System.Object,System.Boolean)">
      <summary>
            Subclasses may override this
            method to set boolean values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.SetDouble(System.Object,System.Double)">
      <summary>
            Subclasses may override this
            method to set double values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.SetInt(System.Object,System.Int32)">
      <summary>
            Subclasses may override this
            method to set integer values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataProviderAdapter">
      <summary>An abstract adapter class for providing data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.DataProviderAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.Defined(System.Object)">
      <summary>Returns <see langword="false"></see> for all data holders.</summary>
      <returns>
        <see langword="false">
        </see>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.Get(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to object values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.GetBool(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to boolean values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.GetInt(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to integer values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataProviders">
      <summary>This class provides convenience and transformation services for DataProviders.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.DataProviders" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateConstantDataProvider(System.Object)">
      <summary>
            Returns a DataProvider that returns the given value for each
            key.
            </summary>
      <param name="data">constant Object data returned by the created data provider.</param>
      <returns>a data provider view of a single value.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Boolean[])">
      <summary>Returns a DataProvider view  of a boolean array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Double[])">
      <summary>Returns a DataProvider view  of a double array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a DataProvider view  of a double, int, boolean and Object
            array defined for edges.
            </summary>
      <param name="doubleData">double data for each edge of a static graph</param>
      <param name="intData">int data for each edge of a static graph</param>
      <param name="boolData">boolean data for each edge of a static graph</param>
      <param name="objectData">Object data for each edge of a static graph</param>
      <returns>a data provider view of the given arrays</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Int32[])">
      <summary>Returns a DataProvider view  of an int array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Object[])">
      <summary>Returns a DataProvider view  of an Object array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNegatedDataProvider(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a DataProvider that returns the negated boolean values
            provided by another data provider.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Boolean[])">
      <summary>Returns a DataProvider view  of a boolean array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Double[])">
      <summary>Returns a DataProvider view  of a double array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a DataProvider view  of a double, int, boolean and Object
            array defined for nodes.
            </summary>
      <param name="doubleData">double data for each node of a static graph</param>
      <param name="intData">int data for each node of a static graph</param>
      <param name="boolData">boolean data for each node of a static graph</param>
      <param name="objectData">Object data for each node of a static graph</param>
      <returns>a data provider view of the given arrays</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Int32[])">
      <summary>Returns a DataProvider view  of an int array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Object[])">
      <summary>Returns a DataProvider view  of an Object array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateSourceDataProvider(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a DataProvider for edges that return the data provider values
            bound to their source nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateTargetDataProvider(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a DataProvider for edges that return the data provider values
            bound to their target nodes.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ">
      <summary>
            This class implements a priority queue for objects whose priority
            values are of type double.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.#ctor(System.Int32,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Creates an empty ObjectPQ using the given
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor"></see>
            to store and retrieve Object support information.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Add(System.Object,System.Double)">
      <summary>Adds the given node with with given priority to this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.ChangePriority(System.Object,System.Int32)">
      <summary>Changes the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Contains(System.Object)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.DecreasePriority(System.Object,System.Int32)">
      <summary>Decreases the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Dispose">
      <summary>Does nothing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.GetPriority(System.Object)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.IncreasePriority(System.Object,System.Int32)">
      <summary>Increases the priority value of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Remove(System.Object)">
      <summary>Removes the given node from this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter">
      <summary>This class is an empty abstract implementation of the EdgeMap interface.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.Get(System.Object)">
      <summary>Returns the value bound to the given edge.</summary>
      <returns>
        <see langword="null">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given edge.</summary>
      <returns>
        <see langword="false">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given edge.</summary>
      <returns>
        <c>0.0d</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given edge.</summary>
      <returns>
        <c>0</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.Set(System.Object,System.Object)">
      <summary>Associates the given value to with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to with the given edge.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier">
      <summary>A utility class that can be used to copy a graph's structure and possibly associated data to another instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.#ctor">
      <summary>
            Creates a new instance that uses a
            <see cref="T:yWorks.yFiles.Algorithms.GraphCopyFactory"></see>
            as the default factory.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that uses the specified factory to perform the actual copy operations.</summary>
      <param name="copyFactory">the factory to use, must be non-<see langword="null"></see>.</param>
      <exception cref="T:System.ArgumentNullException">if <c>copyFactory</c> is <see langword="null"></see></exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph)">
      <summary>Copies the contents of the source graph to a newly created target graph and returns the new graph.</summary>
      <param name="sourceGraph">the graph to copy the contents from</param>
      <returns>the newly created graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Copies the contents of the source graph to the target graph and returns the newly created nodes in the target
            graph.
            </summary>
      <param name="sourceGraph">the graph to copy the contents from</param>
      <param name="targetGraph">the target graph to copy the contents to, it will not be cleared prior to the copying</param>
      <returns>the list of Nodes that have been copied to the target graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Copies the subgraph contained in graph induced by the source nodes to a newly created graph.</summary>
      <param name="sourceGraph">the graph to copy</param>
      <param name="sourceNodes">the nodes in the sourceGraph to copy to the new graph</param>
      <returns>the newly created graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.Graph)">
      <summary>Copies the subgraph contained in sourceGraph induced by the source nodes to the targetGraph.</summary>
      <param name="sourceGraph">the graph to copy</param>
      <param name="sourceNodes">the nodes in the sourceGraph to copy to the new graph</param>
      <param name="targetGraph">the graph to copy the sourceGraph's contents to</param>
      <returns>the list of the new nodes in targetGraph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CopyEdge(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.CopyFactory">
      <summary>The currently used copy factory.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CopyNode(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CreateEdgeMap">
      <summary>
            Callback that creates the Map that will hold the mapping from the edges in the old source graph to the newly
            created edges in the target graph.
            </summary>
      <returns>A map that can be used to store the mapping.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CreateGraph(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that uses the given factory to create a new graph.</summary>
      <param name="factory">the factory to use for the creation</param>
      <param name="sourceGraph">the graph that will be</param>
      <returns>the newly created graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CreateNodeMap">
      <summary>
            Callback that creates the Map that will hold the mapping from the nodes in the old source graph to the newly
            created nodes in the target graph.
            </summary>
      <returns>A map that can be used to store the mapping.</returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderContentCopying">
      <summary>Determines whether automatic copying of edge map contents should be performed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopying">
      <summary>Determines whether automatic copying of edge map contents is enabled.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GetSourceEdges(yWorks.yFiles.Algorithms.Graph)">
      <summary>Determines the set of edge candidates from the source graph that should be copied.</summary>
      <param name="sourceGraph">the graph to determine the edges to copy</param>
      <returns>the edges to copy</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GetSourceNodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Determines the set of node candidates from the source graph that should be copied if
            no other nodes are specified by the user.
            </summary>
      <param name="sourceGraph">the graph to determine the nodes to copy</param>
      <returns>the nodes to copy</returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopying">
      <summary>Determines whether automatic copying of node map contents is enabled.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.PostCopyGraphData(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.PreCopyGraphData(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory">
      <summary>Abstract helper class that provides helper methods to copy DataProvider contents.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Creates a new delegating instance that copies the data for the given data provider key.</summary>
      <param name="delegatingFactory">the factory to delegate to.</param>
      <param name="dpKey">the data provider key</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.dpKey">
      <summary>The DataProvider key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.GetMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Helper method that retrieves the map for the given graph instance.</summary>
      <param name="graph">Graph instance for which the map is retrieved</param>
      <returns>the map for the given graph instance</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calls
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)"></see>
            and registers that map on the target graph if there is no
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap"></see>
            registered on the target graph yet.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory">
      <summary>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory"></see>
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly a created
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdgeMap"></see>
            edge map}.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Creates a new instance using the delegate for the given data provider key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Object)"></member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory">
      <summary>
            A helper wrapping implementation of the
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory"></see>
            interface that copies the contents
            of the edge maps from the source to the target graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that copies the node map contents.</summary>
      <param name="delegatingFactory">the factory to delegate the copying of the entities to.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.Copy(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory">
      <summary>An abstract base implementation of a delegating CopyFactory that copies data for items being copied.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that delegates the actual copying process of the elements to the provided factory.</summary>
      <param name="delegatingFactory">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Delegates the copying of the data to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)"></see></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Delegates the copying of the data to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)"></see></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CreateGraph">
      <summary>Creates a new graph instance that will be the target graph of the copy operation.</summary>
      <returns>the graph to use as the target graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="nodeMap">a Map that maps old node instances to their new copies</param>
      <param name="edgeMap">a Map that maps old edge instances to their new copies</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>
            Calls the delegate and then
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calls
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)"></see>
            and then the delegate.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory">
      <summary>
            The copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier"></see>
            to delegate the actual work to.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="newSource">the source node in the target graph to use for the newly created edge</param>
      <param name="newTarget">the target node in the target graph to use for the newly created edge</param>
      <param name="originalEdge">the original edge from the source graph</param>
      <returns>the newly created edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="originalNode">the original node from the source graph</param>
      <returns>the newly created node</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CreateGraph">
      <summary>Creates a new graph instance that will be the target graph of the copy operation.</summary>
      <returns>the graph to use as the target graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Callback that will be called after the copy operation has completed.</summary>
      <param name="sourceGraph">the graph that was used to copy the entities from.</param>
      <param name="targetGraph">the graph that was used to copy the entities to.</param>
      <param name="nodeMap">
            a map that contains a mapping between the nodes in the source graph
            to their corresponding nodes in the new graph.
            </param>
      <param name="edgeMap">
            a map that contains a mapping between the edges in the source graph
            to their corresponding edges in the new graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that will be called before the copy operation takes place.</summary>
      <param name="sourceGraph">the graph that will be used to copy the entities from.</param>
      <param name="targetGraph">the graph that will be used to copy the entities to.</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory">
      <summary>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory"></see>
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly created
            <see cref="T:yWorks.yFiles.Util.HashMap"></see>
            based
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap"></see>
            s.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory">
      <summary>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory"></see>
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly created
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNodeMap">node map</see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Creates a new instance using the delegate for the given data provider key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory">
      <summary>
            A helper wrapping implementation of the
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory"></see>
            interface that copies the contents
            of the node maps from the source to the target graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that copies the node map contents.</summary>
      <param name="delegatingFactory">the factory to delegate the copying of the entities to.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.Copy(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphHider">
      <summary>Provides functionality to hide and unhide nodes and edges of a graph temporarily for algorithmic operations.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Instantiates a new GraphHider for the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphHider.FireGraphEvents">
      <summary>Specifies whether or not this hider should fire graph events.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphHider.Graph">
      <summary>
            The <c>Graph</c> for which this <c>GraphHider</c> was
            created.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenEdges">
      <summary>holds the list of the hidden edges in stack order</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HiddenEdges">
      <summary>The edges that are currently hidden</summary>
      <returns>an EdgeList containing the currently hidden edges</returns>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenNodes">
      <summary>holds the list of the hidden nodes in stack order</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HiddenNodes">
      <summary>The nodes that are currently hidden</summary>
      <returns>a NodeList containing the currently hidden nodes</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Hides the given edge from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Hides the given list of edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Hides the given elements from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Hides the given edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Hides the given nodes from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.Node)">
      <summary>Hides the given node and all it's adjacent edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.NodeList)">
      <summary>Hides the given list of nodes from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideAll">
      <summary>Hides all nodes and edges from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideEdges">
      <summary>Hides all edges from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideMultipleEdges">
      <summary>Hides multiple edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideSelfLoops">
      <summary>Hides all self-loop edges from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideSubgraph(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Hides the subgraph induced by the given edges from the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.SimplifyGraph">
      <summary>Hides all self-loops and multiple edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Unhide(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This method will be called whenever
            the hider is requested to unhide the given edge
            from the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Unhide(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method will be called whenever
            the hider is requested to unhide the given node
            from the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideAll">
      <summary>Unhides all formerly hidden elements in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Unhides the given edge.</summary>
      <param name="e">the edge that will be unhidden</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideEdges">
      <summary>Unhides all formerly hidden edges in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideEdges(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Unhides the given edges.</summary>
      <param name="edges">the edges that will be unhidden</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideNode(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>Unhides the given node and if requested its adjacent edges.</summary>
      <param name="v">the node that will be unhidden</param>
      <param name="unhideAdjacentEdges">
            whether of not to unhide previously hidden edges connected at <c>v</c> whose other end point
            is not hidden, i.e. it is part of the graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideNodes">
      <summary>Unhides all formerly hidden nodes in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideNodes(yWorks.yFiles.Algorithms.NodeList,System.Boolean)">
      <summary>Unhides the given nodes and if requested its adjacent edges.</summary>
      <param name="nodes">the nodes that will be unhidden</param>
      <param name="unhideAdjacentEdges">
            whether of not to unhide previously hidden edges connected at the given nodes whose other end point
            is not hidden, i.e. it is part of the graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideSubgraph(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Unhides the subgraph induced by the given edges in the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphPartitionManager">
      <summary>Provides functionality to hide and unhide partitions of nodes and their adjacent edges of a graph temporarily for algorithmic operations.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Instantiates a new GraphPartitionManager for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.DisplayPartition(System.Object)">
      <summary>
            Assures that only nodes are visible in the graph that are associated with
            the given partitionId.
            </summary>
      <param name="partitionId">the partitionId for the nodes that will be made visible</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.FireGraphEventsEnabled">
      <summary>Specifies whether or not this partition manager should fire graph events.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Graph">
      <summary>
            The <c>Graph</c> for which this partition manager was
            created.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Hides the given edge from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Hides the given list of edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Hides the given elements from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Hides the given edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Hides the given nodes from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.Node)">
      <summary>Hides the given node and all it's adjacent edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.NodeList)">
      <summary>Hides the given list of nodes from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideAll">
      <summary>Hides all nodes and edges from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideEdges">
      <summary>Hides all edges from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideMultipleEdges">
      <summary>Hides multiple edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HidePartition(System.Object)">
      <summary>Hides nodes and adjacent edges that have the given partionId associated.</summary>
      <param name="partitionId">the id</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideSelfLoops">
      <summary>Hides all self-loop edges from this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.InitPartitions(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Initializes internal data structures using the new DataProvider.</summary>
      <param name="partitionId">
            the data provider that holds the partitionIds for all
            elements.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.SimplifyGraph">
      <summary>Hides all self-loops and multiple edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Unhide(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This method will be called whenever the partition manager is requested to
            unhide the given edge from the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Unhide(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method will be called whenever the partition manager is requested to
            unhide the given node from the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhideAll">
      <summary>Unhides all formerly hidden elements in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhideEdges">
      <summary>Unhides all formerly hidden edges in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhideNodes">
      <summary>Unhides all formerly hidden nodes in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhidePartition(System.Object)">
      <summary>Unhides nodes that have the given partionId associated.</summary>
      <param name="partitionId">the id</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ">
      <summary>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by associated double values.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Adds a node with the given priority to the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Decreases the priority of a node in the queue to a given value.</summary>
      <param name="n">a node in the priority queue.</param>
      <param name="priority">the new priority of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.RemoveMin">
      <summary>Removes the node with the minimal priority from the queue.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IIntNodePQ">
      <summary>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by associated int values.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Adds a node with the given priority to the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the priority of a node in the queue to a given value.</summary>
      <param name="n">a node in the priority queue.</param>
      <param name="priority">the new priority value of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.RemoveMin">
      <summary>Removes the node with the minimal priority from the queue.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.INodePQ">
      <summary>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by a comparable values.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Adds the given node with the given priority to the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Decreased the priority value of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.INodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.INodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue.</summary>
      <returns>the removed node with smallest priority</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IntObjectPQ">
      <summary>
            This class implements a priority queue for objects whose priority
            values are of type int.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.#ctor(System.Int32,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Creates an empty ObjectPQ using the given
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor"></see>
            to store and retrieve Object support information.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Add(System.Object,System.Int32)">
      <summary>Adds the given node with with given priority to this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.ChangePriority(System.Object,System.Int32)">
      <summary>Changes the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Contains(System.Object)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.DecreasePriority(System.Object,System.Int32)">
      <summary>Decreases the priority value of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Dispose">
      <summary>Does nothing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.GetPriority(System.Object)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.IncreasePriority(System.Object,System.Int32)">
      <summary>Increases the priority value of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IntObjectPQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Remove(System.Object)">
      <summary>Removes the given node from this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.ListIntNodePQ">
      <summary>
            A specialized priority queue that contains nodes which are
            prioritized by associated int values.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Constructs an initially empty PQ.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32)">
      <summary>Constructs a PQ that holds all nodes of the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Adds a node to this queue with the given priority</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Clear">
      <summary>Removes all entires from the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Whether or not the given node is contained within this queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the priority of a node in the queue to a certain value.</summary>
      <param name="v">a node in the priotity queue.</param>
      <param name="value">the new priority value of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.DecrementPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Decrements the associated priority value for the given node by 1
            and updates it's position within the queue accordingly.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Increases the priority of a node in the queue to a certain value.</summary>
      <param name="v">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.IncrementPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Increments the associated priority value for the given node by 1
            and updates it's position within the queue accordingly.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Min">
      <summary>The node with the minimal value in the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.PopMaxNode">
      <summary>
            Returns a node with highest associated int key within this
            queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.PopMinNode">
      <summary>
            Returns a node with smallest associated int key within this
            queue.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a node from the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.RemoveMin">
      <summary>Same as popMinNode.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Size">
      <summary>Returns the number of nodes still in the queue.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.LoggingUtil">
      <summary>
            Provides some convenience methods for code debugging
            and exception handling.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.LoggingUtil" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.LoggingUtil.DebugLevel">
      <summary>The debug level threshold.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Fatal(System.Object)">
      <summary>Called on a fatal error.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Fatal(System.Object,System.Object)">
      <summary>Outputs the class of the given object and the given message.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)">
      <summary>
            Prints the given string to <c>System.out</c> if
            the given debug level if bigger than
            <c>DEBUG_LEVEL</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Object)">
      <summary>Prints the given object to <c>System.err</c> unconditionally.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Object,System.Int32,System.Object)">
      <summary>
            Print the given message to <c>System.err</c> if the fully qualified
            class name of the given source object is encoded
            in the system property <c>y.debug</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Object,System.Object)">
      <summary>
            Print the given message to <c>System.err</c> if the fully qualified
            class name of the given source object is encoded
            in the system property <c>y.debug</c> and
            if the given debug level if bigger than
            <c>DEBUG_LEVEL</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.ShortLog(System.Int32,System.String)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)"></see>
            , but uses no line-feed.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.ShortLog(System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)"></see>
            , but omits newline.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.ShortLog(System.Object,System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)"></see>
            , but does not append a newline to the
            output.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Trace">
      <summary>Outputs a stack trace on System.err</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Trace(System.Exception)">
      <summary>Outputs a stack trace on System.err</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Watch(System.String)">
      <summary>
            Returns true if the given object type is under observation
            due to the <c>-Dy.debug</c> mechanism.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.WatchSource(System.Object)">
      <summary>
            Returns true if the given object type is under observation
            due to the <c>-Dy.debug</c> mechanism.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps">
      <summary>This class provides convenience and transformation services for Node- and EdgeMaps.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateDataMap(yWorks.yFiles.Util.IMap)">
      <summary>Create a DataMap view of the given map.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateEdgeMap(yWorks.yFiles.Util.IMap)">
      <summary>Create an EdgeMap view of the given map.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedDataMap">
      <summary>Creates a DataMap that is based on hashing.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedEdgeMap">
      <summary>Creates an EdgeMap that is based on hashing.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedNodeMap">
      <summary>Creates a NodeMap that is based on hashing.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Boolean[])">
      <summary>Returns a EdgeMap view  of a boolean array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Double[])">
      <summary>Returns a EdgeMap view  of a double array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a EdgeMap view  of a double, int, boolean and Object
            array defined for edges.
            </summary>
      <param name="doubleData">double data for each edge of a static graph</param>
      <param name="intData">int data for each edge of a static graph</param>
      <param name="boolData">boolean data for each edge of a static graph</param>
      <param name="objectData">Object data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given arrays</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Int32[])">
      <summary>Returns a EdgeMap view  of an int array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Object[])">
      <summary>Returns a EdgeMap view  of an Object array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Boolean[])">
      <summary>Returns a NodeMap view  of a boolean array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Double[])">
      <summary>Returns a NodeMap view  of a double array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a NodeMap view  of a double, int, boolean and Object
            array defined for nodes.
            </summary>
      <param name="doubleData">double data for each node of a static graph</param>
      <param name="intData">int data for each node of a static graph</param>
      <param name="boolData">boolean data for each node of a static graph</param>
      <param name="objectData">Object data for each node of a static graph</param>
      <returns>a NodeMap view of the given arrays</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Int32[])">
      <summary>Returns a NodeMap view  of an int array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Object[])">
      <summary>Returns a NodeMap view  of an Object array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateNodeMap(yWorks.yFiles.Util.IMap)">
      <summary>Create a NodeMap view of the given map.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap">
      <summary>Implementation of a resettable high performance map for values of simple type <c>boolean</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.ResetAll(System.Boolean)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap">
      <summary>Implementation of a resettable high performance map for values of simple type <c>double</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.ResetAll(System.Double)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap">
      <summary>Implementation of a resettable high performance map for values of simple type <c>int</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.ResetAll(System.Int32)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap">
      <summary>Implementation of a resettable high performance map for values of type <c>Object</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Object)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Object)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.ResetAll(System.Object)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.NodeMapAdapter">
      <summary>This class is an abstract empty implementation of the NodeMap interface.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.NodeMapAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
      <param name="key">
      </param>
      <returns>
        <see langword="null">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
      <param name="key">
      </param>
      <returns>
        <see langword="false">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
      <returns>
        <c>0.0d</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
      <returns>
        <c>0</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.Set(System.Object,System.Object)">
      <summary>Associates the given value to with the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to with the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to with the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to with the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ">
      <summary>Implements a priority queue for nodes based on AVL Trees.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_graph">the graph which contains the nodes</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a new Priority-Queue initialized with all nodes of the graph.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="_initValues">the initial priority-values of the nodes.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.#ctor(yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_valueMap">here the priority values are stored</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Inserts a node into the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Clear">
      <summary>Removes all entities from the queue.<br></br></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.<br></br></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the value of a node in the queue to a certain value.<br></br></summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Min">
      <summary>The node with the minimal value in the queue.<br></br></summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a node from the queue.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.RemoveMin">
      <summary>Removes the node with the minimal value from the queue.<br></br></summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Tuple">
      <summary>
            This class represents an ordered 2-Tuple that is consistent with
            <c>equals()</c> and <c>hashCode()</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.#ctor(System.Object,System.Object)">
      <summary>Constructs a 2-Tuple using the two given Objects</summary>
      <param name="o1">The first element (may be <see langword="null"></see>)</param>
      <param name="o2">The second element (may be <see langword="null"></see>)</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object)">
      <summary>Factory method to create a 2-Tuple</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object,System.Object)">
      <summary>Factory method to create a 3-Tuple</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object,System.Object,System.Object)">
      <summary>Factory method to create a 4-Tuple</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object,System.Object,System.Object,System.Object)">
      <summary>Factory method to create a 5-Tuple</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Equals(System.Object)">
      <summary>Determines if the given Tuple equals another Tuple.</summary>
      <param name="o">the element to compare this tuple with</param>
      <returns>true iff o equals this</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.GetHashCode">
      <summary>Generates a hashCode using the two tuple elements.</summary>
      <returns>a hashCode built using the hashCodes of the two elements.</returns>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.Tuple.o1">
      <summary>The first element of the Tuple</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.Tuple.o2">
      <summary>The second element of the Tuple</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider">
      <summary>This class can be used to wrap a given DataProvider with another one.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="wrapper">the wrapping data provider</param>
      <param name="graph">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="wrapper">The DataProvider instance which will be queried first</param>
      <param name="provider">the data provider which will be wrapped by the first one</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.DataMapView">
      <summary>A DataMap that can be used to read and write values.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Dispose">
      <summary>Disposes previously allocated data structures.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Get(System.Object)">
      <summary>Returns an object value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.GetBool(System.Object)">
      <summary>Returns a boolean value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.GetDouble(System.Object)">
      <summary>Returns a double value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.GetInt(System.Object)">
      <summary>Returns an integer value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Unwrap">
      <summary>Undoes a previous wrap() operation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Wrap(yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>
            Performs the wrapping, the given DataProvider will be unregistered
            from the graph and replaced with this instance.
            </summary>
      <param name="g">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering</param>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrappedProvider">
      <summary>The underlying wrapped DataProvider.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrappingProvider">
      <summary>The wrapping DataProvider instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrapUsingEdgeMap(yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="graph">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering and wrapping</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrapUsingNodeMap(yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="graph">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering and wrapping</param>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.YRandom">
      <summary>Generates pseudo-random numbers and the such.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.#ctor(System.Int64)">
      <summary>
            Creates a new instance of this class with a given
            initial random seed.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.GetBoolArray(System.Int32,System.Int32)">
      <summary>
            Returns an array of <c>n</c> randomly chosen boolean values
            of which <c>trueCount</c> of them are <see langword="true"></see>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.GetIntArray(System.Int32,System.Int32)">
      <summary>
            Returns an int array of length <c>bucketCount</c> for
            which the values of all fields are non-negative and sum up
            to <c>ballCount</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.GetUniqueArray(System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns an array of <c>n</c> unique random integers that
            lie within the range <c>min</c> (inclusive) and
            <c>max</c> (exclusive).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.NextDouble(System.Double,System.Double)">
      <summary>
            Returns a double with a random value between <c>minValue</c>
            (inclusive) and <c>maxValue</c> (exclusive).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.NextInt(System.Int32)">
      <summary>
            Returns a pseudo-random, uniformly distributed <tt>int</tt> value
            between 0 (inclusive) and the specified value (exclusive), drawn from
            this random number generator's sequence.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.NextInt(System.Int32,System.Int32)">
      <summary>
            Returns an int with a random value between <c>minValue</c>
            (inclusive) and <c>maxValue</c> (exclusive).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.Permutate(System.Object[])">
      <summary>Permutates the positions of the elements within the given array.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.AbstractLayoutStage">
      <summary>
            Partial LayoutStage implementation that handles
            the management of the core layouter part.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.#ctor">
      <summary>Default constructor.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes this AbstractLayoutStage with the given core Layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Queries the core layouter whether or not the given graph
            can be laid out.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.AbstractLayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the layout routine of the core layouter.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.BendConverter">
      <summary>
            This layout stage replaces bends with dummy nodes, calls the core layout
            algorithm and recreates the bends.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.#ctor">
      <summary>Creates a new instance of BendConverter</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.#ctor(System.Double)">
      <summary>
            Creates a new instance of BendConverter using the given size as
            the width and height for the dummy nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.AddedPathForEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.NodeList)">
      <summary>
            Callback method that will be invoked after new elements for the given edge
            have been added to the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.AdoptEdgeGroups">
      <summary>
            Specifies whether or not the edge group values of the original edge
            should be adopted by its replacement edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.AdoptPortConstraints">
      <summary>
            Specifies whether or not the port constraint values of the original edge
            should be adopted by its replacement edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.AdoptSelection">
      <summary>
            Specifies whether or not the selection state of the original edge
            should be adopted by its replacement edges.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.Prepare(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Prepares the graph before calling the core layouter</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.BendConverter.ScopeDpKey">
      <summary>
            DataProvider key used to specify the set of edges for which
            this stage will replace bends by nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.Unprepare(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Undoes the graph changes performed by
            <see cref="M:yWorks.yFiles.Layout.BendConverter.Prepare(yWorks.yFiles.Layout.LayoutGraph)"></see>
            after the
            core layouter has finished.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.BufferedLayouter">
      <summary>
            A hull layouter that invokes another layout algorithm on a copy of its input
            graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.#ctor">
      <summary>Instantiates a new BufferedLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Instantiates a new BufferedLayouter that wraps
            the given core layouter.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.CalcLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
      <returns>the calculated graph layout for the given graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
      <returns>the calculated graph layout for the given graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Whether or not this layouter can layout the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.DoLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.CanonicMultiStageLayouter">
      <summary>
            An abstract base class for layout algorithms that
            provides services to simplify and decompose the input graph
            before it is passed to the core layout routine itself.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.#ctor">
      <summary>Constructs a new AbstractLayouter</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Appends a stage to the layout pipeline.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CalcLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Returns a layout for the given graph interface and layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns a layout for the given layout graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Tests whether or not the given graph can be laid out
            by this layouter.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">
      <summary>
            The LayoutStage responsible for laying out the
            connected components of the graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouterEnabled">
      <summary>
            Specifies whether or not ComponentLayouter
            is enabled.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>
            Calculates a layout for the given graph interface
            and layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.EnableOnlyCore">
      <summary>Disables all layout stages and performs only the core layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.GroupNodeHider">
      <summary>
            The <c>LayoutStage</c> that is responsible for
            hiding away grouping information for the layout algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.HideGroupNodes">
      <summary>Specifies whether or not to hide away group nodes before the layout begins.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">
      <summary>The algorithm used for placing labels.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouterEnabled">
      <summary>
            Specifies whether or not LabelLayouter
            is enabled.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LayoutOrientation">
      <summary>The main layout orientation.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.OrientationLayouter">
      <summary>
            The LayoutStage that is responsible for
            changing the orientation of the computed layout.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.OrientationLayouterEnabled">
      <summary>
            Specifies whether or not the OrientationLayouter
            is enabled.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ParallelEdgeLayouter">
      <summary>
            The LayoutStage responsible for routing
            parallel edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ParallelEdgeLayouterEnabled">
      <summary>
            Specifies whether or not the ParallelEdgeLayouter
            is enabled.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Prepends a stage to the layout pipeline.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.RemoveStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>
            Removes a LayoutStage that has been previously added by the methods
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)"></see>
            or
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)"></see>
            .
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SelfLoopLayouter">
      <summary>
            The LayoutStage used for routing
            Self-loops.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SelfLoopLayouterEnabled">
      <summary>
            Specifies whether or not the SelfLoopLayouter
            is enabled.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SubgraphLayouter">
      <summary>
            The LayoutStage that is responsible for
            constraining the layout process to a subgraph
            of the target graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SubgraphLayouterEnabled">
      <summary>
            Specifies whether or not the SubgraphLayouter
            is enabled.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.ComponentArrangementStyles"></member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.None">
      <summary>
            Style specification constant describing no special component arrangement at all.
            Components will be centered at the same position they resided at before the layout
            started. If combined with the style modifier
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierNoOverlap"></see>
            components might get moved so that they don't overlap after the layout.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.Rows">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components in multiple rows so that the overall aspect ratio of all
            components gets as close to the ratio of the preferred layout size as possible.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleRow">
      <summary>
            Style specification constant describing a component arrangement strategy that
            places components next to each other in a single rows. If combined with the
            style modifier
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierAsIs"></see>
            components will be placed in the same order as they were placed before the layout.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleColumn">
      <summary>
            Style specification constant describing a component arrangement strategy that
            places components above each other in a single column. If combined with the
            style modifier
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierAsIs"></see>
            components will be placed in the same order as they were placed before the layout.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a rectangular cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactRectangle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a rectangular cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap. In contrast to
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle"></see>
            components might even be placed in empty spaces inside other components.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactCircle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap. In contrast to
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle"></see>
            components might even be placed in empty spaces inside other components.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.Mask">
      <summary>Use this constant for masking actual styles constants from style modifiers.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierAsIs">
      <summary>
            Modifier constant that can be added to normal style constants to indicate that
            the arrangement strategy should take the initial positions of the components
            into account.
            <br></br>
            Combining this modifier is supported with the following styles:
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleRow"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleColumn"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactRectangle"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle"></see>
            , and
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactCircle"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierNoOverlap">
      <summary>
            Modifier constant that can be added to normal style constants to indicate that
            the arrangement strategy should produce a non-overlapping component layout.
            <br></br>
            Combining this modifier is supported with
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.None"></see>
            .
            <p>
            Note that non-overlapping component layout (in the sense that no elements from
            adjacent components overlap) is inherently supported by the following styles:
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactRectangle"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle"></see>
            ,
            and
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactCircle"></see>
            .
            </p></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.ComponentLayouter">
      <summary>This layout stage arranges the connected components of a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.#ctor">
      <summary>Instantiates a ComponentLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a ComponentLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.ArrangeComponents(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.EdgeList[],yWorks.yFiles.Algorithms.Geometry.YRectangle[],yWorks.yFiles.Util.Geom.Rectangle2D[])">
      <summary>Produces a non-overlapping component graph layout.</summary>
      <param name="graph">the layout graph.</param>
      <param name="nodes">array of type NodeList. The i-th NodeList contains all nodes of the i-th graph component.</param>
      <param name="edges">array of type EdgeList. The i-th NodeList contains all edges of the i-th graph component.</param>
      <param name="bbox">array of type YRectangle. The i-th YRectangle contains the current bounding box of the i-th graph component.</param>
      <param name="boxes">
            array of type Rectangle2D. The i-th Rectangle2D contains the extended bounding box of the i-th graph component.
            The method arrange these boxes in such a way that they do not overlap. Then the i-th graph component must be placed
            inside the i-th box.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.ArrangeFields(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.EdgeList[],yWorks.yFiles.Algorithms.Geometry.YRectangle[],yWorks.yFiles.Util.Geom.Rectangle2D[],System.Boolean,System.Boolean,System.Boolean)"></member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.CalcBoundingBox(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates and returns the bounding box of a graph component.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Determines if the preconditions for the graph layout algorithm
            are fulfilled, by applying them to the connected components.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.ComponentArrangement">
      <summary>
            Specifies whether or not the separately laid out components of the input graph should be
            arranged by this class.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.ComponentSpacing">
      <summary>The current component spacing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.ConsiderLabels">
      <summary>
            Specifies whether or not to take node and edge labels into account when calculating the bounding
            box of the graph components.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculate the layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.FindGraphComponents(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Determines which nodes will belong to the same graph component.</summary>
      <param name="graph">the input graph</param>
      <param name="compNumber">
            return value that will hold the zero-based number
            of the component that it belongs to. The component number of
            Node <c>v</c> is <c>compNum.getInt(v)</c>.
            </param>
      <returns>the number of connected components of this graph.</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentLayouter.GivenComponentDpKey">
      <summary>DataProvider key that can be used to determine components by hand.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.GridSpacing">
      <summary>The current grid spacing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.GroupingActive">
      <summary>
            Specifies whether grouping information bound to the graph will be used
            to calculate the components.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentLayouter.LayoutNodeDpKey">
      <summary>DataProvider key that can be used to determine which nodes should be laid out.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.PreferredLayoutSize">
      <summary>The preferred layout size for this layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.SetOrigin(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Sets the origin for a subgraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.SetPreferredLayoutSize(System.Double,System.Double)">
      <summary>Sets the preferred layout size for this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.Style">
      <summary>The component arrangement style used by this <c>ComponentLayouter</c>.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.CompositeLayouter">
      <summary>
            A layouter that allows to express a layout stage
            as a chain of more basic layout stages.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.#ctor(yWorks.yFiles.Layout.ILayoutStage,yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of <c>CompositeLayouter</c> with the
            specified <c>LayoutStage</c> prepended to the specified
            <c>Layouter</c>.
            </summary>
      <param name="stage">
            a <c>LayoutStage</c> that is prepended to the specified
            core layouter.
            </param>
      <param name="coreLayouter">
            a <c>Layouter</c> that is used as core (i.e.
            innermost) layouter for this <c>CompositeLayouter</c>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Appends a stage to the layout pipeline.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns true if all layout stages and the core layout stage
            can layout the given graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CompositeLayouter.LayoutStages">
      <summary>The chain of layout stages that make up this composite layout stage.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Prepends a stage to this composite layout stage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.CompositeLayoutStage">
      <summary>
            A composite layout stage that allows to express a layout stage
            as a chain of more basic layout stages.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.#ctor">
      <summary>Creates a new instance of CompositeLayoutStage</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.#ctor(yWorks.yFiles.Layout.ILayoutStage,yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Creates a new instance of CompositeLayoutStage</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Appends a stage to the layout pipeline.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CompositeLayoutStage.LayoutStages">
      <summary>The chain of layout stages that make up this composite layout stage.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.PrependStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Prepends a stage to this composite layout stage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.CopiedLayoutGraph">
      <summary>
            This is a LayoutGraph implementation that serves as a copy of
            another LayoutGraph or as copy of a combined GraphInterface and
            and GraphLayout interface implementation.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.#ctor(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>
            Initializes this graph as a copy of the given graph interface
            and graph layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Initializes this graph as a copy of the given graph</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CommitLayoutToOriginalGraph">
      <summary>Writes the current layout information to the original graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateEdge(System.Object)">
      <summary>Creates an copied edge.</summary>
      <param name="origEdge">the original edge the copied edge is based on</param>
      <returns>the newly created edge (belongs to the copied graph)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateGraphCopyFactory">
      <summary>
            Creates a factory that delegates to the
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateNode(System.Object)"></see>
            and
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateEdge(System.Object)"></see>
            methods of this instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateNode(System.Object)">
      <summary>Creates a copy of the given original node.</summary>
      <param name="origNode">the node of the original graph the copy will be created for</param>
      <returns>the newly created node that represents a copy of the given node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetCopiedEdge(System.Object)">
      <summary>
            Returns the copied edge that corresponds to the given
            original edge.
            </summary>
      <param name="e">an edge in the original graph whose copy is in this graph</param>
      <returns>an edge in this graph that is the copy of the given original edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetCopiedNode(System.Object)">
      <summary>
            Returns the copied node that corresponds to the given
            original node.
            </summary>
      <param name="v">a node in the original graph whose copy is in this graph</param>
      <returns>a node in this graph that is the copy of the given original node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetFeature(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge which is described by a given label layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetFeature(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node which is described by a given label layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="e">an edge in the drawing.</param>
      <returns>the edge label layout information for the given edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="v">a node in the drawing.</param>
      <returns>the node label layout information for <c>node</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="e">an edge in the drawing.</param>
      <returns>the layout information for the given edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="v">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetOriginalEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the original edge that corresponds to the given
            edge.
            </summary>
      <param name="e">an edge in this graph that is a copy of the returned edge</param>
      <returns>an edge in the original graph whose copy is the given edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetOriginalNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the original node that corresponds to the given
            node.
            </summary>
      <param name="v">a node in this graph that is a copy of the returned node</param>
      <returns>a node in the original graph whose copy is the given node</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.CopiedLayoutGraph.LayoutForOriginalGraph">
      <summary>The GraphLayout that is valid for the original graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CopiedLayoutGraph.OriginalGraph">
      <summary>The original graph</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.CopiedLayoutGraph.OriginalLayout">
      <summary>The original layout</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.SyncStructure">
      <summary>Synchronizes the structure of the CopiedLayoutGraph with the actual structure of the underlying LayoutGraph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultEdgeLayout">
      <summary>This class is a default implementation of the EdgeLayout interface.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.#ctor">
      <summary>Creates a new DefaultEdgeLayout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.#ctor(yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Creates a new DefaultEdgeLayout which is the copy of another EdgeLayout.</summary>
      <param name="layout">another edge layout</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.AddPoint(System.Double,System.Double)">
      <summary>Adds a control point to the end of the control point sequence.</summary>
      <param name="x">the absolute x-coordinate of the control point.</param>
      <param name="y">the absolute y-coordinate of the control point.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.ClearPoints">
      <summary>Remove all control points from this edge layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.GetPoint(System.Int32)">
      <summary>
            Returns the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <returns>the absolute coordinates of the control point at the given index.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.PointCount">
      <summary>Returns the number of control points of the edge.</summary>
      <returns>the number of control points</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.SetPoint(System.Int32,System.Double,System.Double)">
      <summary>
            Sets the coordinates of the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <param name="x">absolute x-coordinate of the control point at the given index.</param>
      <param name="y">absolute y-coordinate of the control point at the given index.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultEdgeLayout.SourcePoint">
      <summary>
            The relative coordinates of the first end point of this layout
            that is associated with the source node of the edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultEdgeLayout.TargetPoint">
      <summary>
            The relative coordinates of the second end point of this layout
            that is associated with the target node of the edge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultGraphLayout">
      <summary>
            This class is a default implementation of the SimpleGraphLayout
            interface.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.DefaultGraphLayout" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetBoundingBox">
      <summary>
            Returns the bounding box of this graph layout
            This is the smallest rectangle containing the entire layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetEdgeLabelLayout(System.Object)">
      <summary>Returns the edge label layouts associated with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetEdgeLayout(System.Object)">
      <summary>Returns the layout information associated with the given edge object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetNodeLabelLayout(System.Object)">
      <summary>Returns the node label layouts associated with the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetNodeLayout(System.Object)">
      <summary>Returns the layout information associated with the given node object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetEdgeLabelLayout(System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout[])">
      <summary>Sets the edge label layouts associated with the given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetEdgeLayout(System.Object,yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Sets the layout information associated with the given edge object.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetNodeLabelLayout(System.Object,yWorks.yFiles.Layout.INodeLabelLayout[])">
      <summary>Sets the node label layouts associated with the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetNodeLayout(System.Object,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Sets the layout information associated with the given node object.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultLayoutGraph">
      <summary>This class is a default implementation of the abstract class LayoutGraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor">
      <summary>Creates a new Layout Graph</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor(yWorks.yFiles.Layout.DefaultLayoutGraph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a copy of the given subgraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Creates a copy of the given subgraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a copy of the given subgraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.CreateEdgeLayout">
      <summary>Override this to create your own EdgeLayouts.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.CreateGraphCopyFactory">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.CreateNodeLayout">
      <summary>Override this to create your own NodeLayouts.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.edgeLabelFeatureMap">
      <summary>Map used to associate the owner of an edge label with the edge label itself.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.edgeLabelMap">
      <summary>EdgeMap used to associate edge label layouts with the edges of this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetFeature(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge which is described by a given label layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetFeature(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node which is described by a given label layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <returns>the edge label layout information for the given edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns NodeLabelLayout objects that describe the layouts
            of the labels belonging to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <returns>the node label layout information for the given node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="e">a edge in the drawing.</param>
      <returns>the layout information for the given edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="v">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.nodeLabelFeatureMap">
      <summary>Map used to associate the owner of a node label with the node label itself.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.nodeLabelMap">
      <summary>NodeMap used to associate node label layouts with the nodes of this graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.IEdgeLabelLayout[])">
      <summary>
            Sets the EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <param name="layout">an array of edge label layout objects</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>
            Sets the NodeLabelLayout object which describes the layout
            of the label that belongs to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <param name="layout">a layout object for the node label</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLabelLayout[])">
      <summary>
            Sets the NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <param name="llayout">an array of node label layout objects</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLayout(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Sets the layout information for an edge in the drawing.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLayout(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Sets the layout information for a node in the drawing.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout">
      <summary>This class is the default implementation for the NodeLabelLayout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLabelLayout.#ctor(yWorks.yFiles.Layout.INodeLabelModel,System.Object,yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout"></see></summary>
      <param name="model">the NodeLabel model for this label layout</param>
      <param name="param">
            the NodeLabelModel parameter that describes the position
            of the label layout.
            </param>
      <param name="box">the bounds of this label layout</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.Box">
      <summary>The bounding box of the label</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.LabelModel">
      <summary>The node label model associated with this label layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.ModelParameter">
      <summary>The NodeLabelModel parameter that describes the position of the label layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.Node">
      <summary>The node associated with this layout.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultNodeLayout">
      <summary>This class is a default implementation of the NodeLayout interface.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor">
      <summary>Creates a new instance of DefaultNodeLayout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new instance of DefaultNodeLayout.</summary>
      <param name="x">the x-coordinate of the upper left corner of the node.</param>
      <param name="y">the y-coordinate of the upper left corner of the node.</param>
      <param name="width">the width of the node.</param>
      <param name="height">the height of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Creates a new instance of DefaultNodeLayout.</summary>
      <param name="location">the upper-left corner coordinate of the node layout.</param>
      <param name="size">the size of the node layout.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor(yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a new instance of DefaultNodeLayout as copy of another instance
            of NodeLayout.
            </summary>
      <param name="layout">another instance of NodeLayout.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.Height">
      <summary>The height of the node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.SetCenter(System.Double,System.Double)">
      <summary>Sets the center coordinates of the node.</summary>
      <param name="x">the x-coordinates of the center.</param>
      <param name="y">the y-coordinates of the center</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.SetLocation(System.Double,System.Double)">
      <summary>Sets the coordinates of the upper left corner of the node.</summary>
      <param name="x">the x-coordinates of the upper left corner.</param>
      <param name="y">the y-coordinates of the upper left corner.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.SetSize(System.Double,System.Double)">
      <summary>Sets the size of the node.</summary>
      <param name="width">the width of the node.</param>
      <param name="height">the height of the node.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.Width">
      <summary>The width of the node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.X">
      <summary>X-Coordinate of the upper left corner of the node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.Y">
      <summary>Y-Coordinate of the upper left corner of the node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels
            at some positions along an edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of DiscreteEdgeLabelModel.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.DiscreteEdgeLabelPosition)">
      <summary>Returns a new instance of DiscreteEdgeLabelModel.</summary>
      <param name="candidateMask">
            
            Position mask that defines the allowed positions for an edge label.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.Distance">
      <summary>The distance between the label's bounding box and the edge's path.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate"></see>
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="labelLayout">
            
            The label for which candidates should be generated.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate"></see>
            objects.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the coordinates of the upper-left corner of the label position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of a label position.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.DiscreteEdgeLabelPosition)">
      <summary>Returns the coordinates of the upper-left corner of the given label position.</summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceNode">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetNode">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="pos">
            
            A label position (given by a symbolic position specifier) that is valid in
            this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of a label position.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
            Checks if the given model parameter encodes an edge label position that is
            valid in this model.
            </summary>
      <returns>
            
            Whether the label position encoded by the given model parameter is among the
            allowed positions.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition"></member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Shead">
      <summary>
            Symbolic position specifier.
            Places the label near the source node.
            The label's position is to the left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of the edge's path.
            The label's position is to the left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Thead">
      <summary>
            Symbolic position specifier.
            Places the label near the target node.
            The label's position is to the left of or above the edge's path.
            Places the label near the target node on the "head" side of the edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Stail">
      <summary>
            Symbolic position specifier.
            Places the label near the source node.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of the edge's path.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Ttail">
      <summary>
            Symbolic position specifier.
            Places the label near the target node.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Scenter">
      <summary>
            Symbolic position specifier.
            Places the label near the source node directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of an edge directly on its path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tcenter">
      <summary>
            Symbolic position specifier.
            Places the label near the target node directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.TwoPos">
      <summary>
            Position mask that constrains allowed positions to the two near the edge's
            end points.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Centered">
      <summary>
            Position mask that constrains allowed positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.SixPos">
      <summary>
            Position mask that constrains allowed positions to a set of six positions on
            the "head" and "tail" sides of an edge.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Shead"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Thead"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Stail"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail"></see>
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Ttail"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.ThreeCenter">
      <summary>
            Position mask that constrains allowed positions to a set of three positions
            directly on the edge's path.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Scenter"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center"></see>
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tcenter"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel">
      <summary>
            A node label model that allows placement of labels at eight positions around
            a node and at nine positions inside the node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of DiscreteNodeLabelModel.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.DiscreteNodeLabelPosition)">
      <summary>Returns a new instance of DiscreteNodeLabelModel.</summary>
      <param name="candidateMask">
            
            Defines the allowed positions for the node label.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.DiscreteNodeLabelPosition,System.Double)">
      <summary>Returns a new instance of DiscreteNodeLabelModel.</summary>
      <param name="candidateMask">
            
            Defines the allowed positions for the node label.
            </param>
      <param name="inset">
            
            The distance between label and node.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed node label positions.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.Distance">
      <summary>The distance between the bounding boxes of label and node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given node label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the coordinates of the upper-left corner of the label position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label.
            </param>
      <param name="nodeLayout">
            
            The geometric description of the label's node.
            </param>
      <param name="param">
            
            A model parameter that encodes a label position that is valid in this model.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.DiscreteNodeLabelPosition)">
      <summary>Returns the coordinates of the upper-left corner of the given label position.</summary>
      <param name="labelSize">
            
            The size of the label.
            </param>
      <param name="nodeLayout">
            
            The geometric description of the label's node.
            </param>
      <param name="pos">
            
            A label position that is valid in this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of the given label position.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
            Checks if the given model parameter encodes a node label position that is valid
            in this model.
            </summary>
      <returns>
            
            Whether the label position encoded by the given model parameter is among the
            allowed positions.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteNodeLabelPosition"></member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North">
      <summary>Symbolic position specifier. Places the label north of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthWest">
      <summary>Symbolic position specifier. Places the label north-west of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthEast">
      <summary>Symbolic position specifier. Places the label north-east of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.East">
      <summary>Symbolic position specifier. Places the label east of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.West">
      <summary>Symbolic position specifier. Places the label west of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.South">
      <summary>Symbolic position specifier. Places the label south of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthWest">
      <summary>Symbolic position specifier. Places the label south-west of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthEast">
      <summary>Symbolic position specifier. Places the label south-east of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Center">
      <summary>Symbolic position specifier. Places the label in the center of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Bottom">
      <summary>Symbolic position specifier. Places the label at the bottom inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Top">
      <summary>Symbolic position specifier. Places the label at the top inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Left">
      <summary>Symbolic position specifier. Places the label at the left inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Right">
      <summary>Symbolic position specifier. Places the label at the right inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.TopLeft">
      <summary>Symbolic position specifier. Places the label at the top-left inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.TopRight">
      <summary>Symbolic position specifier. Places the label at the top-right inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.BottomLeft">
      <summary>Symbolic position specifier. Places the label at the bottom-left inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.BottomRight">
      <summary>Symbolic position specifier. Places the label at the bottom-right inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SandwichMask">
      <summary>
            Position mask that constrains the positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.South"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.InternalMask">
      <summary>Position mask that allows only the nine node-internal positions.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SidesMask">
      <summary>
            Position mask that constrains the positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.East"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.West"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North"></see>
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.South"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.CornerMask">
      <summary>
            Position mask that constrains the positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthEast"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthWest"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthEast"></see>
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthWest"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.EightPosMask">
      <summary>Position mask that allows only the eight node-external positions.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeLabelCandidate">
      <summary>A candidate position for edge labels</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout,System.Boolean)">
      <summary>Returns a new instance of EdgeLabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is
            allowed to overlap the layout of the edge.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeLabelLayoutImpl">
      <summary>
            This class is an default implementation of the EdgeLabelLayout
            interface.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeLabelLayoutImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.EdgeLabelModel">
      <summary>The edge label model associated with this label layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.LabelModel">
      <summary>The edge label model associated with this label layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.PreferredPlacement">
      <summary>The preferred placement of this label</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel">
      <summary>
            A node label model that sets
            the labels at the opposite side of the outgoing edges of a node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.DefaultParameter">
      <summary>The default position, this is offset (0,0)</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the positions of the lower upper corner of the label
            with given parameter.
            </summary>
      <param name="labelSize">the size of the label.</param>
      <param name="nodeLayout">the geometric description of the labeled node.</param>
      <param name="param">not used by this model</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter"></member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter.#ctor(yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter.#ctor(yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel,System.Double,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter.Point"></member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)"></member>
    <member name="T:yWorks.yFiles.Layout.EdgeReversalStage">
      <summary>
            A layout stage that can be used to (selectively) reverse edges in a
            graph while keeping the layout and label positions of the reversed edges
            as close to the pre-reversal layout and positions as possible.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeReversalStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeReversalStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.FindReversedTreeEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Marks edges in a tree-structured graph component that need to be reversed
            to make the specified node the root of the tree component.
            </summary>
      <param name="graph">the graph to which the specified node belongs.</param>
      <param name="root">the node to be considered the root of its tree component.</param>
      <param name="reversedEdges">
            a data acceptor that is used to mark edges for
            reversal.
            </param>
      <exception cref="T:System.ArgumentException">
            if the specifed node does not belong to
            the specified graph.
            </exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Reverse the specified edge in the specified graph.</summary>
      <param name="graph">the graph to which the specified edge belongs.</param>
      <param name="edge">the edge to be reversed.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdges(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Reverses <em>selected</em> edges in the specified graph.</summary>
      <param name="graph">the graph in which to reverse edges.</param>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdgesDpKey">
      <summary>This key can be used to <em>select</em> specific edges for reversal.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels
            at a fixed offset from the source intersection point of the node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.#ctor">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a model parameter that represents the given edge label
            context.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.DefaultParameter">
      <summary>The default parameter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns exactly one label candidate that corresponds to
            the actual label layout of the given label.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the positions of the upper left corner of the label
            with given parameter.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter">
      <summary>The model parameters for the <c>FreeEdgeLabelModel</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter"></see>
            with radius <c>50</c>
            and angle <c>0</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double)">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter"></see>
            with given radius and angle.
            </summary>
      <param name="radius">the distance of the label from the source node of the underlying edge</param>
      <param name="theta">
            the angle between the first segment of the underlying edge and the
            imaginary line to the center of the label. the angle is measured in radian.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.Point">
      <summary>
            A point whose x-coordinate corresponds to the radius associated with this
            class and whose y-coordinate corresponds to the angle associated with this class.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)">
      <summary>Sets angle and radius for this class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel">
      <summary>
            A node label model that allows placement of labels at a fixed offset relative
            to the node's upper-left corner.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of FreeNodeLabelModel.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed node label positions.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given node label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the coordinate of the upper-left corner of the label position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label.
            </param>
      <param name="nodeLayout">
            
            The geometric description of the label's node.
            </param>
      <param name="param">
            
            A model parameter that encodes a label position that is valid in this model.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.SetLocation(System.Double,System.Double)">
      <summary>Sets the node label's offset that is used with this model.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter">
      <summary>The model parameter that encodes a node label position within FreeNodeLabelModel.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.#ctor">
      <summary>Returns a new instance of ModelParameter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double)">
      <summary>Returns a new instance of ModelParameter with the given offset.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.Point">
      <summary>The offset of this ModelParameter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)">
      <summary>Sets the node label's offset.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.GraphLayoutLineWrapper">
      <summary>A layout stage that can be used to "line-wrap" or "column-wrap" a graph layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.GraphLayoutLineWrapper.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.GraphLayoutLineWrapper" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.GraphLayoutLineWrapper.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.ColumnMode">
      <summary>Determines whether this algorithm should not wrap lines or rows, but columns.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.GraphLayoutLineWrapper.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.EdgeSpacing">
      <summary>The space between edges that should be used for the additional routing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidth">
      <summary>
            The desired width of the lines to use if
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks"></see>
            is set to
            <see langword="true"></see>.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks">
      <summary>
            Specifies whether the algorithm should use the
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidth">fixed width</see>
            to determine line breaks.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.Mirror">
      <summary>
            Specifies whether lines should be going from left to right and right to left
            in an alternating fashion.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.Spacing">
      <summary>The space between adjacent lines of the wrapped graph layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.TargetRatio">
      <summary>The desired target aspect ratio the algorithm should try to generate.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.IEdgeLabelLayout">
      <summary>
            This interface defines the properties of one edge label
            from the perspective of a labeling algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLabelLayout.LabelModel">
      <summary>The edge label model associated with this label layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLabelLayout.PreferredPlacement">
      <summary>The preferred placement of this label.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.IEdgeLabelModel">
      <summary>
            This interface defines the properties of the model associated with an edge label
            layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLabelModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLabelModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate"></see>
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="labelLayout">
            
            The label for which candidates should be generated.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate"></see>
            objects.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the coordinates of the upper-left corner of the label position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of a label position.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.IEdgeLayout">
      <summary>This interface encapsulates the layout information for an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.AddPoint(System.Double,System.Double)">
      <summary>Adds a control point to the end of the control point sequence.</summary>
      <param name="x">the absolute x-coordinate of the control point.</param>
      <param name="y">the absolute y-coordinate of the control point.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.ClearPoints">
      <summary>Remove all control points from this edge layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.GetPoint(System.Int32)">
      <summary>
            Returns the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <returns>the absolute coordinates of the control point at the given index.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.PointCount">
      <summary>Returns the number of control points of the edge.</summary>
      <returns>the number of control points</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.SetPoint(System.Int32,System.Double,System.Double)">
      <summary>
            Sets the coordinates of the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <param name="x">absolute x-coordinate of the control point at the given index.</param>
      <param name="y">absolute y-coordinate of the control point at the given index.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLayout.SourcePoint">
      <summary>
            The relative coordinates of the first end point of this layout
            that is associated with the source node of the edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLayout.TargetPoint">
      <summary>
            The relative coordinates of the second end point of this layout
            that is associated with the target node of the edge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.IGraphLayout">
      <summary>This interface defines the layout information of a  graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetBoundingBox">
      <summary>Returns the bounding box of the graph layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetEdgeLabelLayout(System.Object)">
      <summary>
            Returns an array of layout information for all edge labels
            belonging to the given edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetEdgeLayout(System.Object)">
      <summary>Returns the layout information for a given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetNodeLabelLayout(System.Object)">
      <summary>
            Returns an array of layout information for all node labels
            belonging to the given node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetNodeLayout(System.Object)">
      <summary>Returns the layout information for a given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.IIntersectionCalculator">
      <summary>
            Interface implemented by classes that are responsible for calculating the
            intersection point between an Edge and the visual representation of its
            source or target node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IIntersectionCalculator.CalculateIntersectionPoint(yWorks.yFiles.Layout.INodeLayout,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Calculates an intersection point given the coordinates of a point lying on
            the last/first segment of an Edge and a normalized direction.
            </summary>
      <param name="nl">
            the currently calculated
            <see cref="T:yWorks.yFiles.Layout.INodeLayout"></see></param>
      <param name="xOffset">
            the relative (to the node's center)
            x-coordinate of a point on the last line segment
            </param>
      <param name="yOffset">the relative y-coordinate of a point on the last line segment</param>
      <param name="dx">
            the x component of the normalized direction vector indicating the
            direction of the segment pointing towards the node
            </param>
      <param name="dy">
            the y component of the normalized direction vector indicating the
            direction of the segment pointing towards the node
            </param>
      <returns>
            the new relative (to the node's center) intersection coordinates or
            <see langword="null"></see> if no such intersection could be found
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.ILabelLayout">
      <summary>
            This interface defines the properties of one label
            from the perspective of a labeling algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILabelLayout.Box">
      <summary>The bounding box of the label</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILabelLayout.ModelParameter">
      <summary>
            The label model parameter that describes
            the position of this label.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.ILayouter">
      <summary>
            This is a general interface for algorithms that
            perform a layout process on a given layout graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ILayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ILayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.ILayoutStage">
      <summary>
            Interface for a layouter that forms a stage of a larger layout
            process.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.INodeLabelLayout">
      <summary>
            This interface defines the properties of one edge label
            from the perspective of a labeling algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLabelLayout.LabelModel">
      <summary>The node label model associated with this label layout</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.INodeLabelModel">
      <summary>
            This interface defines the properties of the model
            associated with a node label layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLabelModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLabelModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed node label positions.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.NodeLabelCandidate"></see>
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="nl">
            
            The label layout for which candidates should be generated.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.NodeLabelCandidate"></see>
            objects.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the coordinates of the upper-left corner of the label position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of a label position.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.INodeLayout">
      <summary>
            This interface describes the layout information for a node in the drawing
            of a graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.Height">
      <summary>The height of the node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLayout.SetLocation(System.Double,System.Double)">
      <summary>Sets the coordinates of the upper left corner of the node.</summary>
      <param name="x">the x-coordinates of the upper left corner.</param>
      <param name="y">the y-coordinates of the upper left corner.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLayout.SetSize(System.Double,System.Double)">
      <summary>Sets the size of the node.</summary>
      <param name="width">the width of the node.</param>
      <param name="height">the height of the node.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.Width">
      <summary>The width of the node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.X">
      <summary>X-Coordinate of the upper left corner of the node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.Y">
      <summary>Y-Coordinate of the upper left corner of the node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.IntersectionCalculatorKeys"></member>
    <member name="F:yWorks.yFiles.Layout.IntersectionCalculatorKeys.SourceIntersectionCalculatorDpKey">
      <summary>
            Key to be used when registering a DataProvider to a graph instance that provides
            for each Edge object in a graph an <c>IntersectionCalculator</c> instance
            that is configured to calculate the intersection of the edge and the source
            node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.IntersectionCalculatorKeys.TargetIntersectionCalculatorDpKey">
      <summary>
            Key to be used when registering a DataProvider to a graph instance that provides
            for each Edge object in a graph an <c>IntersectionCalculator</c> instance
            that is configured to calculate the intersection of the edge and the target
            node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.IProfitModel">
      <summary>This is an interface for ranking LabelCandidates.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.IProfitModel.GetProfit(yWorks.yFiles.Layout.LabelCandidate)">
      <summary>Returns the profit for placing a label-candidate.</summary>
      <param name="candidate">a label candidate</param>
      <returns>a value between 0 and 1.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelCandidate">
      <summary>Base class for candidate positions for labels.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.ILabelLayout)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.ILabelLayout,System.Boolean)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is
            allowed to overlap its own feature.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.BoundingBox">
      <summary>The bounds of this label candidate.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.EdgeOverlapPenalty">
      <summary>The penalty value for a candidate position that overlaps the path of an edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Height">
      <summary>The height of the label candidate bounds.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Internal">
      <summary>Specifies whether this candidate is an internal node label, i.e.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Location">
      <summary>The upper left corner of the label candidate bounds.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.ModelParameter">
      <summary>
            The model parameter that was used by the underlying model to
            generate this label candidate.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.NodeOverlapPenalty">
      <summary>The penalty for a candidate position that overlaps the bounds of a node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.OverlapPenalty">
      <summary>The sum of node overlap penalty and edge overlap penalty.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Owner">
      <summary>The LabelLayout to which this candidate box belongs.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Parameter">
      <summary>
            The model parameter that was used by the underlying model to
            generate this label candidate.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.Propagate">
      <summary>
            Sets the model parameters of the owner of this label candidate to the
            model parameters of this candidate box.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Propagated">
      <summary>If this box had been chosen by the labeling algorithm.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Size">
      <summary>The with and height of the label candidate bounds.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Width">
      <summary>The width of the label candidate bounds.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.X">
      <summary>The minimal x-coordinate of the label candidate bounds.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Y">
      <summary>The minimal y-coordinate of the label candidate bounds.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutData">
      <summary>This class encapsulates layout data for a label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.#ctor(System.Double,System.Double)">
      <summary>Creates a new instance of LabelLayoutData.</summary>
      <param name="width">the width of the label</param>
      <param name="height">the height of the label</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.#ctor(System.Double,System.Double,yWorks.yFiles.Layout.LabelPlacements)">
      <summary>Creates a new instance of LabelLayoutData.</summary>
      <param name="width">the width of the label</param>
      <param name="height">the height of the label</param>
      <param name="preferredPlacement">a preferred placement specifier</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Bounds">
      <summary>The bounds of the label.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Height">
      <summary>The height of the label.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.PreferredPlacement">
      <summary>The preferred placement for this label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.SetLocation(System.Double,System.Double)">
      <summary>Sets the coordinates of the upper-left corner of the label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.SetSize(System.Double,System.Double)">
      <summary>Sets the size of the label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.ToString">
      <summary>Returns a string representation of this object.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Width">
      <summary>The width of the label.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.X">
      <summary>The x-coordinate of the label's upper-left corner.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Y">
      <summary>The y-coordinate of the label's upper-left corner.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutDataRefinement">
      <summary>A layout stage that improves the placement of edge labels.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutDataRefinement.#ctor">
      <summary>Creates a new instance of LabelLayoutDataImprovement</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutDataRefinement.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutDataRefinement.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutDataRefinement.InternalLabelingAlgorithm">
      <summary>
            The internal labeling algorithm used to improve the
            label positions.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutImpl">
      <summary>This class is a default implementation of the LabelLayout interface.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutImpl.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LabelLayoutImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutImpl.Box">
      <summary>The bounding box of the label.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutImpl.ModelParameter">
      <summary>
            The label model parameter that describes
            the position of this label.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutKeys">
      <summary>
            This interface provides label-specific keys that can
            be used to add data providers to a layout graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelLayoutKeys.EdgeLabelLayoutDpKey">
      <summary>
            Key that is used to add or access a data provider to a graph that must
            return for each edge of the graph an array of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelLayoutKeys.NodeLabelLayoutDpKey">
      <summary>
            Key that is used to add or access a data provider to a graph that must
            returns for each node of the graph an array of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutTranslator">
      <summary>
            Layout stage that automatically translates label layout information provided by the standard
            label layout classes
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout"></see>
            to layout data
            of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData"></see>
            that is accessible by the keys defined in class
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutTranslator.#ctor">
      <summary>Creates a new instance of LabelLayoutTranslator.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutTranslator.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>The returned result gets calculated by the core layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutTranslator.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Before invoking the core layouter this stage translates traditional
            label layout information to data provider based label layout data.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels">
      <summary>Specifies whether edge label translation is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels">
      <summary>Specifies whether node label translation is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.WriteBackEdgeLabels">
      <summary>Specifies whether edge labels are written back to their model.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.WriteBackNodeLabels">
      <summary>Specifies whether node labels are written back to their model.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelPlacements"></member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.Anywhere">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label can be placed anywhere along an edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AtSource">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed near the source
            node of an edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AtTarget">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed near the target
            node of an edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AtCenter">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed near the center
            of the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AlongEdgeMask">
      <summary>
            Placement specifier mask. Masks all placement specifiers that are not one of
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.AtTarget"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.AtSource"></see>
            , or
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.AtCenter"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.OnEdge">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed on the path of the edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.LeftOfEdge">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed on the left hand side of the edge
            path if looking from the source node into the direction of the target node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.RightOfEdge">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed on the right hand side of the edge
            path if looking from the source node into the direction of the target node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.OnSideOfEdgeMask">
      <summary>
            Placement specifier mask. Masks all placement specifiers that are not one of
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.OnEdge"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.LeftOfEdge"></see>
            , or
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.RightOfEdge"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelRanking">
      <summary>Implements the ranking for edge and node labels for Graph2D.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelRanking.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LabelRanking" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelRanking.GetProfit(yWorks.yFiles.Layout.LabelCandidate)">
      <summary>Returns the profit for placing a label-candidate.</summary>
      <param name="candidate">a label candidate</param>
      <returns>a value between 0 and 1.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayouterKeys"></member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.EdgeIdDpKey">
      <summary>
            The data provider key used to look up a unique Object identifier
            (consistent with hashCode() and equals() ) for each edge in a graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.NodeIdDpKey">
      <summary>
            The data provider key used to look up a unique Object identifier
            (consistent with hashCode() and equals() ) for each node in a graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey">
      <summary>
            The data provider key used to look up the selected
            state of the edges of the graph to be laid out.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.SelectedNodesDpKey">
      <summary>
            The data provider key used to look up the selected
            state of the nodes of the graph to be laid out.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutGraph">
      <summary>This class represents a drawing of a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.#ctor">
      <summary>Creates a new Layout Graph</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Creates a copy of the given subgraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a copy of the given subgraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.CreateGraphCopyFactory">
      <summary>
            Factory method that is called by
            <see cref="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory"></see>
            to create a (possibly shared) instance.
            </summary>
      <returns>the (possibly shared) instance.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.LayoutGraph.EdgeList">
      <summary>A list, which contains the edges of the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetBoundingBox">
      <summary>Returns the bounding box of the diagram.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetCenter(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the position of a node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <returns>the center of the node in the drawing of the node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetCenterX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the center x-coord of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetCenterY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the center y-coord of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetEdgeLabelLayout(System.Object)">
      <summary>
            Returns
            EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <returns>the edge label layout information for <c>edge</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetEdgeLayout(System.Object)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="edge">a edge in the drawing.</param>
      <returns>the layout information for <c>edge</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetFeature(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge which is described by a given label layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetFeature(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node which is described by a given label layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetHeight(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the given node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns
            EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <returns>the edge label layout information for <c>edge</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns
            NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <returns>the node label layout information for <c>node</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="edge">a edge in the drawing.</param>
      <returns>the layout information for <c>edge</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="node">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLocation(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the position of the node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <returns>the upper left corner of the drawing of the node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetNodeLabelLayout(System.Object)">
      <summary>
            Returns
            NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <returns>the node label layout information for <c>node</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetNodeLayout(System.Object)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="node">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPath(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the path</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPathList(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the path as a YList</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPointList(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the sequence of control points as a YList</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPoints(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the sequence of control points.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetRectangle(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the bounding box of a node.</summary>
      <param name="node">a node in the graph.</param>
      <returns>a box.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetSize(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the size of the node in a drawing.</summary>
      <param name="node">a node in the graph.</param>
      <returns>the size of the node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetSourcePointAbs(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the source end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetSourcePointRel(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the source end point of an edge
            in relative coordinates to the center of the source node.
            </summary>
      <param name="edge">an edge in the graph</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetTargetPointAbs(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the target end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetTargetPointRel(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the target end point of an edge
            in relative coordinates to the center of the target node.
            </summary>
      <param name="edge">an edge in the graph</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetWidth(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the upper left x-coord of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the upper left y-coord of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.MoveBy(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Moves the location of a node by a given vector</summary>
      <param name="node">a node in the graph</param>
      <param name="dx">the x-component of the vector</param>
      <param name="dy">the y-component of the vector</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetCenter(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the center coords of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetCenter(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Sets the position of a node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <param name="position">the center of the node in the drawing of the node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetEndPointsAbs(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Set the two end points of an edge in absolute coordinates.</summary>
      <param name="edge">an edge in the graph.</param>
      <param name="source">the port on the source side of the edge.</param>
      <param name="target">the port on the target side of the edge.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetLocation(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the upper left coords of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetLocation(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Set the position of the node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <param name="position">the upper left corner of the drawing of the node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPath(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPointPath)">
      <summary>Sets the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="path">the path sequence.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPath(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList)">
      <summary>Sets the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="path">the path sequence given as a YList</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPoints(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPointPath)">
      <summary>Sets the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="points">the sequence of control points.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPoints(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList)">
      <summary>Sets the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="points">the sequence of control points as a YList</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSize(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the size of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSize(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Set the size of the node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <param name="size">the size of the node.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSourcePointAbs(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the source end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
      <param name="point">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSourcePointRel(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the source end point of an edge
            in relative coordinates to the center of the source node.
            </summary>
      <param name="edge">an edge in the graph</param>
      <param name="point">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetTargetPointAbs(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the target end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
      <param name="point">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetTargetPointRel(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the target end point of an edge
            in relative coordinates to the center of the target node.
            </summary>
      <param name="edge">an edge in the graph</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory">
      <summary>
            An implementation of the copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier"></see>
            that can be used by implementations of
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="newSource">the source node in the target graph to use for the newly created edge</param>
      <param name="newTarget">the target node in the target graph to use for the newly created edge</param>
      <param name="originalEdge">the original edge from the source graph</param>
      <returns>the newly created edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyEdgeLabelLayout(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Copies the edge label's layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyLabels(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Callback that copies the labels for a given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyLabels(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback that copies the labels for a given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="originalNode">the original node from the source graph</param>
      <returns>the newly created node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyNodeLabelLayout(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Copies the node label's layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CreateGraph">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Layout.DefaultLayoutGraph"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Callback that will be called after the copy operation has completed.</summary>
      <param name="sourceGraph">the graph that was used to copy the entities from.</param>
      <param name="targetGraph">the graph that was used to copy the entities to.</param>
      <param name="nodeMap">
            a map that contains a mapping between the nodes in the source graph
            to their corresponding nodes in the new graph.
            </param>
      <param name="edgeMap">
            a map that contains a mapping between the edges in the source graph
            to their corresponding edges in the new graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that will be called before the copy operation takes place.</summary>
      <param name="sourceGraph">the graph that will be used to copy the entities from.</param>
      <param name="targetGraph">the graph that will be used to copy the entities to.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory">
      <summary>
            An implementation of the copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier"></see>
            that can be used by implementations of
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph"></see>
            that are hierarchically grouped
            using
            <see cref="T:yWorks.yFiles.Layout.Grouping.GroupingKeys"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.CreateNodeId(System.Object,yWorks.yFiles.Algorithms.Node)">
      <summary>Factory method that creates an id for the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="nodeMap">a Map that maps old node instances to their new copies</param>
      <param name="edgeMap">a Map that maps old edge instances to their new copies</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutMultiplexer">
      <summary>
            This class delegates its layout calls to a core layout algorithm that is dynamically
            chosen at runtime by inspecting the nodes of the input graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutMultiplexer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.GetCoreLayouter(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns the core layout algorithm associated with the
            nodes contained in the given graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutMultiplexer.LayouterDpKey">
      <summary>
            Look-up key used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            that provides a
            <see cref="T:yWorks.yFiles.Layout.ILayouter"></see>
            object for each node of a graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutOrientation">
      <summary>Orientation specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.TopToBottom">
      <summary>
            Orientation specifier. Layout will be oriented from top to bottom,
            which is the default for all layout algorithms.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.LeftToRight">
      <summary>
            Orientation specifier. Layout will be from left to right, which means
            that the layout will be rotated by 90 degrees counterclockwise
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.RightToLeft">
      <summary>
            Orientation specifier. Layout will be from right to left, which means
            that the layout will be rotated by 90 degrees clockwise
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.BottomToTop">
      <summary>
            Orientation specifier. Layout will be from bottom to top, which means
            that the layout will be flipped along the x axis.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutTool">
      <summary>
            This class is a container for several helper and utility functions for
            the LayoutGraph class.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutTool" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ApplyGraphLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Applies a GraphLayout to a LayoutGraph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleGrid(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double)">
      <summary>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit into a
            large rectangle, whose bounds will be stored in <c>finalrect</c>.
            </summary>
      <param name="rects">the rectangles whose, coordinates will be modified</param>
      <param name="finalRect">the exact dimension will be placed in this rectangle</param>
      <param name="viewRatio">the preferred ratio of the grid</param>
      <returns>the dimension of the grid</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double)">
      <summary>
            Reassigns the bounds of the rectangles in rects to fit in a large
            rectangle, whose bounds will be stored in finalrect.
            </summary>
      <param name="rects">the rectangles whose coordinates will be modified</param>
      <param name="finalRect">the exact dimension will be placed in this rectangle</param>
      <param name="viewRatio">the preferred ratio of the resulting bounds</param>
      <returns>the number of used rows</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)">
      <summary>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit into a
            large rectangle, whose bounds will be stored in <c>finalrect</c>.
            </summary>
      <param name="alignment">
            determines the alignment policy for rows, that are not
            completely filled
            </param>
      <param name="rects">the rectangles whose coordinates will be modified</param>
      <param name="finalRect">the exact dimension will be placed in this rectangle</param>
      <param name="viewRatio">the preferred ratio of the resulting bounds</param>
      <returns>the number of generated rows</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.AssignReverseLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Set the layout of two parallel edges with different direction identical.</summary>
      <param name="e1">the edge for which the points are set.</param>
      <param name="e2">the template.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ClipEdgeOnBB(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method clips the path of the edge on the bounding box
            of the start and end points.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ClipEdgesOnBB(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            This helper method clips the path of the edge on the bounding box
            of the start and end points.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.EdgeLayoutString(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the path of the layout of a specific edge as a String.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Returns the bounding box of the edges accessible through the given edge cursor.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Returns the bounding box of the nodes accessible through the given node cursor.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Returns the bounding box of the nodes and edges accessible through the given cursors.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IEdgeCursor,System.Boolean)">
      <summary>Returns the bounding box of the nodes and edges accessible through the given cursors.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetEdgeClippedOnBB(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetEdgeClippedOnBB(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Double)">
      <summary>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetEdgeClippedOnBB(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetNodeDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the distance between the centers of two nodes</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetNodePositions(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns the positions of the nodes of a graph's diagram.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetPathLength(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the length of path of a given edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.InitDiagram(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            This method assigns the position (0,0) to all nodes in the graph,
            and sets the edges to straight lines with ports in the center
            of the adjacent node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.IsEdgeOutsideNodes(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Double)">
      <summary>
            This helper method tests if the path of an edge is outside
            the bounding box of the start and end vertices.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.IsEdgeOutsideNodes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method tests if the path of an edge is outside
            the bounding box of the start and end vertices.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Double,System.Double)">
      <summary>Moves the edge points of the given edge by the vector <c>(dx,dy)</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,System.Double,System.Double)">
      <summary>Moves all edges accessible through the given edge cursor by the vector <c>(dx,dy)</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveNode(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Moves the given node by the vector <c>(dx,dy)</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveNodes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,System.Double,System.Double)">
      <summary>Moves all nodes accessible through the given node cursor by the vector <c>(dx,dy)</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveSubgraph(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,System.Double,System.Double)">
      <summary>
            Moves the subgraph induced by edges accessible through the given edge cursor
            by the vector <c>(dx,dy)</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveSubgraph(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,System.Double,System.Double)">
      <summary>
            Moves the subgraph induced by nodes accessible through the given node cursor
            by the vector <c>(dx,dy)</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.PathIntersectsRect(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Checks whether or not the path of an edge intersects the interior of
            a given rectangular area.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RemoveDuplicateBends(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>This helper method removes duplicate bends from all edges in the graph</summary>
      <param name="gd">a graph diagram.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RemoveDuplicateBends(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>This helper method removes duplicate bends from the given edge in the graph</summary>
      <param name="gd">a graph diagram.</param>
      <param name="edge">the edge.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPath(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method assign an trivial path to an edges which has no
            control points and the ports are in the center of the nodes.
            </summary>
      <param name="gd">a graph diagram.</param>
      <param name="edge">an edge in graph.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPaths(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            This helper method assign an trivial path to all edges which has no
            control points and the ports are in the center of the nodes.
            </summary>
      <param name="gd">a graph diagram.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPaths(yWorks.yFiles.Layout.LayoutGraph,System.Boolean)">
      <summary>
            This helper method assign an trivial path to all edges which has no
            control points
            </summary>
      <param name="gd">a graph diagram.</param>
      <param name="resetPorts">whether to reset the ports to the center of the nodes.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPorts(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Sets the ports to the center of the nodes.</summary>
      <param name="gd">a graph diagram.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ReverseEdgeLayout(yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Reverses the layout of an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RoundEdgeLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Round the values of the controllpoints and ports of an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RoundLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Round the values of the layout of an entire layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RoundNodeLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Round the values of the layout of a node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Double)">
      <summary>Routes two edges which are incident to the same nodes, in parallel.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Double,System.Boolean,System.Double,System.Double)">
      <summary>Routes two edges which are incident to the same nodes, in parallel.</summary>
      <param name="gd">the graph</param>
      <param name="e1">the leading edge</param>
      <param name="e2">the edge to be adjusted (may be e1)</param>
      <param name="lineDistance">the distance between the two edges</param>
      <param name="joinEnds">whether the end points should all be set to the end points of e1</param>
      <param name="absJoinDist">
            the absolute distance between the end points and the beginning to
            the parallel segment routing
            </param>
      <param name="relJoinDist">
            the relative distance, measured relative to the length of the
            first/last segments
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.EdgeList,System.Double)">
      <summary>Routes a list of edges with are incident to the same nodes, in parallel.</summary>
      <param name="gd">the graph</param>
      <param name="e1">the leading edge</param>
      <param name="list">the list of edges that will be aligned to e1</param>
      <param name="lineDistance">the distance between two edges</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.EdgeList,System.Double,System.Boolean,System.Boolean,System.Double,System.Double)">
      <summary>Routes a list of edges which are incident to the same nodes, in parallel.</summary>
      <param name="gd">the graph</param>
      <param name="e1">the leading edge</param>
      <param name="list">the list of edges that will be aligned to e1</param>
      <param name="lineDistance">the distance between two edges</param>
      <param name="adjustE1">whether e1 should be adjusted if the size of list is odd</param>
      <param name="joinEnds">whether the end points should all be set to the end points of e1</param>
      <param name="absJoinDist">
            the absolute distance between the end points and the beginning to
            the parallel segment routing
            </param>
      <param name="relJoinDist">
            the relative distance, measured relative to the length of the
            first/last segments
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteSelfLoop(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Routes a self-loop.</summary>
      <param name="e">An edge with <c>e.source.equals(e.target)</c>.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.MinNodeSizeStage">
      <summary>This layout stage enforces a given minimum width/height of the nodes of a graph during the layout process.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a new MinNodeSizeStage that wraps the given core layouter.</summary>
      <param name="core">The core layouter.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.#ctor(yWorks.yFiles.Layout.ILayouter,System.Double,System.Double)">
      <summary>Instantiates a new MinNodeSizeStage that wraps the given core layouter.</summary>
      <param name="core">The core layouter.</param>
      <param name="minWidth">The minimum width of nodes that should be enforced.</param>
      <param name="minHeight">The minimum height of nodes that should be enforced.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.MirrorMask">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.TopToBottom">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirroring the graph for layout
            orientation LayoutOrientation.TOP_TO_BOTTOM.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.RightToLeft">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirroring the graph for layout
            orientation LayoutOrientation.RIGHT_TO_LEFT.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.BottomToTop">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirroring the graph for layout
            orientation LayoutOrientation.BOTTOM_TO_TOP.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.LeftToRight">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirroring the graph for layout
            orientation LayoutOrientation.LEFT_TO_RIGHT.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.NodeLabelCandidate">
      <summary>
            This class represents a candidate position for label associated to a node
            in a graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns a new instance of NodeLabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.INodeLabelLayout,System.Boolean)">
      <summary>Returns a new instance of NodeLabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is inside the node,
            or outside.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.NodeLabelLayoutImpl">
      <summary>
            This class is an default implementation of the NodeLabelLayout
            interface.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelLayoutImpl.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.NodeLabelLayoutImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.NodeLabelLayoutImpl.LabelModel">
      <summary>The node label model associated with this label layout</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage">
      <summary>Layout stage that can be used to normalize the order of the elements within a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.ComparableEdgeDpKey">
      <summary>
            The <c>DataProvider</c> registered with this key must return a
            <see cref="T:System.IComparable"></see>
            object for each edge thereby inducing a (global) order
            for edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.ComparableNodeDpKey">
      <summary>
            The <c>DataProvider</c> registered with this key must return a
            <see cref="T:System.IComparable"></see>
            object for each node thereby inducing a (global) order
            for nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.FillComparableMapFromGraph(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Convenience method that assigns comparable values for each node and edge.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.OrientationLayouter">
      <summary>
            A layout stage that performs changes the orientation
            of the layout that another algorithm calculates.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.#ctor">
      <summary>Instantiates a new OrientationLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a new OrientationLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.#ctor(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>Instantiates a new OrientationLayouter with a given orientation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CompleteOrientationChange(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Method that will be called after the core layouter has been activated.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CompleteTransform(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Transforms a point for the completion phase.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CreateOrientedInsets(yWorks.yFiles.Util.Geom.Insets)">
      <summary>Create and return an insets object that is a geometric transform of the given insets.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CreateOrientedNodeSize(yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Create and return an YDimension object that is a geometric transform of the given size.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.OrientationLayouter.HorizontalOrientation">
      <summary>
            Specifies whether or not the set orientation is a horizontal
            orientation, i.e.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.IsOrientationMirrored(System.SByte)">
      <summary>This method will return whether the layouter will mirror the graph for a given layout orienation.</summary>
      <param name="orientation">the layout orientation, for which to check the mirror state.</param>
      <returns>
        <ul>
          <li>true - if the layouter will mirror the graph at the corresponding axis
            (x-Axis for horizontal orientations, y-Axis for vertical orientations) for the given layout orientation.</li>
          <li>false - otherwise.</li>
        </ul>
      </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.OrientationLayouter.MirrorMask">
      <summary>The mirror mask, that defines which orientations this layouter shall mirror.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">
      <summary>The orientation of the layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.PrepareOrientationChange(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Method that will be called before the core layouter gets activated.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.PrepareTransform(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Transforms a point for the preparation phase.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.Transform(yWorks.yFiles.Algorithms.Geometry.YPoint,System.Boolean)">
      <summary>
            Transforms a point for the preparation or completion
            phase.
            </summary>
      <param name="prepare">
            if <see langword="true"></see> then the transformation
            is for the preparation phase, otherwise for the completion phase.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.ParallelEdgeLayouter">
      <summary>
            A layout algorithm that routes parallel edges
            (edges that connect the same pair of nodes)
            of a graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.#ctor">
      <summary>Creates a new instance of ParallelEdgeLayouter with no core layouter assigned.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of ParallelEdgeLayouter for the given core layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.AbsJoinEndDistance">
      <summary>
            The absolute distance from the end point of the lines to the first
            parallel segments if end joining is enabled.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.AdjustLeadingEdge">
      <summary>
            Specifies whether this layouter will adjust the leading edge if the number of edges
            is even.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.DirectedMode">
      <summary>Specifies whether or not edges should be considered as directed.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.FindAndHideParallelEdges(yWorks.yFiles.Algorithms.Graph)">
      <summary>This method detects parallel edges of the given graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ParallelEdgeLayouter.hiddenEdges">
      <summary>Holds the list of parallel edges that are hidden from the core layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.JoinEnds">
      <summary>
            The state of the automatic end joining mechanism,
            i.e.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.LayoutParallelEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>This method assigns a layout to parallel edges.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.LineDistance">
      <summary>
            The distance between two adjacent
            paths that run in parallel.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ParallelEdgeLayouter.parallelEdges">
      <summary>EdgeMap that associates a hidden edge with the unique parallel edge not hidden from the core layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.RelJoinEndDistance">
      <summary>
            The relative distance from the end point of the lines to the first
            parallel segments if end joining is enabled.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter">
      <summary>This layout stage provides a framework for layouts that are based on a divide and conquer approach.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.PartitionLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns
            <see cref="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.InterEdgeRouter">
      <summary>The currently set InterEdgeRouter instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.PartitionFinder">
      <summary>The currently set PartitionFinder instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.PartitionPlacer">
      <summary>The currently set PartitionPlacer instance.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter">
      <summary>
            InterEdgeRouter implementation that routes inter-edges using
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.ChannelEdgeRouter">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter"></see>
            instance used to route inter-edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.InterEdgeDPKey">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            key which is used to register the
            inter-edge data provider passed to
            <see cref="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)"></see>
            on the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.Margin">
      <summary>
            The maximum relative distance between an edge and its closest
            node for edges routed outside the bounding box of all graph nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Routes inter-edges of the partitioned graph.</summary>
      <param name="graph">the input graph.</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph
            indicating if the edge is an inter-edge or not.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdgesOnly">
      <summary>
        <see langword="true">
        </see> if this <c>ChannelInterEdgeRouter</c>
            is configured to route inter-partition edges only.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer">
      <summary>
            PartitionPlacer implementation that uses
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter"></see>
            to place
            the partitions.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer.ComponentLayouter">
      <summary>The ComponentLayouter instance used to place the graph partitions.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer.PlacePartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Arranges the graph while taking partition ids and inter-edge information into account.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not. An inter-edge is an edge that connects nodes that do not
            belong to the same partition.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder">
      <summary>
            PartitionFinder implementation that uses
            <see cref="M:yWorks.yFiles.Algorithms.Groups.EdgeBetweennessClustering(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)"></see>
            as partition strategy.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.FindPartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns a partition id for each node of an input graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDMap">used to return the resulting partition ids</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.MaximumPartitionCount">
      <summary>The maximum number of partitions that this class should return.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.MinimumPartitionCount">
      <summary>The minimum number of partitions that this class should return.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.IInterEdgeRouter">
      <summary>Implementations of this interface are responsible for routing inter-edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.IInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Routes inter-edges of the partitioned graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.IPartitionFinder">
      <summary>Implementations of this interface are responsible to partition the input graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.IPartitionFinder.FindPartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns a partition id for each node of an input graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDMap">used to return the resulting partition ids</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.IPartitionPlacer">
      <summary>Implementations of this interface are responsible for arranging the graph partitions.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.IPartitionPlacer.PlacePartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Arranges the graph while taking partition ids and inter-edge information into account.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not. An inter-edge is an edge that connects nodes that do not
            belong to the same partition.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter">
      <summary>
            InterEdgeRouter implementation that routes inter-edges using
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.OrthogonalEdgeRouter">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            instance used to route inter-edges.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Routes inter-edges of the partitioned graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCalculator">
      <summary>
            This class implements a LayoutStage that can be used to adjust the final port
            assignments after a layout has been calculated.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.#ctor">
      <summary>Creates a new PortCalculator without a core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new PortCalculator using the given layouter as the core of
            this layout stage.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.CalculatePorts(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Performs the actual port calculation on the specified graph instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCalculator.Eps">
      <summary>
            EPSILON used by
            <see cref="M:yWorks.yFiles.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)">
      <summary>Callback method that determines whether two points are equal.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidate">
      <summary>This class represents a candidate for an edge's ports.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(System.Double,System.Double,System.Boolean,yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>Creates a new instance of PortCandidate using the given values.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(System.Double,System.Double,yWorks.yFiles.Layout.PortDirection)">
      <summary>Creates a new instance of PortCandidate using the given values.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(yWorks.yFiles.Layout.PortDirection)">
      <summary>Creates a new instance of PortCandidate using the given direction.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>Creates a new instance of PortCandidate using the given values.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.Cost">
      <summary>The cost associated with the usage of this PortCandidate.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(System.Double,System.Double,yWorks.yFiles.Layout.PortDirection)">
      <summary>
            Factory method that returns an instance describing a fixed port with zero
            cost penalty for the given direction at the given offsets.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <param name="xOffset">the x offset</param>
      <param name="yOffset">the y offset</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(System.Double,System.Double,yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>
            Factory method that returns an instance describing a fixed port with the given
            cost penalty for the given
            direction at the given offset.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <param name="cost">the cost to associate with the usage of this port</param>
      <param name="xOffset">the x offset</param>
      <param name="yOffset">the y offset</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(yWorks.yFiles.Layout.PortConstraint)">
      <summary>
            Factory method that returns an instance describing a non-fixed port with zero
            cost penalty for the direction specified by the given
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see></summary>
      <param name="fromPortConstraint">the port constraint to obtain the direction from</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(yWorks.yFiles.Layout.PortDirection)">
      <summary>
            Factory method that returns an instance describing a non-fixed port with 0 cost penalty for the given
            direction.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>
            Factory method that returns an instance describing a non-fixed port with the given
            cost penalty for the given
            direction.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <param name="cost">the cost to associate with the usage of this port</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.Direction">
      <summary>The direction mask for this instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.Equals(System.Object)">
      <summary>Tests for equality based on the internal attributes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.Fixed">
      <summary>
            Specifies whether this instance describes a fixed or
            <see cref="P:yWorks.yFiles.Layout.PortConstraint.Strong">strong</see>
            port.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            Returns the direction constant with respect to the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <param name="layoutOrientation">the orientation for which the direction should be interpreted.</param>
      <returns>
            the
            <see cref="P:yWorks.yFiles.Layout.PortCandidate.Direction"></see>
            with respect to the orientation.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            Yields the X-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <param name="layoutOrientation">The orientation for which to interpret the x offset.</param>
      <returns>The x offset.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            Yields the Y-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <param name="layoutOrientation">The orientation for which to interpret the x offset.</param>
      <returns>The y offset.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.IsInDirection(yWorks.yFiles.Layout.PortDirection)">
      <summary>Determines whether this instance lies in the given direction.</summary>
      <param name="directionMask">the mask of directions as defined by the constants in this class.</param>
      <returns>whether this instance specifies on of the given directions</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key that holds a
            <see cref="T:yWorks.yFiles.Util.ICollection"></see>
            of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            s for the
            source port of each edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key that holds a
            <see cref="T:yWorks.yFiles.Util.ICollection"></see>
            of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            s for the
            target port of each edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.ToPortConstraint">
      <summary>
            A utility method for converting this instance to a
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see></summary>
      <returns>a PortConstraint that matches this PortCandidate</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.ToPortConstraintForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            A utility method for converting this instance to a
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            interpreted for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <returns>a PortConstraint that matches this PortCandidate</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.ToString">
      <summary>Returns a human-readable string representation of this PortCandidate.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.XOffset">
      <summary>The x offset of the port with respect to the corresponding node's center.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.YOffset">
      <summary>The y offset of the port with respect to the corresponding node's center.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidateSet">
      <summary>
            This class describes a set of possible
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            s and their cardinality for a node-like entity.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.#ctor">
      <summary>Creates a new and empty instance of PortCandidateSet</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.Add(yWorks.yFiles.Layout.PortCandidate)">
      <summary>Adds another PortCandidate with capacity 1 to the set of PortCandidates.</summary>
      <param name="p">the candidate to add.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.Add(yWorks.yFiles.Layout.PortCandidate,System.Int32)">
      <summary>Adds another PortCandidate with the given capacity to the set of candidates.</summary>
      <param name="p">the candidate to add</param>
      <param name="connections">the maximum number of connections allowed to the candidate</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.ConnectionCount">
      <summary>
            The maximum number of connections this set allows or
            <see cref="F:System.Int32.MaxValue"></see>
            if
            the number is unbound.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.CreateMatcher">
      <summary>
            Creates a CandidateMatcher instance that can be used to query
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">entries</see>
            from.
            </summary>
      <returns>a fresh matching instance that reflects the current state of this set of candidates.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.Entries">
      <summary>
            An Iterator over the list of
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">entries</see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.GetCost(yWorks.yFiles.Layout.PortCandidateSet.IEntry,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Double,System.Double)">
      <summary>Calculates the cost for each entry for the given edge configuration.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.GetPriority(yWorks.yFiles.Layout.PortCandidateSet.IEntry,yWorks.yFiles.Algorithms.Edge,System.Boolean)">
      <summary>Returns the priority of the given entry.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCandidateSet.NodeDpKey">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            key used to associate instances of this class with nodes in a graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.Remove(yWorks.yFiles.Layout.PortCandidateSet.IEntry)">
      <summary>Removes the entry from the internal list of PortCandidate entries.</summary>
      <param name="entry">the entry to remove from this set of candidates.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher">
      <summary>
            The interface that is used by
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet"></see>
            to retrieve
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            s from.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate">
      <summary>
            Returns an the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry"></see>
            .
            </summary>
      <returns>the next best entry with respect to the costs</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Double,System.Double,System.Int32)">
      <summary>
            Returns the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry"></see>
            for the given parameters.
            </summary>
      <param name="edge">the edge that will connect to the port</param>
      <param name="source">whether the edge connects to the node with its source side</param>
      <param name="xOffset">the preferred x offset of the connection point (relative to the node's center)</param>
      <param name="yOffset">the preferred y offset of the connection point (relative to the node's center)</param>
      <param name="directionMask">
            a bitwise combination of the constants defined in
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            indicating the preferred connection points
            </param>
      <returns>the next best entry with respect to the constraints and the costs</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Int32)">
      <summary>
            Returns an the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry"></see>
            for the given parameters.
            </summary>
      <param name="edge">the edge that will connect to the port</param>
      <param name="source">whether the edge connects to the node with its source side</param>
      <param name="directionMask">
            a bitwise combination of the constants defined in
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            indicating the preferred connection points
            </param>
      <returns>the next best entry with respect to the constraints and the costs</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">
      <summary>
            An interface that is returned by the find methods in
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher"></see>
            and the
            <see cref="P:yWorks.yFiles.Layout.PortCandidateSet.Entries"></see>
            method.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.IEntry.Connections">
      <summary>The maximum number of connections allowed for the port candidate.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.IEntry.PortCandidate">
      <summary>The associated PortCandidate.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraint">
      <summary>
            This class represents a constraint for either a source or target port
            of an edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.#ctor">
      <summary>
            Creates the empty constraint, that allows ports to connect at any side of a
            node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.#ctor(yWorks.yFiles.Layout.PortSide)">
      <summary>
            Creates the weak constraint, that allows ports to connect to a specific side
            of a node.
            </summary>
      <param name="side">
            weak constraint specifier. One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East"></see>
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.#ctor(yWorks.yFiles.Layout.PortSide,System.Boolean)">
      <summary>
            Creates a constraint, that allows ports to connect to a specific side
            of a node.
            </summary>
      <param name="side">
            weak constraint specifier. One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East"></see>
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West"></see>
            .
            </param>
      <param name="strong">
            whether the layouter should use the current port coordinates
            (strong constraint)
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtAnySide">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any"></see>
            associated
            with it.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtEast">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.East"></see>
            associated
            with it.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtNorth">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.North"></see>
            associated
            with it.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtSouth">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.South"></see>
            associated
            with it.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtWest">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.West"></see>
            associated
            with it.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.Create(yWorks.yFiles.Layout.PortSide)">
      <summary>Creates a weak port constraint.</summary>
      <param name="side">
            One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East"></see>
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.Create(yWorks.yFiles.Layout.PortSide,System.Boolean)">
      <summary>Creates a port constraint.</summary>
      <param name="side">
            One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East"></see>
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West"></see>
            .
            </param>
      <param name="strong">defines whether it is a strong or weak PortConstraint.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.Equals(System.Object)">
      <summary>
            Tests for equality based on the strong attribute and the
            side attribute.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.GetSPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the source port constraint associated with the
            given edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.GetTPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the target port constraint associated with the
            given edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.HasPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns whether or not there are non-trivial
            source or target port constraints associated with the
            given edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.HasSPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns whether or not there is a non-trivial
            source port constraint associated with the
            given edge.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.HasTPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns whether or not there is a non-trivial
            target port constraint associated with the
            given edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.Side">
      <summary>The side of a node at which a port should connect.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.Strong">
      <summary>
        <see langword="true">
        </see> if this <c>PortConstraint</c> represents
            a strong constraint and <see langword="false"></see> otherwise.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.ToString">
      <summary>Returns a string representation of this object.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraintConfigurator">
      <summary>Provides configuration services for the port constraints of a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.#ctor">
      <summary>Creates a new instance of PortConstraintConfigurator</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.CreatePortConstraintFromSketch(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>Creates and returns a port constraint for the given edge.</summary>
      <param name="source">
            if <see langword="true"></see> a source port constraint for the given
            edge will be created, otherwise a target port constraint.
            </param>
      <param name="strong">
            if <see langword="true"></see> a strong port constraint is created,
            otherwise a weak port constraint is created.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.CreatePortConstraintsFromSketch(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean)">
      <summary>Creates port constraints for some edges of the given graph.</summary>
      <param name="ec">EdgeCursor that provides access to the edges for which to set port constraints.</param>
      <param name="spcMap">an edge map that will be used to store the source port constraints of the edges.</param>
      <param name="strongSP">whether or not to assign strong source port constraints</param>
      <param name="tpcMap">an edge map that will be used to store the target port constraints of the edges.</param>
      <param name="strongTP">whether or not to assign strong target port constraints</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.CreatePortConstraintsFromSketch(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Creates weak port constraints for all edges of the given graph.</summary>
      <param name="spcMap">an edge map that will be used to store the source port constraints of the edges.</param>
      <param name="tpcMap">an edge map that will be used to store the target port constraints of the edges.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraintEnforcementStage">
      <summary>
            This layout stage can be used to enforce that a layout algorithm will not change
            the relative coordinates of ports that are associated with a strong/fixed port constraint.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintEnforcementStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.PortConstraintEnforcementStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintEnforcementStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintEnforcementStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraintKeys">
      <summary>
            This interface defines keys used to associate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">DataProviders</see>
            
            that provide port constraints for all edges of the input graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            that provides source port
            group information for edges of the input graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            that provides source port
            constraints for edges of the input graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            that provides target port
            group information for edges of the input graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            that provides target port
            constraints for edges of the input graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortDirection"></member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.North">
      <summary>Constant indicating a port in the north of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.East">
      <summary>Constant indicating a port in the east of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.West">
      <summary>Constant indicating a port in the west of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.South">
      <summary>Constant indicating a port in the south of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.WithTheFlow">
      <summary>
            Constant indicating a port lying in the direction of the main flow of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.AgainstTheFlow">
      <summary>
            Constant indicating a port lying in the opposite direction of the main flow of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.LeftInFlow">
      <summary>
            Constant indicating a port lying to the left of the direction of the main flow
            of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.RightInFlow">
      <summary>
            Constant indicating a port lying in the right of the direction of the main flow
            of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.Any">
      <summary>A bitwise combination of all possible direction constants.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortSide">
      <summary>Weak constraint specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.Any">
      <summary>
            Weak constraint specifier. Indicates that any side of the
            node will do for the port direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.North">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the north side (i.e. top side) of a node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.South">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the south side (i.e. bottom side) of a node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.East">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the east side (i.e. right side) of a node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.West">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the west side (i.e. left side) of a node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.RemoveColinearBendsStage">
      <summary>This LayoutStage removes all collinear bends found in the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.RemoveColinearBendsStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.RemoveColinearBendsStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.RemoveColinearBendsStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.RemoveColinearBendsStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Removes collinear bends of the edges.</summary>
      <param name="graph">
      </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.RemoveColinearBendsStage.Scale">
      <summary>The current scale, to which this stage will refer, when checking for collinearity.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.RowAlignment">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Leading">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)"></see>
            .
            Rectangles in one row will be aligned with the leading edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Trailing">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)"></see>
            .
            Rectangles in one row will be aligned to the trailing edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Justified">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)"></see>
            .
            Rectangles in one row will be justified in the row.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Center">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)"></see>
            .
            Rectangles in one row will be centered on the row.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SelfLoopLayouter">
      <summary>A layout algorithm that routes the self-loops (reflexive edges) of a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.#ctor">
      <summary>Instantiates a new SelfLoopLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a new SelfLoopLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Whether or not this layouter can layout the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Lays out the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SelfLoopLayouter.KeepAllSelfloopLayouts">
      <summary>Specifies whether this algorithm should keep the existing layout of all self-loops.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SelfLoopLayouter.KeepSelfLoopLayoutDpKey">
      <summary>
            This
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            key can be used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            with the graph to be laid out.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.LayoutSelfLoops(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Lays out the self-loops of the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SequentialLayouter">
      <summary>
            This Layouter will take several
            <see cref="T:yWorks.yFiles.Layout.ILayouter"></see>
            implementations and will run these layouters one after the other in
            the order in which they were added.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.SequentialLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.AppendLayouter(yWorks.yFiles.Layout.ILayouter)">
      <summary>Appends the given layouter to the end of the layouter chain.</summary>
      <param name="layouter">the layouter that should be appended to the chain.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.AppendLayouters(System.Collections.Generic.ICollection{yWorks.yFiles.Layout.ILayouter})">
      <summary>Appends the specified layouters to the end of the layouter chain.</summary>
      <param name="layouters">the layouters that should be appended to the chain.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.ClearLayouterChain">
      <summary>Clears the layouter chain and therefore removes all layouters.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SequentialLayouter.Layouters">
      <summary>A list of the layouters that are currently in the layout chain.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels at a set of continuous positions
            along both sides of an edge or directly on the edge path.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.SliderMode)">
      <summary>Returns a new instance of SliderEdgeLabelModel.</summary>
      <param name="mode">
            Determines which slider mode to use.
            Possible values are either
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center"></see>
            or
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side"></see>
            .
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)"></see>
            
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.Density">
      <summary>The density to generate label candidate positions.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given edge label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the coordinates of the upper-left corner of the label position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of a label position.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.GetOffsetVec(System.Double,System.Double,System.Double,System.Double,yWorks.yFiles.Layout.SliderRatio)">
      <summary>Returns the offset vector for a given edge label and a given edge segment.</summary>
      <param name="dx">x-coordinates delta for an edge segment.</param>
      <param name="dy">y-coordinates delta for an edge segment.</param>
      <param name="width">The label's width.</param>
      <param name="height">The label's height.</param>
      <param name="labelPosition">
            One of the symbolic ratio specifiers
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left"></see>
            ,
            or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right"></see>
            .
            </param>
      <returns>An offset vector.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.NodeBorderDistance">
      <summary>The minimal distance between the label's bounding box and a node's borders.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.SetDistances(System.Double,System.Double)">
      <summary>
            Sets the minimum and maximum distances between the label's bounding box and
            the edge's path.
            </summary>
      <param name="minDistance">
            
            The minimal distance between label and edge.
            </param>
      <param name="maxDistance">
            
            The maximal distance between label and edge.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter">
      <summary>
            Encodes the model parameters for the two slider edge label models specified
            by
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.#ctor(System.Int32,System.Double,yWorks.yFiles.Algorithms.Geometry.YVector,System.SByte,System.Double)">
      <summary>Returns a new instance of ModelParameter that has the given characteristics.</summary>
      <param name="s">
            
            The index of the edge segment relative to which the label should be placed.
            </param>
      <param name="r">
            
            The label's ratio with respect to the length of the edge segment relative
            to which it should be placed.
            </param>
      <param name="v">
            
            The offset vector between the label and the edge segment relative to which
            it should be placed.
            </param>
      <param name="p">
            
            One of the symbolic ratio specifiers
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left"></see>
            ,
            or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right"></see>
            .
            </param>
      <param name="aRatio">
            
            The label's absolute ratio with respect to the entire length of the edge
            path.
            <br></br>
            Note that this value is derived from the ratio value.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.AbsRatio">
      <summary>
            The label's absolute ratio with respect to the entire length of the
            edge path.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.LabelPosition">
      <summary>
            The label's symbolic ratio specifier, i.e., one of
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left"></see>
            , or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right"></see>
            .
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.OffsetVector">
      <summary>
            The offset vector between the label and the edge segment relative
            to which it is placed.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.Ratio">
      <summary>
            The label's ratio with respect to the length of the edge segment
            relative to which it is placed.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.SegmentNumber">
      <summary>The index of the edge segment relative to which the label is placed.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderMode">
      <summary>Symbolic slider mode specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderMode.Center">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderMode.Side">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions along the sides of the edge path.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderRatio">
      <summary>Symbolic ratio specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Center">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Tail">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side"></see>
            .
            Determines a label to be right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Head">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side"></see>
            .
            Determines a label to be left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Left">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side"></see>
            .
            Determines a label to be left of the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Right">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side"></see>
            .
            Determines a label to be right of the edge's path.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SubgraphLayouter">
      <summary>
            A layout stage that filters out all graph elements
            that are not part of a subgraph that is induced by
            the selected nodes of the input graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.SubgraphLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.SubgraphLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Swimlanes">
      <summary>Helper class for swimlanes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Swimlanes" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.ArrangeSwimlanes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Calculates an ordering of the swim lanes such that:
            <p></p>
            1) the number of swim lanes traversed by edges is reduced.
            </summary>
      <param name="graph">the input graph.</param>
      <param name="node2Swimlane">
            a DataProvider assigning an object of class
            <see cref="T:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant"></see>
            to each node in the
            graph. Two nodes v,w are in the same swim lane if they are assigned to the same swim lane
            representant. After calling this method, method
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos"></see>
            returns for each swim lane representant an integer value (&gt;= 0) denoting the optimized
            position of the associated swim lane.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.ArrangeSwimlanes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,yWorks.yFiles.Layout.SwimlanesMode)">
      <summary>
            Calculates an ordering of the swim lanes such that:
            <p></p>
            1) the number of swim lanes traversed by edges is reduced.
            </summary>
      <param name="graph">the input graph.</param>
      <param name="node2Swimlane">
            a DataProvider assigning an object of class
            <see cref="T:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant"></see>
            to each node in the
            graph. Two nodes v,w are in the same swim lane if they are assigned to the same swim lane
            representant. After calling this method, method
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos"></see>
            returns for each swim lane representant an integer value (&gt;= 0) denoting the optimized
            position of the associated swim lane.
            </param>
      <param name="iterations">the number of iterations performed by the heuristic. The default value is 5.</param>
      <param name="mode">
            swim lane ordering mode specifier. Possible values are
            <see cref="F:yWorks.yFiles.Layout.SwimlanesMode.Mixed"></see>
            (default),
            <see cref="F:yWorks.yFiles.Layout.SwimlanesMode.OnlyGroups"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.SwimlanesMode.IgnoreGroups"></see>
            .
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant">
      <summary>Class that internally represents a swim lane.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.#ctor(System.Int32,System.Boolean)">
      <summary>Creates a new instance of <c>SwimlaneRepresentant</c>.</summary>
      <param name="swimlanePos">denotes the current position of the represented swim lane.</param>
      <param name="allowRearrangement">
        <see langword="true">
        </see> if the represented swim lane may be rearranged (see
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.AllowRearrangement"></see>
            )
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.AllowRearrangement">
      <summary>Specifies whether the represented swim lane can be rearranged.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos">
      <summary>The current position of the represented swim lane.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SwimlanesMode">
      <summary>Swim lane ordering mode specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SwimlanesMode.IgnoreGroups">
      <summary>
            Swim lane ordering mode specifier. Specifies that node grouping is ignored during the swim lane ordering
            optimization.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SwimlanesMode.OnlyGroups">
      <summary>
            Swim lane ordering mode specifier. Specifies that only node grouping is considered during the swim lane ordering
            optimization.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SwimlanesMode.Mixed">
      <summary>
            Swim lane ordering mode specifier. Specifies that both node grouping and edge length are considered during the swim
            lane ordering optimization.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.CircularLayouter">
      <summary>Circular style layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.#ctor">
      <summary>Create a new instance of this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.BalloonLayouter">
      <summary>
            The BalloonLayouter used for arranging the partitions
            <p></p>
            Configuring that layouter has effect upon the partition arrangement
            within the overall layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns <see langword="true"></see>.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.CircularLayouter.CircularCustomGroupsDpKey">
      <summary>This key is used to identify custom groups.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.FromSketchMode">
      <summary>
            Specifies whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the partitions and the partitions themselves.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle">
      <summary>The global layout style for this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.MaximalDeviationAngle">
      <summary>The maximal deviation angle allowed for an edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle">
      <summary>The layout style for the arrangement of each partition.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.SingleCycleLayouter">
      <summary>
            The SingleCycleLayouter used for laying out single node cycles
            <p></p>
            Configuring that layouter has effects upon single cycle layouts
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.LayoutStyle">
      <summary>Layout style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact">
      <summary>
            Layout style specifier. In this layout style the nodes within a
            biconnected component of the input graph are treated as separate
            partitions. If a node belongs to more biconnected components,
            it will be assigned to the one that seems to be more suitable.
            <p></p>
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle"></see></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccIsolated">
      <summary>
            Layout style specifier. In this layout style the nodes within a
            biconnected component of the input graph are treated as separate
            partitions.
            If a node belongs to more biconnected components,
            it will form an isolated partition and will be laid out
            in between all of it's biconnected component cycles.
            <p></p>
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle"></see></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.CircularCustomGroups">
      <summary>
            Layout style specifier. In this layout style the user can specify groups that
            will each form a separate partition. To specify groups, a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            with key
            <see cref="F:yWorks.yFiles.Layout.Circular.CircularLayouter.CircularCustomGroupsDpKey"></see>
            must be registered.
            <p></p>
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle"></see></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.SingleCycle">
      <summary>
            Layout style specifier.  In this layout style all nodes of the input graph
            will be put on or inside a single cycle.
            <p></p>
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle"></see></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle"></member>
    <member name="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Cycle">
      <summary>
            Place each node of a partition on the boundary of a circle.
            <p></p>
            This style is very fast, but the results may need much space.
            <p></p>
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle"></see></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Disk">
      <summary>
            Create semi-compact layout for each partition.
            <p></p>
            This style places nodes in the inside and the border
            of a circle and arranges them in an organic manner, leading to more compact
            layout. Only nodes with connections into other partitions are guaranteed to lie on the boundary of
            the resulting disk.
            This style may come with a performance penalty.
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle"></see></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Organic">
      <summary>
            Create most compact layout for each partition.
            <p></p>
            This style creates an organic circular layout for each partition. Even nodes that connect
            into different partitions may be placed in the inside of the resulting disk.
            This style may come with a performance penalty.
            <p></p>
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle"></see></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.SingleCycleLayouter">
      <summary>A layouter that places the nodes of a graph on a cycle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Circular.SingleCycleLayouter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.AutomaticRadius">
      <summary>Specifies whether or not to choose the cycle radius automatically.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns <see langword="true"></see>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.FixedRadius">
      <summary>
            The fixed radius for the cycle on which the nodes of the graph
            will be placed.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.FromSketchModeEnabled">
      <summary>
            Specifies whether or not to take the coordinates of the input diagram
            into account when arranging the nodes.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.InitialAngle">
      <summary>The angle for the first node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.LastAppliedRadius">
      <summary>The radius last applied by this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.MinimalNodeDistance">
      <summary>
            The distance to keep between the nodes on the cycle
            Default value is 30.0.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.MinimalRadius">
      <summary>The minimal radius for the cycle on which the nodes are placed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.NodeSequencer">
      <summary>
            The node sequencer used to determine the order of nodes
            around a cycle.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy"></member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.DoNotSortBySex">
      <summary>Disables sorting the individuals according to their sex.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.FemaleFirst">
      <summary>Places female individuals before their male siblings and partners if possible.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.FemaleAlwaysFirst">
      <summary>Places female individuals before their male siblings and partners.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.MaleFirst">
      <summary>Places female individuals before their male siblings and partners if possible.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.MaleAlwaysFirst">
      <summary>Places female individuals before their male siblings and partners.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter">
      <summary>This class implements a layout algorithm for genealogic data (family trees).</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.#ctor">
      <summary>Creates a new instance of this</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.Alignment">
      <summary>The vertical alignment of the individual nodes</summary>
      <exception cref="T:System.ArgumentException">if the given value is not defined.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see> if the given graph can be layed out by this algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
      <param name="graph">The graph to run the layout on</param>
      <exception cref="T:System.InvalidOperationException">
            If the data provider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType"></see>
            is not registered
            </exception>
      <exception cref="T:yWorks.yFiles.Algorithms.InvalidGraphStructureException">If a family node has more than two parents, or two nodes of the same type are linked together</exception>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType">
      <summary>
            Data provider key which defines a data provider for nodes which returns a String which defines the type of the
            node as defined in
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFamily"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeMale"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFemale"></see>
            .
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.FamilyNodesAlwaysBelow">
      <summary>Determines wheter family/marriage nodes will be placed between the partners or below them.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.OffsetForFamilyNodes">
      <summary>The offset by which a family node will be shifted down if its parents are not direct neighbours.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.PartnerlessBelow">
      <summary>Determines the treatment of individuals who have only children but no partners.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.SortFamilyMembers">
      <summary>The policy the individuals of a family will be sorted by their sex.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.SpacingBetweenFamilyMembers">
      <summary>The (horizontal) space between two nodes representing members of the same family.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TopLayouter">
      <summary>The layouter which is responsible for the layout between the family groups.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFamily">
      <summary>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType"></see>
            for nodes which represent a family.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFemale">
      <summary>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType"></see>
            for nodes which represent a female individual.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeMale">
      <summary>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType"></see>
            for nodes which represent a male individual.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment"></member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment.Top"></member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment.Center"></member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment.Bottom"></member>
    <member name="T:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage">
      <summary>A layout stage for hierarchically grouped graphs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.#ctor">
      <summary>Creates a new instance of FixedGroupLayoutStage</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.FixedGroupNodesDpKey">
      <summary>
            This key can be used to <em>select</em> specific group nodes whose contents
            should keep their relative positions.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.InterEdgeRoutingStyle">
      <summary>The inter-edge routing style used by this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.OrthogonalEdgeRouter">
      <summary>
            The orthogonal edge router instance used to route
            the inter-edges orthogonally.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.GraphGrouping">
      <summary>
            Instances of this class can be used by algorithms to efficiently query the structure
            of such type of graphs.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Creates a new instance of Grouping.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.CreateInfoMap(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Factory method for a NodeMap</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.Dispose">
      <summary>Disposes the data structures held by this instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.DisposeInfoMap(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Factory destructor method for a NodeMap</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the children of the given group node as a NodeList.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetDescendants(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns all descendants of the given group node as a NodeList.</summary>
      <param name="parent">
            
            A group node.
            If <see langword="null"></see> is given, the graph's root is used.
            </param>
      <returns>
            
            A recursively built NodeList containing all descendants of the given group
            node.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetEdgesGoingIn(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that returns a list of all Edges crossing the group node
            boundary of the given group node in such a way, that there target is inside the
            group node and the source does not lie inside the group node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetEdgesGoingOut(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that returns a list of all Edges crossing the group node
            boundary of the given group node in such a way, that there target is outside the
            group node and the source does not lie outside the group node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetParent(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the parent of the given node or <see langword="null"></see> if the node
            is at the top of the hierarchy
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetRepresentative(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that returns a node that can be used to represent
            <c>node</c> in the group <c>inGroup</c>, that is either the node
            itself if it is an immediate child of <c>inGroup</c>, or a node that
            is a child of <c>inGroup</c> and an ancestor of <c>node</c> at the
            same time or <see langword="null"></see> if neither of the latter applies.
            </summary>
      <param name="node">the node for which a representative will be returned</param>
      <param name="inGroup">the group to which the representative should belong.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.Init">
      <summary>Initializes internal data structures.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsFlat(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            A graph is considered to be flat if it is either not grouped
            or there is no group node that contains child nodes present in the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsGrouped(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            A graph is considered to be grouped if the three low-level
            grouping data providers
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupDpKey"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.NodeIdDpKey"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey"></see>
            are registered.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsGroupNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines if the given node is a group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsNormalEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Determines if the given Edge is a normal edge, i.e.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.LayoutGraph">
      <summary>The graph instance this object provides information for.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.Root">
      <summary>
            A node instance that can be used as a handle to the virtual root
            of the node hierarchy.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.GroupingKeys">
      <summary>
            This interface defines data provider keys for those layout algorithms that can
            handle hierarchically grouped graphs.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupDpKey">
      <summary>This key is used to distinguish normal nodes from group nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey">
      <summary>This key is used to provide insets for group nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey">
      <summary>This key is used to provide minimum sizes for nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.NodeIdDpKey">
      <summary>
            This key is used to register a DataProvider instance with a graph, that
            associates each node instance with a unique (based on hashCode() and equals())
            id.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey">
      <summary>This key is used to actually describe the hierarchy of the nodes in the graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.GroupNodeHider">
      <summary>A layout stage for hierarchically grouped graphs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.#ctor">
      <summary>Creates a new instance of GroupNodeHider</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of GroupNodeHider.</summary>
      <param name="coreLayouter">the core layouter used by this layout stage.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GroupNodeHider.GroupBoundsCalculator">
      <summary>The currently installed GroupBoundsCalculator instance</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.HideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Hides the group nodes and adjacent edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.UnhideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Unhides group nodes and adjacent edges from the graph that were previously hidden using method
            <see cref="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.HideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator">
      <summary>
            Implementations of this interface are responsible for calculating the bounds
            of a group node during a layout process.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList)">
      <summary>This method is called during the layout process.</summary>
      <param name="graph">the graph instance for which the bounds will be calculated</param>
      <param name="groupNode">the group node whose bounds will be calculated</param>
      <param name="children">a list of nodes which reside inside the group node</param>
      <returns>a Rectangle2D instance that describes the bounds of the group node.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator">
      <summary>Convenience implementation which allows for custom insets for each group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor">
      <summary>
            Constructs an instance that uses insets provided through the
            data provider registered at the input graph with the public key
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(System.Object)">
      <summary>Constructs an instance using the given DataProvider key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(System.Object,yWorks.yFiles.Util.Geom.Insets)">
      <summary>Constructs an instance using the given DataProvider key and default insets.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(yWorks.yFiles.Util.Geom.Insets)">
      <summary>
            Constructs an instance that uses the specified insets as the default if
            the data provider contains no insets information for a specific node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList)">
      <summary>This method is called during the layout process.</summary>
      <param name="graph">the graph instance for which the bounds will be calculated</param>
      <param name="groupNode">the group node whose bounds will be calculated</param>
      <param name="children">a list of nodes which reside inside the group node</param>
      <returns>a Rectangle2D instance that describes the bounds of the group node.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.ConsiderNodeLabelsEnabled">
      <summary>
            Specifies whether the bounds calculation for group nodes takes labels of the
            group's content nodes into account.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.CreateEnlargedBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>This method enlarges the given graph bounds by the insets associated with the given group node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.DefaultInsets">
      <summary>The default insets.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.GetNodeBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList)">
      <summary>
            Calculates and returns the united bounds of the given nodes only,
            no labels or adjacent edges are considered.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDPKey">
      <summary>The DataProvider key that is used to get the insets for the nodes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle">
      <summary>Inter-edge routing style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle.Adopt">
      <summary>
            Inter-edge routing style specifier. Adopts the edge layout from
            the core layouter.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle.Orthogonal">
      <summary>Inter-edge routing style specifier. Routes the inter-edges in an orthogonal style.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle.Straightline">
      <summary>Inter-edge routing style specifier. Routes the inter-edges as a straight line.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter">
      <summary>
            A special component layouter that handles hierarchically grouped graphs
            in a special way.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.#ctor">
      <summary>Create a new instance of IsolatedGroupComponentLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Create a new instance of IsolatedGroupComponentLayouter.</summary>
      <param name="coreLayouter">
            the core layouter being invoked for each component
            of the graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns true, iff the coreLayouter returns true for all components
            of the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculate the layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.FindIsolatedGraphComponents(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Determines which nodes will belong to the same graph component.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator">
      <summary>
            This subclass of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator"></see>
            does not
            only allow custom insets for each group node, but also makes sure to keep provided minimum
            sizes registered for each node that are provided through a DataProvider which must be
            registered with the graph prior to the invocation of the layout algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.#ctor">
      <summary>
            Constructs an instance that uses the minimum size provided through the data provider registered at the input
            graph with the public key
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.#ctor(System.Object)">
      <summary>Constructs an instance using the given DataProvider key.</summary>
      <param name="minSizeDataProviderKey">
            a DataProvider key that is used to get the minium sizes
            for the nodes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList)">
      <summary>This method is called during the layout process.</summary>
      <param name="graph">the graph instance for which the bounds will be calculated</param>
      <param name="groupNode">the group node whose bounds will be calculated</param>
      <param name="children">a list of nodes which reside inside the group node</param>
      <returns>a Rectangle2D instance that describes the bounds of the group node.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.DefaultMinimumNodeSize">
      <summary>The default minimum size for nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDPKey">
      <summary>The DataProvider key that is used to get the minium sizes for the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.XAlignment">
      <summary>
            A value that describes how the node will be resized horizontally if the calculated width
            of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator"></see>
            is smaller than
            the minimal width that is provided for the node.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.YAlignment">
      <summary>
            A value that describes how the node will be resized vertically if the calculated height
            of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator"></see>
            is smaller than
            the minimal height that is provided for the node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage">
      <summary>
            This class can be used as a decorating stage for layout algorithms that
            cannot handle node groups.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage.#ctor">
      <summary>Creates a new instance of ParentEdgeAugmentationStage</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns true if the core layouter can layout the augmented graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter">
      <summary>
            Recursively traverses a hierarchically organized graph in a bottom-up fashion
            and applies the given layout algorithm (i.e.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.#ctor">
      <summary>Creates a new instance of RecursiveGroupLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of RecursiveGroupLayouter using the given layout
            algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.#ctor(yWorks.yFiles.Layout.ILayouter,yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator)">
      <summary>
            Creates a new instance of RecursiveGroupLayouter using the given layout
            algorithm and GroupBoundsCalculator implementation.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.GroupBoundsCalculator">
      <summary>The currently installed GroupBoundsCalculator instance.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer">
      <summary>Abstract base class for the third phase of the Sugiyama algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Binds the specified graph to this drawer and
            calls the abstract method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)"></see></summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignYCoords(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor[])">
      <summary>
            Assign the y coordinates to the nodes respecting the minimal
            layer distance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignYCoords(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>
            Assign the y coordinates to the nodes respecting the minimal
            layer distance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.Dispose">
      <summary>Frees allocated resources after the drawwer is finished.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.distanceToNextNode">
      <summary>
            Stores the minimal distance between the right border of a node and
            the left border of its right hand side neighbor in a layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.dummyMap">
      <summary>
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.DummyMap"></see></summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.edgeLengthKey">
      <summary>The key to the data provider, which stores the length of the edges.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.EdgeLengthKey">
      <summary>The key to the data provider, which stores the length of the edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetBottomBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the bottom border of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetBottomHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the border-obeying bottom half of the node,</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetBottomY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying bottom y-coordinate of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetDistanceToNextNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the minimal distance between the right border of the given node and
            the left border of its right hand side neighbor in the layer.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetFullHeight(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying full height of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetFullWidth(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying full width of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetLeftBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the left border of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetLeftHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the border-obeying left half of the node,</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetLeftX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying left x-coordinate of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetRightBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the right border of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetRightHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the border-obeying right half of the node,</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetRightX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying right x-coordinate of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetTopBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the top border of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetTopHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the border-obeying top half of the node,</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetTopY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying top y-coordinate of the given node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.graph">
      <summary>The graph bound to this drawer instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.InitializeDistancesToNextNode(yWorks.yFiles.Algorithms.NodeList[])">
      <summary>
            Initializes the minimal distances between the right border of a node
            and the left border of its right hand side neighbor in a layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target in the same layer.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase">
      <summary>Constant describing the first phase of the HierarchicLayouter algorithm.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase.Layering">
      <summary>Constant describing the first phase of the HierarchicLayouter algorithm.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase.Sequencing">
      <summary>Constant describing the second phase of the HierarchicLayouter algorithm.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer">
      <summary>This class can be used to simply wrap another Drawer implementation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.#ctor(yWorks.yFiles.Layout.Hierarchic.IDrawer)">
      <summary>Creates a new AlignmentDrawer using the given drawer as the actual drawer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.AlignNodes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Modifies the given drawing by modifying the y-coordinates only</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multiedges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.NodeAlignmentPointDpKey">
      <summary>
            The DataProvider key used for the DataProvider instance that provides for
            each node a double depicting the center anchored offset to the
            alignment point.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer">
      <summary>
            This layerer implementation assigns layers by analyzing already existing
            node coordinates.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.<br></br></summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.GetMax(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback used to calculate the lower (max) value of a node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.GetMin(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback used to calculate the upper (min) value of a node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.MaximumNodeSize">
      <summary>The maximum size of a node that is used to calculate layer overlaps.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.MinimumNodeSize">
      <summary>The minimum size of a node that is used to calculate layer overlaps.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.NodeHalo">
      <summary>
            The size of the halo around a node or the insets respectively that are
            used to calculate layer overlaps.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor">
      <summary>The scaling factor that is used to scale the nodes' height.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.BFSLayerer">
      <summary>Layerer that uses a breadth first search to assign layers to the nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.BFSLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="graph">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey">
      <summary>
            The data provider key used to look up the core nodes
            of the bfs layering.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer">
      <summary>This class implements the second phase of the Sugiyama algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.#ctor">
      <summary>Instantiates a new layer sequencer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.AdoptValues(yWorks.yFiles.Layout.Hierarchic.ILayerSequencer)">
      <summary>Tries to adopt/copy the settings of the given LayerSequencer to this sequencer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.GetLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Calculates the sequence of nodes within each layer.</summary>
      <param name="g">the graph being acted upon</param>
      <param name="layerID">
            provides for each node an integral number signifying the layer
            of that node. The first layer has the number 0.
            </param>
      <param name="maxLayer">the number of different layers</param>
      <returns>
            an array of length maxLayer containing node lists. Each node list
            contains the nodes of a corresponding layer. The order of the nodes
            within each node list represents the sequence of the nodes within their layer.
            </returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.GroupDpKey">
      <summary>
            This is the key, which must be used to register the DataProvider
            which contains the mappings between nodes and group ids.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.MaximalDuration">
      <summary>The proposed maximal duration for the calculation of the sequence.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.RandomizationRounds">
      <summary>
            The number of randomized rounds this algorithm will try
            if there was no optimal solution.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.RecentCrossingNumber">
      <summary>
            The number of edge crossings that were
            produced by this sequencer the last time it was
            applied to a graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.RemoveFalseCrossings">
      <summary>Specifies whether or not to remove false crossings.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.UseTransposition">
      <summary>
            Specifies whether or not the transposition heuristic should
            be used.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.UsingGroups">
      <summary>
            Specifies whether or not the layerer will preserve the groupings of
            nodes between each layer.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.WeightHeuristic">
      <summary>The currently set weight heuristic.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer">
      <summary>Layerer implementation that uses relative and absolute layering constraints.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.ILayerer)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.AllowSameLayerEdges">
      <summary>Specifies whether same layer edges can be created by this layerer instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <exception cref="T:System.ArgumentException">if any strong constraints are inconsistent</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CheckConstraints">
      <summary>Checks if the current set of strong constraints is consistent (i.e.</summary>
      <exception cref="T:System.ArgumentException">if the constraint network is inconsistent</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CoreLayerer">
      <summary>The core layerer for this layerer instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CreateConstraintFactory(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Create an instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory"></see>
            that is suitable for this
            layerer implementation.
            </summary>
      <param name="g">the current graph for the layerer</param>
      <returns>a ContraintFactory bound to this graph.</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.EdgeWeightsDpKey">
      <summary>DataProvider key for additional edge weights of type <c>int</c>.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.LayerConstraintsMementoDpKey">
      <summary>
        <c>DataProvider</c> key to store the constraints.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory">
      <summary>
            Interface specification for classes that can create suitable constraints for a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer"></see>
            instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object)">
      <summary>Add a constraint that forces the node <c>above</c> to lie above the node <c>reference</c>.</summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>above</c> to lie at least <c>minDistance</c> layers above
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
            Add a constraint that forces the node  with id <c>above</c> to lie at least <c>minDistance</c> layers above
            the node  with id <c>reference</c> with a given weight penalty for larger  layer differences.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAtBottomConstraint(System.Object)">
      <summary>Add a constraint that places a node in the bottom layer</summary>
      <param name="nodeId">the id of the node that should lie at the bottom</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAtTopConstraint(System.Object)">
      <summary>Add a constraint that places a node in the topmost layer</summary>
      <param name="nodeId">the id of the node that should lie at the top</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object)">
      <summary>Add a constraint that forces the node with id with id <c>below</c> to lie below the node with id <c>reference</c>.</summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers below
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers below
            the node with id <c>reference</c> with a given weight penalty for larger layer differences.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeInSameLayerConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>sameLayer</c> to lie in the same layer as the node with id
            <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="sameLayerId">the id of the node that should lie in the same layer</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.Dispose">
      <summary>Disposes the ConstraintFactory.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.Memento">
      <summary>A token that allows to bind a constraint factory to a graph instance after creation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.RemoveConstraints(System.Object)">
      <summary>Clears all constraints for a given node</summary>
      <param name="nodeId">the id of the node for which all constraints should be cleared</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.DrawerKeys"></member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderBottom">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderLeft">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderRight">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderTop">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeDistance">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.EdgeReverser">
      <summary>Helper that reverses edges that are oriented in the wrong direction.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.EdgeReverser.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.EdgeReverser" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.EdgeReverser.ReverseEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Reverses the edges contained ion the given edge list</summary>
      <param name="g">the graph containing the edges in edgeList</param>
      <param name="edgeList">contains to be reversed edges.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.EdgeReverser.ReverseUpwardEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Reverses edges in the given graph whose source node has a
            larger layer ID than the target node.
            </summary>
      <param name="g">target graph</param>
      <param name="layerMap">node map that contains a layer ID for each node</param>
      <returns>a list of edges that have been reversed</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer">
      <summary>This layerer implementation layers the nodes by given layer IDs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            Assigns layers to the graph that were given by the
            DataProvider <c>g.getDataProvider(LAYER_ID_KEY)</c>.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.LayerIdDpKey">
      <summary>
            The key used by this class to query a graph for a
            DataProvider that yields the layerID for each node in the
            graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>Convenience method which removes empty layers and ensures that the smallest layer has value 0.</summary>
      <param name="layerId">provides the current layer ids for nodes in <c>g</c></param>
      <param name="normalizedLayerId">accepts the new layer ids that result after normalization.</param>
      <returns>The amount of layers left after removing all empty layers.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy">
      <summary>Group layering alignment strategy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Top">
      <summary>
            Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
            the same layer are top aligned with respect to their inner layers.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Center">
      <summary>
            Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
            the same layer are center aligned with respect to their inner layers.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Bottom">
      <summary>
            Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
            the same layer are bottom aligned with respect to their inner layers.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter">
      <summary>This class is an extended variant of the HierarchicLayouter class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.#ctor">
      <summary>Creates a new instance of HierarchicGroupLayouter</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see>..</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Layouts the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.Drawer">
      <summary>The drawer which is responsible for the third phase of the algorithm</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.GetLayerSequence(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Determines the order of the nodes within their layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.GlobalSequencingActive">
      <summary>The current strategy for the node sequencing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.GroupBoundsCalculator">
      <summary>The current GroupBoundsCalculator instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.Grouping">
      <summary>The associated <c>Grouping</c> instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.Layerer">
      <summary>
            The <c>Layerer</c>, which is responsible for the first phase
            of the algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayeringStrategy">
      <summary>The currently set layering strategy.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayerSequencer">
      <summary>
            The <c>LayerSequencer</c>, which is responsible for the second phase
            of the algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayoutLevel(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList,System.Boolean)">
      <summary>Layouts the children of root recursively.</summary>
      <param name="root">The current root node (parent, invisible during layout)</param>
      <param name="levelNodes">The nodes to be laid out</param>
      <returns>the bounding box of the layout</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayoutStyle">
      <summary>
            The currently set layout style or <c>-1</c>
            if the style cannot be
            determined
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.StrongPortsScalingActive">
      <summary>The property strongPortsScalingActive.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter">
      <summary>
            This class implements a layout algorithm for drawing directed graphs
            in a hierarchic way.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.#ctor">
      <summary>Instantiates a new HierarchicLayouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.BendReductionThreshold">
      <summary>
            The limit, when bends are removed and a straight line is drawn
            instead.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns true.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.DisposeMementoSupport">
      <summary>Disposes the memento support if it is existent, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Layout the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.Drawer">
      <summary>
            The <c>Drawer</c>, which is responsible for the third phase of
            the algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.GetLayerSequence(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Determines the order of the nodes within their layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.Layerer">
      <summary>
            The <c>Layerer</c>, which is responsible for the first phase
            of the algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayeringStrategy">
      <summary>The currently set layering strategy.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayerSequencer">
      <summary>
            The <c>LayerSequencer</c>, which is responsible for the second phase
            of the algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayoutStyle">
      <summary>
            The currently set layout style or <c>-1</c>
            if the style cannot be
            determined
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MaximalDuration">
      <summary>A time limit for the algorithm in milliseconds</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MementoSupport">
      <summary>The cookie for the memento support of the hierarchic layout algorithm.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalEdgeDistance">
      <summary>The minimal distance between edges that run in parallel.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalFirstSegmentLength">
      <summary>
            The minimal length of first and last edge segments
            for edge routing.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.OptimizePortConstraints">
      <summary>
            Specifies whether the algorithm tries to optimize PortConstraints,
            that are either
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any"></see>
            or <see langword="null"></see>.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.OptimizeSameLayerEdgeRouting">
      <summary>
            Specifies whether the algorithm tries to optimize the routing of
            same layer edges whose PortConstraints don't impose the routing.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.RemoveFalseCrossings">
      <summary>Specifies whether or not false crossings should be removed from the layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.RoutingStyle">
      <summary>The routing style being used.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.IDrawer">
      <summary>Interface for the third phase of the Sugiyama algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multiedges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ILayerer">
      <summary>This is the interface to the node layering  phase of the hierarchic layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ILayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.<br></br></summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ILayerSequencer">
      <summary>
            Classes implementing this interface calculate the order of nodes within
            the different layers that the graph has been partitioned.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ILayerSequencer.GetLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Calculates the sequence of nodes within each layer.</summary>
      <param name="g">the graph being acted upon</param>
      <param name="layerID">
            provides for each node an integral number signifying the layer
            of that node. The first layer has the number 0.
            </param>
      <param name="maxLayer">the number of different layers</param>
      <returns>
            an array of length maxLayer containing node lists. Each node list
            contains the nodes of a corresponding layer. The order of the nodes
            within each node list represents the sequence of the nodes within their layer.
            </returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.IMementoSupport">
      <summary>This interface is a Cookie for the HierarchicLayouter's memento support.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.CreateMemento">
      <summary>
            Creates a memento which can be held by the user, before using the support,
            a valid memento Object has to be set using the corresponding setter method.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.GetMementoMode(yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase)">
      <summary>
            Retrieves the current mode previously set by setMementoMode(byte, boolean)
            for the given phase of the algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.Memento">
      <summary>The currently active memento Object</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.SetMementoMode(yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase,System.Boolean)">
      <summary>Sets the mode for each phase of the algorithm.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter">
      <summary>
            This class is a variant of the classic
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter"></see>
            implementation.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.#ctor">
      <summary>
            Creates a new IncrementalHierarchicLayouter instance which is
            set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch"></see>
            initially
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Determines whether this layouter can perform the core layout on the given
            graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CompactGroups">
      <summary>Specifies whether layer compaction for recursive group layering is active.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ConfigureCoreLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter)">
      <summary>Called before the actual layout is performed.</summary>
      <param name="graph">the graph to be laid out</param>
      <param name="ihl">the instance used for the core layout.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating
            node positions (thereby preventing possible node/node label or
            node label/node label overlaps).
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator"></see>
            .
            </exception>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator"></see>
            .
            </exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateEdgeLayoutDescriptor">
      <summary>Factory method that creates the default EdgeLayoutDescriptor.</summary>
      <returns>a new EdgeLayoutDescriptor (<c>new EdgeLayoutDescriptor()</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateHierarchicLayouter">
      <summary>
            Factory method that creates the internally used
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            instance.
            </summary>
      <returns>
        <c>new y.layout.hierarchic.incremental.HierarchicLayouter()</c>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateIncrementalHintsFactory">
      <summary>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory"></see>
            instance that must be used
            to obtain marks that can be associated with elements in the graph that
            will be laid out incrementally.
            </summary>
      <returns>the factory</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateNodeLayoutDescriptor">
      <summary>Factory method that creates the default NodeLayoutDescriptor.</summary>
      <returns>a new NodeLayoutDescriptor (<c>new NodeLayoutDescriptor()</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateSequenceConstraintFactory(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory"></see>
            instance that can be used to specify sequence constraints for the given
            graph.
            </summary>
      <param name="graph">
      </param>
      <returns>A SequenceConstraintFactory instance for use with the given graph.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.DefaultDrawingDistanceCalculator">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator"></see>
            that is registered
            with the layout algorithm by default.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current instance returned
            by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DrawingDistanceCalculator"></see>
            is not an instance of <c>DefaultDrawingDistanceCalculator</c>.
            </exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Performs the actual layout using the currently set mode.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.EdgeLayoutDescriptor">
      <summary>
            The <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.EdgeToEdgeDistance">
      <summary>The minimum distance between two adjacent edges in one layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FixedElementsLayerer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer"></see>
            instance that is used to obtain the layering
            for those nodes that are not marked to be laid out incrementally
            if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental"></see>
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FixedElementsSequencer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer"></see>
            instance that is used to calculated the sequence
            of the nodes that are not marked to be laid out incrementally
            if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental"></see>
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayerer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer"></see>
            instance that is used to obtain the layering
            for the nodes if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch"></see>
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayeringStrategy">
      <summary>
            The currently set layering strategy for the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayerer">from scratch</see>
            layering.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchSequencer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer"></see>
            instance that is used to calculate the node
            sequence if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch"></see>
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.GroupAlignmentPolicy">
      <summary>The group layer alignment strategy used for recursive group layering.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.HierarchicLayouter">
      <summary>
            The internally used
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            instance.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IncrementalHintsDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to store incremental layout hints
            that can be retrieved from the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory"></see>
            which itself can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateIncrementalHintsFactory"></see>
            method.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator"></see>
            .
            </exception>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator"></see>
            .
            </exception>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayerValueHolderDpkey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder"></see>
            for each node in the graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode">
      <summary>The layout mode this layouter is currently in.</summary>
      <exception cref="T:System.ArgumentException">if the mode is unknown</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.MinimumLayerDistance">
      <summary>The minimum distance between two adjacent layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeLayoutDescriptor">
      <summary>
            The <c>NodeLayoutDescriptor</c> instance used for all those
            nodes, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodePlacer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer"></see>
            instance that will be used to calculated the
            final node placement of the layout.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeToEdgeDistance">
      <summary>The minimum distance between two adjacent nodes in one layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeToNodeDistance">
      <summary>The minimum distance between two adjacent nodes in one layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.RecursiveGroupLayering">
      <summary>Specifies whether groups are respected during the layering stage.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SequenceConstraintsMementoDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see> key to store the constraint graph for sequence constraints.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SwimlaneDescriptorDpkey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor"></see>
            instances for each node in the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.UnconfigureCoreLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter)">
      <summary>Called after the actual layout is performed.</summary>
      <param name="graph">the graph to be laid out</param>
      <param name="ihl">the instance used for the core layout.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy">
      <summary>Layering strategy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTopmost">
      <summary>
            Layering strategy specifier. A simple hierarchical layering variant.
            All nodes with indegree zero will be assigned to the topmost layer of the layout.
            The number of separate layers will be as small as possible.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal">
      <summary>
            Layering strategy specifier. An optimal hierarchical layering strategy.
            The layer distance of an edge is the absolute difference between the layer numbers
            of its source and target node.
            Layer assignment will be done in such a way that the overall sum of the layer distances
            of all edges in the layout is minimal.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTightTree">
      <summary>
            Layering strategy specifier.  A heuristic that approximates the ranking done by
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalDownshift">
      <summary>
            Layering strategy specifier. A fast heuristic that improves the
            the ranking done by
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTopmost"></see>
            by down shifting
            some nodes in the layering. The quality is usually worse than the
            one produced by <i>Tight Tree Heuristic</i>.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.Bfs">
      <summary>
            Layering strategy specifier.
            Layering based on a breadth first search (bfs).
            All edges will span at most one layer in
            the resulting drawing. Edges between nodes that belong to the same layer are possible.
            The nodes that will be placed in the first layer can be provided by a
            data provider bound to the input graph using the key
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey"></see>
            .
            If this data provider is not given, then nodes that have no incoming edges are placed
            in the first layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.FromSketch">
      <summary>
            Layering strategy specifier. A layer assignment strategy
            that uses the initial y-coordinates of the nodes
            (x-coordinates when the layout orientation is horizontal)
            to determine a node layering. It tries to find a layering that is similar to the
            one in the input graph. When this layering strategy is used, the layouter
            may place nodes in the same layer, even though they are connected by an edge.
            These inner layer edges are always routed in an orthogonal style.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.UserDefined">
      <summary>
            Layering strategy specifier. The ranks of the nodes will be given by the user.
            The node ranks must be provided by a data provider bound to the input graph
            using the key
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.LayerIdDpKey"></see>
            . Like
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.FromSketch"></see>
            this layering allows inner layer edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.Unknown">
      <summary>
            Dummy layering strategy specifier. Returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayeringStrategy"></see>
            if the current strategy
            is not known.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LayoutMode">
      <summary>
            Layout mode constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental">
      <summary>
            Layout mode constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode"></see>
            .
            This constant sets the layout algorithm to incremental mode, i.e.
            fixed elements will be handled by the <c>fixedElementsSequencer</c>
            and <c>fixedElementsLayerer</c> and elements marked for incremental
            layout will be added to the drawing later.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch">
      <summary>
            Layout mode constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode"></see>
            .
            This constant sets the layout algorithm to "from scratch mode", i.e.
            the algorithm will recompute the layout from scratch.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LayoutStyle">
      <summary>Layout style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Pendulum">
      <summary>
            Layout style specifier. Draws the edges in a way
            that nodes are balanced nicely and the number
            of bends on an edge is kept small.
            <p></p>
            Note that this layout style is more time consuming than most of the
            other ones.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.LinearSegments">
      <summary>
            Layout style specifier. Draws the edges in a way
            that at most two bends are used per edge unless two edges cross.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Polyline">
      <summary>
            Layout style specifier. Draws the edges in a polyline
            fashion. The layout tends to be very compact but the
            number of edge bends may be high.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Tree">
      <summary>
            Layout style specifier. Gives nice layouts if the
            graph is a tree.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Simplex">
      <summary>Layout style specifier. Gives tight layouts with rather few bends.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.MedianSimplex">
      <summary>
            Layout style specifier. Similar to SIMPLEX but more symmetric for the cost
            of a few more bends.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer">
      <summary>Still experimental.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.<br></br></summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList,System.Boolean)"></member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.PreferredLayerWidth"></member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.StartFromSketch"></member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.UseEnhancedDistribution"></member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer">
      <summary>This class implements the third phase of the Sugiyama layout algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper">
      <summary>This class can be used to improve the results of different drawers.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.#ctor(yWorks.yFiles.Layout.Hierarchic.IDrawer)">
      <summary>
            Creates a new instance of MedianDrawerWrapper using the delegate to
            perform the core work.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.Delegate">
      <summary>The drawer to which the actual drawing will be delegated.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.drawerDelegate">
      <summary>the delegate</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.dummy">
      <summary>the dummyMap</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multiedges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.Postprocess(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Called as a hook after the actual drawing is performed by the delegate</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.Preprocess(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Called as a hook before the actual drawing is performed by the delegate</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer">
      <summary>This class implements the third phase of the hierarchic layout algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Performs coordinate assignment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.Dispose">
      <summary>Frees held resources.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.HorizontalCompaction(yWorks.yFiles.Layout.LayoutGraph,System.Double[],yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Calculate coordinates.</summary>
      <param name="g">the graph for which the layout is calculated.</param>
      <param name="x">the array where the result is stored.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.Init(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Initializes data structures for all runs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.MarkConflicts(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap,System.Int32[])">
      <summary>Mark type 1 conflicts.</summary>
      <param name="layerLists">the list of layers.</param>
      <param name="conflictMark">used to mark the conflicting edges.</param>
      <param name="dummyMap">
            map which returns <see langword="true"></see> for bends,
            <see langword="false"></see> otherwise.
            </param>
      <param name="pos">
            is indexed by the index method of node and returns the rank of
            a node inside the layer which contains the node.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.PropagateCoordinates(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Writes the calculated x values in the layout graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.Reinit(yWorks.yFiles.Algorithms.Graph,System.Double[])">
      <summary>Initializes data structures for one basic step.</summary>
      <param name="x">the array where the coordinates will be stored.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.VerticalAlignment(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Calculates vertical alignment.</summary>
      <param name="g">the graph for which the layout is calculated.</param>
      <param name="layerLists">the list of layers.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer">
      <summary>
            This class can be used to wrap
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IDrawer"></see>
            implementations.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.#ctor(yWorks.yFiles.Layout.Hierarchic.IDrawer)">
      <summary>Creates a new instance of NodeLabelSpaceDrawer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.GetHaloSpace(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>Calculates the horizontal space requirements for the given node.</summary>
      <param name="node">The node to calculate the halo for.</param>
      <param name="left">Whether to calculate the left (<see langword="true"></see>) or right (<see langword="false"></see>) halo.</param>
      <returns>The additional space needed by the given node at the given side.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multiedges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.PendularDrawer">
      <summary>
            This class implements the third phase of the Sugiyama layout algorithm
            as described in "Visualisierungstechniken fuer den Compilerbau" (Georg Sander)
            mixed with techniques as described in "A technique for drawing directed graphs"
            (Gansner et al).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.#ctor">
      <summary>empty constructor, does nothing</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This is the main loop of this layout algorithm.</summary>
      <param name="layerLists">
            a list of all the nodes for each layer, to determine
            their relative positions
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.DisposeStructures">
      <summary>
            Cleans up previously allocated structures, that were constructed by a call to
            <c>initStructures</c></summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.FindChains">
      <summary>Finds chains of nodes, i.e.</summary>
      <returns>a list of NodeLists containing each more than 1 nodes</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetEdgeWeight(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns a non-negative value for each Edge e.</summary>
      <param name="e">the edge</param>
      <returns>a non-negative value</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetMaximumExtent(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Calculates the highest or lowest x-coordinate the Node n can be assigned to, without breaking
            the constraints.
            </summary>
      <param name="n">the node</param>
      <param name="toLeft">
        <see langword="true">
        </see> if the minimum x-coordinate shall be calculated;
            <see langword="false"></see> for the maximum x-coordinate
            </param>
      <returns>the maximum/minimum extent of the node's center x-coordinate</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetMinimalLayerDistance(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Returns the minimum distance between two Nodes on the same layer according to
            getMinimalNodeDistance(), getMinimalEdgeDistance() and getMinimalMultiEdgeDistance().
            </summary>
      <param name="n">the node</param>
      <param name="toLeft">
        <see langword="true">
        </see> if the minimum x-coordinate shall be calculated;
            <see langword="false"></see> for the maximum x-coordinate
            </param>
      <returns>the maximum/minimum extent of the node's center x-coordinate</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetPendulumForce(yWorks.yFiles.Algorithms.ICursor,System.Int32)">
      <summary>Helper method which calculates the force acting on all nodes given by the cursor.</summary>
      <param name="cursor">the nodes for which the force will be calculated</param>
      <param name="direction">
            -1 if nodes in higher layers should be used to calculate the forces, 1 if nodes
            in lower layers should be used, 0 if both surrounding layers should be used
            </param>
      <returns>
            a force, i.e. a signed value, which, if applied to the nodes in cursor, would minimize
            the force acting on them.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetPendulumForce(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>
            Helper method which calculates the force that all nodes given by
            EdgeCursor apply to v.
            </summary>
      <param name="v">the node for which the force will be calculated</param>
      <param name="ec">
            the EdgeCursor which determines which edges should be
            considered in the calculation
            </param>
      <returns>
            a force, i.e. a signed value, which (if added to the x-coordinate
            of v) would minimize the force on v if applied.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetZ">
      <summary>Calculates the value of the function this algorithm should minimize.</summary>
      <returns>a positive value.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.InitializePositions(yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Helper method which initializes the positions of the nodes in all layers.</summary>
      <param name="layerList">an array of NodeLists each corresponding to a single layer</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.InitStructures">
      <summary>
            used to initialize internal structures such as <c>NodeMap right</c> and
            <c>NodeMap left</c><c>bendGridWidth</c> and <c>nodeGridWidth</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.IsSegmentNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Helper method that determines whether a node is a so-called segment node.</summary>
      <param name="n">the Node</param>
      <returns>
        <see langword="true">
        </see> iff (inDegree == 1 &amp;&amp; outDegree &lt; 2) ||
            (outDegree == 1 &amp;&amp; inDegree &lt; 2)
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.LayoutGraph"></member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.left">
      <summary>map that maps the left node for each node in a layer or <see langword="null"></see> if it is the leftmost</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.MinNode">
      <summary>Performs the minNode phase.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.MinPath(yWorks.yFiles.Algorithms.YList)">
      <summary>Performs the minPath phase.</summary>
      <param name="segments">a list of NodeList each containing a chain of nodes</param>
      <returns>
        <see langword="true">
        </see> iff there was a change in any coordinate of the graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.Move(yWorks.yFiles.Algorithms.ICursor,System.Double)">
      <summary>Helper method which moves the nodes provided by the Cursor nodes by the given amount.</summary>
      <param name="nodes">the nodes</param>
      <param name="distance">the distance that shall be added to the nodes x-coordinate</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.Move(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>
            Helper method which moves a given node by a given amount
            if the useGrid is set to true, this method will snap the new node position to the
            appropriate grid, i.e.
            </summary>
      <param name="n">the node</param>
      <param name="distance">the distance that shall be added to the nodes x-coordinate</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.PartitionLayer(yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>
            Partitions a layer given by its NodeList by calculating the forces
            according to the given direction.
            </summary>
      <param name="layer">the layer which shall be partitioned</param>
      <param name="direction">
            -1 if nodes in higher layers should be used to calculate
            the forces, 1 if nodes in lower layers
            should be used, 0 if both surrounding layers should be used
            </param>
      <returns>
            a list of NodeLists each containing adjacent nodes in that layer,
            which can be treated as a single unit when moving
            </returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.right">
      <summary>map that maps the right node for each node in a layer or <see langword="null"></see> if it is the rightmost</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.ShakePartition(yWorks.yFiles.Algorithms.YList,System.Int32)">
      <summary>Shakes a given partition of a Layer, i.e.</summary>
      <param name="partition">
            a List of NodeLists each containing at least one node
            belonging to a single layer
            </param>
      <param name="direction">
            -1 if nodes in higher layers should be used to calculate
            the forces, 1 if nodes in lower layers should be used, 0 if both
            surrounding layers should be used
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.StraightenPath(yWorks.yFiles.Algorithms.ListCell,yWorks.yFiles.Algorithms.ListCell,System.Double[])">
      <summary>Helper method for use in <c>minPath</c>.</summary>
      <param name="firstCell">
            this determines the first Node in a NodeList
            which should be assigned a new x-coordinate
            </param>
      <param name="lastCell">
            this determines the last Node in a NodeList
            (which must be same List as the one for firstCell) which should
            be assigned a new x-coordinate
            </param>
      <param name="range">
            an interval providing information of the legal range,
            the Nodes x-coordinates could be set to.
            The values can can be smaller than (-Double.MAX_VALUE) for the left
            border and greater than Double.MAX_VALUE for the right one
            </param>
      <returns>
        <see langword="true">
        </see> iff this method has done any change to the graphs
            coordinates
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.Touches(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Helper method which checks whether two adjacent nodes on a layer touch
            each other, i.e.
            </summary>
      <param name="v1">one node</param>
      <param name="v2">another node</param>
      <returns>
        <see langword="true">
        </see> iff their distance is smaller than
            getMinimalLayerDistance+EPSILON
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.VerifyMovement(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Assures that if distance was applied to the n's x-coordinate no given constraint gets broken.</summary>
      <param name="n">the node to be moved</param>
      <param name="distance">the distance which shall be verified</param>
      <returns>the distance which can be applied to n without breaking any constraint</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer">
      <summary>
            This class is an implementation of the third phase of the
            Sugiyama algorithm, which represents edges by  polylines.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.PortAssignment">
      <summary>This class assigns port coordinates to the edges of a graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PortAssignment.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.PortAssignment" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,System.Collections.IComparer,System.Collections.IComparer)">
      <summary>Assigns port coordinates to the edges.</summary>
      <param name="g">graph whose edges need port assignment</param>
      <param name="dummyMark">
            provides boolean data about whether a node
            is a dummy node or not.
            </param>
      <param name="inComp">A Comparator that defines an ordering for edges. This comparator is used for ordering the edges entering a node.</param>
      <param name="outComp">A Comparator that defines an ordering for edges. This comparator is used for ordering the edges leaving a node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Assigns port coordinates to the edges.</summary>
      <param name="g">graph whose edges need port assignment</param>
      <param name="layers">the layering of g</param>
      <param name="dummyMark">
            provides boolean data about whether a node
            is a dummy node or not.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.RankingPolicy">
      <summary>Ranking policy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.NoReranking">
      <summary>
            Ranking policy specifier. Nodes do not get re-ranked after
            the initial topological layering step.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.DownShift">
      <summary>
            Ranking policy specifier. Nodes get re-ranked by an
            inexpensive downshift rule.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.TightTree">
      <summary>
            Ranking policy specifier. Nodes get re-ranked by
            finding a spanning tree that contains only tight
            (length 1) edges.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.RoutingStyle">
      <summary>Edge routing style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Polyline">
      <summary>Edge routing style specifier. Routes the edges as polylines.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Orthogonal">
      <summary>
            Edge routing style specifier. Routes the edges orthogonally, i.e.
            all edge segments are either vertically or horizontally aligned.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer">
      <summary>Drawer based on rank-assignment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Assigns the coordinates to the nodes based on simplex-rank assignment.</summary>
      <param name="layerLists">The nodes in each layer.</param>
      <param name="layerID">Provides the layer ID for nodes.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.GetCost(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Returns the overall edge cost of the result.</summary>
      <param name="result">The result to calculate the cost for.</param>
      <param name="weight">Provides the edge weights.</param>
      <param name="minLength">Provides the min length for edges.</param>
      <returns>The total cost given the parameters.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.IsDummy(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether the given node is a dummy node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.StraighteningFactor">
      <summary>The straightening factor.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer">
      <summary>This class implements the first phase of the Sugiyama algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.RankingPolicy">
      <summary>
            The currently active ranking policy within
            this layerer.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.TreeDrawer">
      <summary>This class implements the third phase of the hierarchic layout algorithm for trees.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.TreeDrawer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.AlternativeDrawer">
      <summary>The drawer, which is called when graph is not a tree.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer">
      <summary>
            places nodes in their given layers (does not change the y coordinates) for the TREE layout style of a
            HierarchicLayouter.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer.#ctor(System.Double)">
      <summary>creates a new HierarchicTreePlacer.</summary>
      <param name="minimalNodeDistance">the minimal allowed distance between two nodes in the same layer</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer">
      <summary>This class implements the first phase of the hierarchic layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.#ctor">
      <summary>Creates a new weighted layerer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.#ctor(System.Object)">
      <summary>Creates a new weighted layerer.</summary>
      <param name="k">the key to access the weights.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Assigns the layers to the nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignLayersFast(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Assign the layers to the nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.DownShiftNodes(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Pushes the nodes down, drawings seems then to be nicer.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.key">
      <summary>The key to access the weights.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.MakeDFSAcyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Uses dfs to remove cycles from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.MakeDFSAcyclic(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Uses dfs to remove cycles from the graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.weight">
      <summary>Provides the edge weights.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic">
      <summary>Weight assignment heuristic specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic.Barycenter">
      <summary>
            Weight assignment heuristic specifier. A node position within a layer
            will be determined by the barycenter of its
            successor (downward pass) and  predecessor (upward pass) nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic.Median">
      <summary>
            Weight assignment heuristic specifier. A node position within a layer
            will be determined by the median position of its
            successor (downward pass) and  predecessor (upward pass) nodes.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AsIsSequencer">
      <summary>
            Sequencer implementation that returns a sequencing that
            corresponds to the current drawing.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AsIsSequencer.#ctor">
      <summary>Creates a new AsIsSequencer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AsIsSequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator">
      <summary>
            A default
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator"></see>
            implementation that is used
            by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            to configure the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.#ctor">
      <summary>
            Creates a new instance of DefaultDrawingDistanceCalculator
            with default settings.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Dispose(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to dispose internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that was used</param>
      <param name="ldp">the LayoutDataProvider that was used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Edge2EdgeDistance">
      <summary>The minimum distance between two edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Main interface method.</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer object that contains the nodes</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="left">
            the left one of the two nodes whose
            minimum distance is to be determined or <see langword="null"></see> if only the left border of the right node is
            of interest.
            </param>
      <param name="right">
            the right one of the two nodes whose
            minimum distance is to be determined or <see langword="null"></see> if only the right border of the left node is
            of interest.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Initialize(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to initialize internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that will be used during subsequent calls</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Node2EdgeDistance">
      <summary>The minimum distance between a node and an (non-adjacent) edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Node2NodeDistance">
      <summary>The minimum distance between two nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.OptimizeSwimLaneDistances">
      <summary>
            Specifies whether the optimized minimum distance calculation for swim lane layouts
            is enabled.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger">
      <summary>
            A default implementation of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger"></see>
            that provides
            simple default behaviors.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.#ctor">
      <summary>
            Creates a new instance of DefaultLayeredComponentsMerger
            with default policy (
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightTopAligned"></see>
            )
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy)">
      <summary>
            Creates a new instance of DefaultLayeredComponentsMerger
            using the given policy constant.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.Merge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            All nodes in srcLayers and targetLayers are part of graph at the moment of
            invocation.
            </summary>
      <param name="graph">
            the graph that contains the nodes in <c>srcLayers</c> and
            <c>targetLayers</c>.
            </param>
      <param name="ldp">the LayoutDataProvider that can be used to query the layer indices</param>
      <param name="srcLayers">
            the Layers implementation that contains the layers that
            will be merged into <c>targetLayers</c></param>
      <param name="targetLayers">
            the Layers that will be modified to contain the resulting
            layering
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.Policy">
      <summary>The current policy constant.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer">
      <summary>This class implements the second phase of the Sugiyama algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.#ctor">
      <summary>Initializes a new instance of the DefaultLayerSequencer class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.GroupTranspositionEnabled">
      <summary>
            Specifies whether or not the group transposition heuristic should
            be used.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.MaximalDuration">
      <summary>The proposed maximal duration for the calculation of the sequence.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.RandomizationRounds">
      <summary>
            The number of randomized rounds this algorithm will try
            if there was no optimal solution.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.TranspositionEnabled">
      <summary>
            Specifies whether or not the transposition heuristic should
            be used.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.WeightHeuristic">
      <summary>The currently set weight heuristic.</summary>
      <exception cref="T:System.ArgumentException">if the constant is unknown</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator">
      <summary>Default implementation of the PortAllocator interface.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.#ctor">
      <summary>Creates a new instance of DefaultPortAllocator with default settings</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Assigns the port positions for the drawer.</summary>
      <param name="graph">the graph</param>
      <param name="layers">the layering</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="itemFactory">the ItemFactory that can be used for temporarily altering the graph</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.DefaultPortBorderGapRatio">
      <summary>The default port to border gap ratio.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.GetPortBorderGap(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double,System.Int32)">
      <summary>
            Callback method used to determine the port border gap for each node and
            side.
            </summary>
      <param name="graph">the graph</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information from</param>
      <param name="node">the node</param>
      <param name="sideIndex">the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</param>
      <param name="sideLength">the width/height of the side</param>
      <param name="edgeCount">the number of edges/port that connect to this side</param>
      <returns>the absolute gap to be used on both sides of the ports</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.GetPortBorderGapRatio(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double,System.Int32)">
      <summary>Callback method used to determine the port border gap ratio.</summary>
      <param name="graph">the graph</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information from</param>
      <param name="node">the node</param>
      <param name="sideIndex">the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</param>
      <param name="sideLength">the width/height of the side</param>
      <param name="edgeCount">the number of edges/port that connect to this side</param>
      <returns>the ratio</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.GetPortDistanceDelta(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double,System.Int32,System.Double)">
      <summary>Callback method used to determine the distance between two adjacent ports</summary>
      <param name="graph">the graph</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information from</param>
      <param name="node">the node</param>
      <param name="sideIndex">the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</param>
      <param name="sideLength">the width/height of the side</param>
      <param name="edgeCount">the number of edges/port that connect to this side</param>
      <param name="portBorderGap">the previously calculated port border gap</param>
      <returns>the absolute distance to be used between two adjacent ports</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType"></member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.Normal">
      <summary>Describes a normal edge.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.SourceGroupNodeConnector">
      <summary>Describes an edge that connects to a source group node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.TargetGroupNodeConnector">
      <summary>Describes an edge that connects to a target group node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.GroupNodeInterconnector">
      <summary>Describes an edge that connects two group nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.DirectSameLayerEdge">
      <summary>Describes a same layer edge that connects two neighbouring nodes directly.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.NonDirectSameLayerEdge">
      <summary>Describes a same layer edge that connects two neighbouring nodes directly.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.BorderEdge">
      <summary>Describes an edge that connects group border nodes in adjacent layers</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the various
            phases to determine the routing details of the graph's edges.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.#ctor">
      <summary>
            Creates a new instance of an EdgeLayoutDescriptor using the
            default values.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumDistance">
      <summary>The <i>preferred</i> minimum distance of the edge to obstacles.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>The minimum length of the first segment (at the source).</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>The minimum length of the last segment (at the target).</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumLength">
      <summary>
            The minimum length of the edge if the edge does not contain any
            This is used for polyline routing.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumSlope">
      <summary>
            The minimum slope this edge's mid-segments should have if the edge
            is routed polygonal in vertical layouts.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.OrthogonallyRouted">
      <summary>Determines whether this edge should be routed orthogonally.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.SourcePortOptimizationEnabled">
      <summary>Specifies whether source port optimization is enabled, i.e.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.TargetPortOptimizationEnabled">
      <summary>Specifies whether target port optimization is enabled, i.e.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer">
      <summary>
            This LayerSequencer implementation returns a sequencing that satisfies
            a comparator constraint.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.#ctor">
      <summary>Creates a new instance of GivenSequenceSequencer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.#ctor(System.Collections.IComparer)">
      <summary>
            Creates a new instance of GivenSequenceSequencer using the specified
            comparator for the sequencing.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.SequenceComparator">
      <summary>The comparator used by this <c>GivenSequenceSequencer</c>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupCompactionPolicy">
      <summary>
            Compaction strategy specifier for use with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupCompactionPolicy.None">
      <summary>
            Compaction strategy specifier for use with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy"></see>
            .
            This specifies no horizontal group compaction, i.e. group node contents will occupy nearly the same horizontal positions as when not grouped at all.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupCompactionPolicy.Maximal">
      <summary>
            Compaction strategy specifier for use with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy"></see>
            .
            This specifies maximal horizontal group compaction, i.e. the node placer will try to minimimze the horizontally occupied space for a group node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport">
      <summary>Helper class that is used to manage hierarchically grouped graphs.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.Active">
      <summary>Specifies whether or not groupingSupport is active.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.AssignEdgeGroupNodesToGroups(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)"></member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.AssignLabelNodesToGroups(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)"></member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.GetChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the direct children of the given group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.GetDecendants(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns all direct and indirect children of the given group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.GetParentNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the parent group node of the given node, or <see langword="null"></see> if the given node is a top-level node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.HideGroupNodes">
      <summary>Hides the group nodes and adjacent edges from the graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IsDescendant(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is a direct or indirect child of the given group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IsGroupNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is a non-empty group node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.MinimumGroupDistance"></member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.RemoveEdgeGroupAssignment(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)"></member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.UnhideGroupNodes">
      <summary>Unhides all previously hidden group nodes and adjacent edges</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.VisitDecendants(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IVisitor)">
      <summary>Visits all decendants of the given group node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IVisitor">
      <summary>Visitor interface that can be used to traverse the decendants of a group node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IVisitor.Visit(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)"></member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter">
      <summary>This class can be used to create hierarchical layouts of graphs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.#ctor">
      <summary>Creates a new instance of HierarchicLayouter with default settings.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns true.</summary>
      <param name="graph">the graph to check</param>
      <returns>
        <see langword="true">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateDrawingDistanceCalculator">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new DefaultDrawingDistanceCalculator()</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateEdgeReverser">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <returns>an implementation</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateGrouping(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="graph">the graph to obtain the grouping information from.</param>
      <returns>a Grouping or <see langword="null"></see> if there is no grouping information associated with the graph.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalHintsFactory">
      <summary>
            Returns an
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory"></see>
            implementation that can be used to obtain hint objects that can be
            associated with nodes and edges in the graph prior to the invocation of the layout algorithm using an appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            implementation and the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey"></see>
            DataProvider key.
            </summary>
      <returns>an instance that can be used with this layouter instance</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalLayerer">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <returns>an implementation</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateItemData(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="g">the graph to obtain the grouping information from.</param>
      <param name="itemFactory">the ItemFactory to use</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLabelLayouter">
      <summary>
            Factory method for the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            used by this layouter.
            </summary>
      <returns>
            a new <c>LabelLayoutTranslator</c> with node translation enabled
            and "node label write back" disabled.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLayerer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new MultiComponentLayerer(new OldLayererWrapper(new WeightedLayerer()))</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLayers(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="ldp">provides the layout data</param>
      <returns>a Layers implementation</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateNodePlacer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new SimplexNodePlacer</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreatePortAllocator">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new DefaultPortAllocator()</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreatePortConstraintOptimizer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>
        <see langword="null">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSequenceConstraintFactory(yWorks.yFiles.Algorithms.Graph)"></member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSequencer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new DefaultLayerSequencer()</c>)</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSubgraphLayerSequencer">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <returns>a Sequencer implementation that can sequence subgraphs incrementally.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Layouts the given graph.</summary>
      <param name="graph">the graph to layout</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DrawingDistanceCalculator">
      <summary>The current DrawingDistanceCalculator instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.EdgeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor"></see>
            instances for each edge in the graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetAlgorithmProperty(System.Object)">
      <summary>
            Provides access to implementation specific
            properties of the algorithms used.<br></br>
            Used for internal purposes.
            </summary>
      <param name="key">the key to a property</param>
      <returns>the associated value or <see langword="null"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetEdgeLayoutDescriptors(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetIncrementalHints(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetNodeLayoutDescriptors(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetSwimLaneDescriptors(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)"></see>
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null"></see></returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to retrieve incremental layout hint
            objects that have been set using the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory"></see>
            which itself can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalHintsFactory"></see>
            method.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalNodesDpKey">
      <summary>
            DataProvider key used to hold boolean values for each node in the graph that indicate whether
            the node has to be added incrementally.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer">
      <summary>The current Layerer instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.LayerValueHolderDpKey">
      <summary>Used for publishing the final layering information.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor"></see>
            instances for each node in the graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodePlacer">
      <summary>The current NodePlacer instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortAllocator">
      <summary>The current PortAllocator instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortConstraintOptimizer">
      <summary>The current PortConstraintOptimizer instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PublishLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>Callback method that publishes the layering information</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layers">the Layers implementation to get the layering information from</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.ReduceBendCount(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Removes bends from the edges which are obviously not necessary.</summary>
      <param name="graph">the graph to obtain the edges from</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Sequencer">
      <summary>The current Sequencer instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SetAlgorithmProperty(System.Object,System.Object)">
      <summary>
            Provides access to implementation specific
            properties of the algorithms used internally.
            </summary>
      <param name="key">the key to a property</param>
      <param name="value">the value to associate with the key</param>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SwimlaneDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">
        </see>
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor"></see>
            instances for each node in the graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHint">
      <summary>
            Hint objects used internally by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter">this</see>
            layout algorithm implementation.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHint.None">
      <summary>
            Convenience singleton instance of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.None"></see></summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHint.Type">
      <summary>The type constant for this hint.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator">
      <summary>
            Interface for a helper class used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during
            the node placement phase.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.Dispose(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to dispose internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that was used</param>
      <param name="ldp">the LayoutDataProvider that was used to query information</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Main interface method.</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer object that contains the nodes</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="left">
            the left one of the two nodes whose
            minimum distance is to be determined or <see langword="null"></see> if only the left border of the right node is
            of interest.
            </param>
      <param name="right">
            the right one of the two nodes whose
            minimum distance is to be determined or <see langword="null"></see> if only the right border of the left node is
            of interest.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.Initialize(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to initialize internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that will be used during subsequent calls</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData">
      <summary>Multi-purpose edge descriptor for each edge in the graph during the layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.AssociatedEdge">
      <summary>A possibly associated edge</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.AssociatedNode">
      <summary>A possibly associated node</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.EdgeLayoutDescriptor">
      <summary>
            The EdgeLayoutDescriptor instance that was initially bound to this edge
            or <see langword="null"></see>.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.FallbackUpperSameLayerEdge">
      <summary>
            Specifies whether this edge should be an upper same layer edge if it is a
            same layer edge and it can be freely determined whether it should
            be routed above or below the layer.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Group">
      <summary>The group that is represented by this edge</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Reversed">
      <summary>Specifies whether the edge has been reversed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.SourceCandidates">
      <summary>
            The Collection of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            s for the
            source port as obtained from the DataProvider bound to the graph via
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey"></see>
            data provider key
            bound to the original edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.SourceGroup">
      <summary>The source group id object if any</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Spc">
      <summary>The current source port constraint</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.TargetCandidates">
      <summary>
            The Collection of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate"></see>
            s for the
            source port as obtained from the DataProvider bound to the graph via
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey"></see>
            data provider key
            bound to the original edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.TargetGroup">
      <summary>The target group id object if any</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Tpc">
      <summary>The current target port constraint</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Type">
      <summary>The type constant of the edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.UpperSameLayerEdge">
      <summary>
            Specifies whether the edge is an upper same layer edge
            (in case it is a same layer edge).
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser">
      <summary>Interface for implementations that perform their work after the first phase.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser.NormalizeEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called at the beginning of the layout algorithm.</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried to receive the
            layering information
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser.RestoreEdgeDirections(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called at the end of the layout algorithm.</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried to receive the
            layering information
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser.Reverse(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Edge)">
      <summary>May be called by the incremental parts of the layout algorithm.</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried to receive the
            layering information
            </param>
      <param name="edge">the edge to reverse</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory">
      <summary>
            Factory interface for
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateLayerIncrementallyHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            after the layering phase.
            </summary>
      <param name="forNodeId">
            the node to be layered and sequenced incrementally together
            with its adjacent edges and possibly marked neighboring nodes.
            </param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateSequenceIncrementallyHint(System.Object)">
      <summary>
            Creates a hint object for a node or edge that should be inserted incrementally
            after the sequencing phase.
            </summary>
      <param name="forItemId">the node to be sequenced/inserted incrementally</param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateUseExactCoordinatesHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current position.
            </summary>
      <param name="forNodeId">the node to be placed at its exact current position</param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateUseExactLayerCoordinatesHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current layer position.
            </summary>
      <param name="forNodeId">
      </param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateUseExactSequenceCoordinatesHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current sequence position.
            </summary>
      <param name="forNodeId">
      </param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see></returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder">
      <summary>
            Used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            to write back layering information.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.ProvidesValue">
      <summary>Returns whether the current context provides a value.</summary>
      <returns>whether meaningful value can be queried from the current context.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.Value">
      <summary>The value of the current context.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory">
      <summary>
            Factory that consistently creates and destroys helper structures in the
            graph during layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.ConvertToLabelNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Converts a node to a label node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateBendNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates a bend node in the layer for the given edge</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateBendNodeData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates bend node data for a bend node and associates it with the node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateConnectorProxyForGroup(yWorks.yFiles.Algorithms.Node,System.Object,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge)">
      <summary>Create a dummy edge that mimics a connector to a group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateDistanceNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Util.Geom.Rectangle2D.Double,yWorks.yFiles.Algorithms.Edge[])">
      <summary>Creates a spacer node for the drawing phase using the given bounds</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateDummyEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>Creates a dummy edge using the given data.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateEdgeGroupNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,System.Object)">
      <summary>Creates an edge group node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateEdgeGroupNodeData(yWorks.yFiles.Algorithms.Node,System.Object,System.Boolean)">
      <summary>Creates an edge group node data for an edge group node and associates it with the node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupBorderEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an edge that connects two group border nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupBorderNode(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,System.SByte)">
      <summary>Creates a group boundary node for a group node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupLayerDummyNode">
      <summary>Create a dummy node for the group layer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupNodeConnectorEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates a group node connector edge between two group nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateNormalEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates edge data for a normal edge and associates it with the edge</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateNormalNodeData(yWorks.yFiles.Algorithms.Node)">
      <summary>Creates node data for a normal node and associates it with the node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean)">
      <summary>
            Creates a proxy node for an edge during the drawing phase,
            changing the edge to end/start at the proxy
            </summary>
      <returns>the proxy</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNodeData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates proxy node data for a proxy node and associates it with the node</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateReverseDummyEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>Creates a reversed dummy edge using the given data</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates edge data for a same layer edge and associates it with the edge</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates a same layer proxy node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerSideProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Creates a proxy node for a same layer edge during the drawing phase that
            ends at the side of a node.
            </summary>
      <returns>the newly created proxy</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerSwitchProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Creates a same layer switch proxy (switching between two same layer edges on two different sides
            of the layer).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSelfLoopEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates edge data for a self loop edge and associates it with the edge</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroyDistanceNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Destroys a previously created spacer node for the drawing phase.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroyLabelNodeLayer(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,System.Boolean)">
      <summary>Destroys a previously created label layer</summary>
      <param name="layer">the layer to destroy</param>
      <param name="useInEdges">
            whether the incoming edges should be used
            as the resulting edges
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroyProxyNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Destroys a proxy node that has been created using
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean)"></see>
            for the drawing phase
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroySameLayerProxy(yWorks.yFiles.Algorithms.Edge)">
      <summary>Destroy a previously created same layer edge proxy</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroySameLayerSideProxy(yWorks.yFiles.Algorithms.Node)">
      <summary>Destroys a proxy node that has been created using.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroySameLayerSwitchProxy(yWorks.yFiles.Algorithms.Node)">
      <summary>Destroys a previously generated same layer switch proxy</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.InsertEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Inserts a same layer edge or an edge that may span multiple layers into the
            data structure.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.InsertGroupNodeLayer(System.Boolean,System.Int32)">
      <summary>Inserts an edge group node layer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.InsertLabelNodeLayer(System.Boolean,System.Int32)">
      <summary>Inserts a layer for label nodes group node layer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.RegisterSameLayerEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Registers an edge as a same layer edge appropriately into all data structures.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.SetDirectlyConnectSameLayerEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Converts a normal edge to a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.DirectSameLayerEdge"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.SetTemporaryPortConstraint(yWorks.yFiles.Algorithms.Edge,System.Boolean,yWorks.yFiles.Layout.PortConstraint)">
      <summary>Sets a port constraint for an edge at the given side.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.UnconvertToLabelNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Reverts a label node to the previous kind of node</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer">
      <summary>
            Describes a single layer in a hierarchical drawing
            with all its nodes and associated same layer edges.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Add(yWorks.yFiles.Algorithms.Node)">
      <summary>Adds a newly created node to this layer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.AddSameLayerEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Adds a same layer edge to this layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Index">
      <summary>The index of this layer in the list of all layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.List">
      <summary>The nodes in this layer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Remove">
      <summary>Removes the current layer from the Layers structure.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a node from this layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.SameLayerEdges">
      <summary>All same layer edges in this layer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.SetNodeOrder(yWorks.yFiles.Algorithms.YList)">
      <summary>Adjusts the order of the nodes in this list according to the given order.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Type">
      <summary>The main type of this layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger">
      <summary>
            Merges two
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers"></see>
            instances, whose nodes reside in the same graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger.Merge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            All nodes in srcLayers and targetLayers are part of graph at the moment of
            invocation.
            </summary>
      <param name="graph">
            the graph that contains the nodes in <c>srcLayers</c> and
            <c>targetLayers</c>.
            </param>
      <param name="ldp">the LayoutDataProvider that can be used to query the layer indices</param>
      <param name="srcLayers">
            the Layers implementation that contains the layers that
            will be merged into <c>targetLayers</c></param>
      <param name="targetLayers">
            the Layers that will be modified to contain the resulting
            layering
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer">
      <summary>
            This interface is used by classes that are capable of generating a layer
            assignment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers"></see>
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer"></see>
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers">
      <summary>
            Container class that manages multiple
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer"></see>
            instances.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.CreateInstance">
      <summary>
            Creates a new and empty Layers instance that can be used on the same graph
            instance for temporary results.
            </summary>
      <returns>
            an instance of the same type as the current instance. It will be
            empty initially.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.GetLayer(System.Int32)">
      <summary>Returns a layer by index</summary>
      <param name="i">the zero-based index</param>
      <returns>the layer at the given index</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Insert(System.SByte,System.Int32)">
      <summary>Creates, inserts and returns a layer of a given type.</summary>
      <param name="type">
            a type constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer"></see>
            interface
            </param>
      <param name="position">the position where this layer will be inserted</param>
      <returns>a newly created read-to-use layer instance</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Remove(System.Int32)">
      <summary>Removes a layer by index.</summary>
      <param name="index">the zero-based index of the layer</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Size">
      <summary>Returns the number of layers in this instance</summary>
      <returns>the number of layers</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider">
      <summary>
            Accessor interface for retrieving
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instances
            for elements in the current layout graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider.GetEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the associated
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instance.
            </summary>
      <param name="edge">the edge for which the data will be returned</param>
      <returns>the instance</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider.GetNodeData(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the associated
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            instance.
            </summary>
      <param name="node">the node for which the data will be returned</param>
      <returns>the instance</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType"></member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.None">
      <summary>
            Type specifier that is used as a dummy. This hint actually tells the algorithm that the corresponding
            element should not be treated as an incrementally added element.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.LayerIncrementally">
      <summary>Type specifier that is used for nodes that shall be inserted into the drawing incrementally.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.SequenceIncrementally">
      <summary>Type specifier that is used for edges that shall be inserted into the drawing incrementally.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.PlaceUsingExactCoordinates">
      <summary>
            Type specifier that is used for nodes that shall be placed into the drawing from sketch using the exact current
            coordinates for both the position within the layer and the position in the sequence.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.PlaceUsingExactSequenceCoordinates">
      <summary>
            Type specifier that is used for nodes that shall be placed into the drawing from sketch using
            the exact current coordinates for the position within the
            sequence in the layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.PlaceUsingExactLayerCoordinates">
      <summary>
            Type specifier that is used for nodes that shall be placed into the drawing from sketch using
            the exact current coordinates for the position within the layer.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData">
      <summary>
            Multi-purpose node descriptor for each node in the graph during the
            hierarchic layout used internally by the algorithm implementations.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.AssociatedEdge">
      <summary>The associated edge (in case of e.g.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.AssociatedNode">
      <summary>The associated node (in case of e.g.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.CreateBorderLine(System.Int32,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates, stores, and returns a BorderLine for the given side or returns the currently
            set BorderLine if it already exists.
            </summary>
      <param name="side">
            the side as defined in
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GetNormalizedBorderLine(System.Int32)"></see></param>
      <param name="nl">
            the NodeLayout of the current node, the initial Borderline will
            be initialize from this instance
            </param>
      <exception cref="T:System.NotSupportedException">
            if this type of node does not support node
            borders
            </exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.FirstSameLayerEdgeCell">
      <summary>The first same layer edge ListCell of all same layer edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GetNormalizedBorderLine(System.Int32)">
      <summary>
            Returns a borderline for the given side which is treated as if the node's position
            was at (0,0).
            </summary>
      <param name="side">
            the index of the side where <c>0</c> means top, <c>1</c>
            means right, <c>2</c> means bottom, and <c>3</c> means left.
            </param>
      <returns>a BorderLine instance if the node was at (0,0) or <see langword="null"></see></returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GroupId">
      <summary>Group id of this node if it is a bus group node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GroupLayers">
      <summary>The inner layers of this group node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GroupNode">
      <summary>The group node this node belongs to.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.IncrementalHint">
      <summary>
            The hint of the incremental mode of this node if this node is of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Normal"></see>
            and a corresponding hint has been set via the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey"></see>
            DataProvider.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer">
      <summary>The layer index this node resides in</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.NodeLayoutDescriptor">
      <summary>
            The <c>NodeLayoutDescriptor</c> instance that was initially
            bound to this node or <see langword="null"></see>.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.ParentGroupNode">
      <summary>The parent group node if any</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position">
      <summary>The current position of this node in its layer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.SameLayerEdgeCount">
      <summary>Returns the number of same layer edges that are associated with this node</summary>
      <returns>the number</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.SwimLaneDescriptor">
      <summary>
            The <c>SwimLaneDescriptor</c> instance that was initially
            bound to this node or <see langword="null"></see>.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type">
      <summary>The type constant for this node</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer">
      <summary>
            Responsible for the x (sequence) and preliminary y coordinate assignments of
            a drawing.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            before the ports get assigned.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            to determine the resulting x coordinates.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
      <param name="drawingDistanceCalculator">
            an instance that can be queried to determine
            the minimum distance between each pair of nodes in the graph
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter">
      <summary>
            Adapter class that uses a
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap"></see>
            ,
            <see cref="T:yWorks.yFiles.Algorithms.INodeMap"></see>
            , or
            <see cref="T:yWorks.yFiles.Algorithms.IEdgeMap"></see>
            implementation and wraps it as a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            that provides
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder"></see>
            instances for each element.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.IDataAcceptor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a new instance of IntValueHolderAdapter using a pair
            of DataAcceptor and DataProvider instances for storage and retrieval.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Creates a new instance of IntValueHolderAdapter using a DataMap</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Creates a new instance of IntValueHolderAdapter using an EdgeMap</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Creates a new instance of IntValueHolderAdapter using a NodeMap</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.Get(System.Object)">
      <summary>Returns an object value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.GetBool(System.Object)">
      <summary>Returns a boolean value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.GetDouble(System.Object)">
      <summary>Returns a double value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.GetInt(System.Object)">
      <summary>Returns an integer value associated with the given data holder.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortAllocator">
      <summary>
            Interface used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortAllocator.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            before the actual node placing takes
            place (phase three).
            </summary>
      <param name="graph">the graph which contains all the elements</param>
      <param name="layers">the layers object that contains the elements in the layering</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried for the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instances
            </param>
      <param name="itemFactory">
            the ItemFactory that can be used to temporarily modify
            the graph instance
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer">
      <summary>
            This interface serves as a callback for
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            after the layering and sequencing phases.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer.OptimizeAfterLayering(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the layering information has been determined.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the sequence of the nodes has been determined after the layering.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory">
      <summary>
            Specifies the general contract for factory classes that can be used
            to associate sequence constraints to a graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeAfterConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>after</c> to lie after
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="afterId">the id of the node that should be placed after the reference</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeAtHeadConstraint(System.Object)">
      <summary>Add a constraint that places a node at the start of the sequence.</summary>
      <param name="nodeId">the id of the node that should be placed at the start</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeAtTailConstraint(System.Object)">
      <summary>Add a constraint that places a node at the end of the sequence.</summary>
      <param name="nodeId">the id of the node that should be placed at the end</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeBeforeConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>before</c> to lie before
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="beforeId">the id of the node that should be placed before the reference</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.Dispose">
      <summary>Disposes the SequenceConstraintFactory.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.Memento">
      <summary>A token that allows to bind a constraint factory to a graph instance after creation.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer">
      <summary>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            to calculate the node
            orders of nodes within the layers in a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers"></see>
            object.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType"></member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.Normal">
      <summary>Describes a normal layer consisting mainly of normal nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.Label">
      <summary>Describes a layer consisting mainly of label nodes or dummy nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.SourceGroupNodes">
      <summary>Describes a layer consisting of source group nodes and dummy nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.TargetGroupNodes">
      <summary>Describes a layer consisting of target group nodes and dummy nodes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy">
      <summary>Constant for merging policy.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddBelow">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering below the
            layers in the target layering.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddAbove">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering above the
            layers in the target layering.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightTopAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the right of
            the layers in the target layering.
            Both layerings will be top aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightBottomAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the right of
            the layers in the target layering.
            Both layerings will be bottom aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightCenterAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the right of
            the layers in the target layering.
            Both layerings will be center aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddLeftTopAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the left of
            the layers in the target layering.
            Both layerings will be top aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddLeftBottomAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the left of
            the layers in the target layering.
            Both layerings will be bottom aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddLeftCenterAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the left of
            the layers in the target layering.
            Both layerings will be center aligned before the merge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer">
      <summary>
            Wrapper Layerer implementation that delegates the actual layering to a
            delegate Layerer.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer)">
      <summary>
            Creates a new instance of MultiComponentLayerer using the given
            delegate and a new instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger"></see>
            as the merger and no component comparator.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger,System.Collections.IComparer)">
      <summary>
            Creates a new instance of MultiComponentLayerer using the given
            delegates.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers"></see>
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer"></see>
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.ComponentComparator">
      <summary>The current component Comparator or <see langword="null"></see>.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.Merger">
      <summary>The merger.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.SingleComponentLayerer">
      <summary>The Layerer instance that is used for delegation.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.Sort(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)"></see>
            .
            </summary>
      <param name="nodeLists">
            the array of NodeLists each containing all nodes that belong
            to the same component
            </param>
      <param name="componentIndexProvider">
            a DataProvider that can be used to query the
            nodes' component indices via
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)"></see>
            and/or
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)"></see>
            .
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Normal">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A normal node - may have any degree, any size and any number of connected
            same layer edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Bend">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A bend node - has degree 2, small size and no same layer edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SideProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A side proxy node in case port constraints are used for the drawing phase
            - has degree 1, small size and no same layer edges.
            The associated node is the node this node is the proxy of.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SameLayerSideProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A side proxy node for drawing same layer edges - has degree 0, small size
            and one same layer edge.
            The associated node is the node this node is the proxy of.
            The associated edge is the same layer edge this node is the proxy of.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Label">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A label node for drawing - has degree 2, size of the labels and no same layer edges.
            The borders of this node describe the layout of the labels
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Group">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A group node if nested graph layouts are calculated.
            Carries additional
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers"></see>
            information.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SourceGroupNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A source group node for bus edges. This node serves as a dummy node
            in a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.SourceGroupNodes"></see>
            layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.TargetGroupNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A target group node for bus edges. This node serves as a dummy node
            in a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.TargetGroupNodes"></see>
            layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SourceBackloopProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A backloop proxy that belongs to the source of an edge
            - has degree 2, small size and exactly one same layer edge
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.TargetBackloopProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A backloop proxy that belongs to the target of an edge
            - has degree 2, small size and exactly one same layer edge
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SameLayerCenterNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A same layer edge crossing dummy node - has degree 2,
            small size and exactly two same layer edges.
            Is used to mark the crossing of the layer if source and target port
            are at opposite layer sides.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.DistanceNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A node used for the drawing phase to keep the distance between two nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.GroupBegin">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A node used for the drawing phase to mark the beginning of a node group interval.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.GroupEnd">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A node used for the drawing phase to mark the ending of a node group interval.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.GroupLayerDummy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A node used for the the sequencing and drawing phase to mark a dummy node inserted to guarantee that a group
            is non-empty on each layer that it is defined on.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.ProxyForEdgeAtGroup">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see>
            .
            A node used for the the sequencing and drawing phase to mark a dummy node that has been inserted
            as a legal end point of an edge connecting to a group node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.Never">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            . This mode prevents node labels from being
            considered during the layout at all.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForSelfLoops">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            . This mode makes the algorithm consider
            node labels for self-loops, node placement, and routing.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            . This mode makes the algorithm consider
            node labels for node placement and routing but not for self loops.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForRouting">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode"></see>
            . This mode makes the algorithm consider
            node labels during routing only.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the various
            phases to determine the drawing details of the graph's nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.#ctor">
      <summary>
            Creates a new instance of a NodeLayoutDescriptor using the
            default values.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.GetPortBorderGapRatio(System.Int32)">
      <summary>
            Returns the port border gap ratio for the port distribution at the given
            side.
            </summary>
      <param name="side">the 0-based clockwise side index for top-to-bottom layouts</param>
      <returns>the ratio</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.LayerAlignment">
      <summary>
            The alignment of the node within its layer
            Default is <c>0.5d</c> which results in center-aligned nodes.
            </summary>
      <exception cref="T:System.ArgumentException">if the alignment is not within [0.0d .. 1.0d]</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.MinimumDistance">
      <summary>The <i>preferred</i> minimum distance of the node to obstacles.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.MinimumLayerHeight">
      <summary>The minimum height of the layer this node will be assigned to.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode">
      <summary>
            The mode that determines the consideration of node labels during the
            layout.<br></br>
            This can be one of
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.Never"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForSelfLoops"></see>
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing"></see>
            , or
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForRouting"></see>
            .
            </summary>
      <exception cref="T:System.ArgumentException">if the constant is unknown.</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.PortBorderGapRatios">
      <summary>
            The port border gap ratio for the port distribution on all sides of
            the node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.SetPortBorderGapRatio(System.Int32,System.Double)">
      <summary>
            Sets the port border gap ratio for the port distribution at the given
            side.
            </summary>
      <param name="side">the side</param>
      <param name="ratio">the new ratio</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper">
      <summary>
            Wraps a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ILayerer"></see>
            implementation from the <c>y.layout.hierarchic</c>
            package to behave like a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer"></see>
            implementation from the
            <c>y.layout.hierarchic.incremental</c> package.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper.#ctor(yWorks.yFiles.Layout.Hierarchic.ILayerer)">
      <summary>Creates a new instance of OldLayererWrapper, wrapping the given layerer.</summary>
      <param name="oldLayerer">the old layerer implementation</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers"></see>
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer"></see>
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper.OldLayerer">
      <summary>
            The <c>y.layout.hierarchic.Layerer</c>
            instance that is used for delegation.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer">
      <summary>
            This class is an implementation of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer"></see>
            interface which can be registered
            with the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            instance using it's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortConstraintOptimizer"></see>
            method.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.CrossingPenalty">
      <summary>
            The penalty cost that is associated with each generated crossing that would be generated
            if a given combination of PortCandidates would be chosen.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.Deterministic">
      <summary>Determines whether this implementation should use a deterministic algorithm to assign the PortCandidates.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.GetPortCandidateSetDataProvider(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns the data provider that provides the port candidate sets for nodes.</summary>
      <param name="graph">The graph that stores the data provider</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.LayoutOrientation">
      <summary>
            The
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.LayoutOrientation">currently set layout orientation</see>
            for this instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.OptimizeAfterLayering(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the layering information has been determined.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the sequence of the nodes has been determined after the layering.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData"></see>
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData"></see>
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.OverUsagePenalty">
      <summary>
            The penalty cost that is associated with each edge being assigned to a port which has no
            capacity left.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator">
      <summary>
            This class can be used to calculate bend points for orthogonally routed
            self loops.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.#ctor(System.Double,System.Double)">
      <summary>
            Creates a new instance of SelfloopCalculator using the given
            parameters for minimum first segment length and minimum distance between
            each pair of edges.
            </summary>
      <param name="minFirstSegmentLength">
            the minimum length of the first and last segment
            of an orthogonally routed self loop
            </param>
      <param name="minEdgeDistance">the minimum distance between a pair of self loops</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.CalculateSelfLoops(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates all self loops at the given node the given graph.</summary>
      <param name="graph">the graph that contains the node</param>
      <param name="node">the node whose self loops will be routed</param>
      <param name="spc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            information
            for the source ports of the edges
            </param>
      <param name="tpc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            information
            for the target ports of the edges
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.CalculateSelfLoops(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Convenience method that calculates a list of self-loops that belong to a given node.</summary>
      <param name="graph">the graph that contains the node</param>
      <param name="node">the node whose self loops will be routed</param>
      <param name="selfLoops">
            a list of
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            s that will be routed
            </param>
      <param name="spc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            information
            for the source ports of the edges
            </param>
      <param name="tpc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            information
            for the target ports of the edges
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the minimum length between two edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumFirstSegmentLength(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the minimum length for the first segment of an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumLastSegmentLength(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the minimum length for the last segment of an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumNodeDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the minimum length between two nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumEdgeDistanceDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            bound to the graph that
            yields for each edge a minimum distance to the next edge or node side.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumFirstegmentLengthDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            bound to the graph that
            yields for each edge a minimum length of its first segment.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumLastSegmentLengthDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            bound to the graph that
            yields for each edge a minimum length of its last segment.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumNodeDistanceDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            bound to the graph that
            yields for each node a minimum distance to the self loop edges.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer">
      <summary>
            NodePlacer implementation based on
            <see cref="T:yWorks.yFiles.Algorithms.RankAssignments">rank-assignment</see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            before the ports get assigned.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            to determine the resulting x coordinates.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
      <param name="drawingDistanceCalculator">
            an instance that can be queried to determine
            the minimum distance between each pair of nodes in the graph
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.BaryCenterMode">
      <summary>Specifies whether or not to use the barycenter drawing mode.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.BreakLongSegments">
      <summary>Specifies whether this instance may break long edge segments in favor of a more compact layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.ExactPlacementEnforced">
      <summary>
            Specifies whether this instance should enforce the placement of nodes at
            their exact current position, even if this violates minimum distance
            constraints.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GetLayerAlignment(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double)">
      <summary>
            Callback method used by
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)"></see>
            to determine the alignment of the node inside the layer
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Determines the minimum allowed distance between two nodes in a given layer</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer that contains the nodes</param>
      <param name="predNode">the node to the left of the other one, may be <see langword="null"></see> to indicate a border line</param>
      <param name="succ">the node to the right of the other one, may be <see langword="null"></see> to indicate a border line</param>
      <returns>the minimum distance allowed between those two nodes ( &gt;=0 )</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GetMinimumLayerHeight(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer)">
      <summary>
            Callback method used by
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)"></see>
            to determine the minimum height of a layer.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy">
      <summary>
            The strategy that is used to control the horizontal compactness
            of group nodes.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.HorizontalCompaction">
      <summary>Specifies whether this instance tries to create a maximally compact horizontal layout at the cost of more bends.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.IsFixedNode(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Callback used by both
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)"></see>
            and
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)"></see>
            to determine whether the given node should be treated as a node with fixed (given) coordinates.
            </summary>
      <param name="graph">the graph that contains the node</param>
      <param name="provider">the current LayoutDataProvider</param>
      <param name="node">the node</param>
      <param name="inLayer">
            whether the nodes' layer coordinate is queried or the sequence coordinate.
            Iff <c>inLayer</c> is <see langword="true"></see> this method is called from within the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)"></see>
            method
            </param>
      <returns>whether the node should be treated as fixed</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.SwimLaneCrossingWeight">
      <summary>
            The relative weight of edges crossing a swim lane relative to edges that stay
            in their lane.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter"></see>
            during the various
            phases to associate swim lanes with each node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.#ctor(System.IComparable)">
      <summary>Creates a new swim lane descriptor with an associated client object.</summary>
      <param name="clientObject">
            an object provided by the client that will be used
            for determining the order of the lanes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.#ctor(System.Object,System.Collections.IComparer)">
      <summary>
            Creates a new swim lane descriptor using the given
            client object and comparator.
            </summary>
      <param name="clientObject">a client object used for sorting the lanes</param>
      <param name="cmp">a Comparator used for comparing the client objects.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ClientObject">
      <summary>The client object.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.Comparator">
      <summary>The comparator that is used for sorting the lanes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.CompareTo(System.Object)">
      <summary>
            Implements the Comparable interface using the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.Comparator"></see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ClientObject"></see>
            fields.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ComputedLaneIndex">
      <summary>
            The computed zero-based index of the lane
            after the layout has been calculated.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ComputedLanePosition">
      <summary>
            The computed position (smaller coordinate) of the lane
            after the layout has been calculated.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ComputedLaneWidth">
      <summary>
            The computed width of the lane
            after the layout has been calculated.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.IndexFixed">
      <summary>
            Specifies whether the index of this swim lane is fixed or whether
            the algorithm should try to find the best possible position.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.LaneTightness">
      <summary>The tightness factor of the lane.</summary>
      <exception cref="T:System.ArgumentException">if tightness is out of the valid range</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.LeftLaneInset">
      <summary>
            The left lane insets where no element
            will lie in the resulting drawing.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.MinimumLaneWidth">
      <summary>The minimum lane width.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.RightLaneInset">
      <summary>
            The right lane insets where no element
            will lie in the resulting drawing.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage">
      <summary>
            This layout stage can be used to automatically assign
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor"></see>
            instances to nodes using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SwimlaneDescriptorDpkey"></see>
            by treating top-level group nodes as swimlanes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.OrderSwimlanesFromSketch">
      <summary>Determines whether the order of the swimlanes should be read from the current sketch.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.Spacing">
      <summary>Determines the spacing between the lanes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer">
      <summary>
            Inserts nodes incrementally into an existing layer structure, without destroying
            the latter.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.#ctor">
      <summary>Creates a new instance of IncrementalLayerer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Calculates an optimal layering for incrementalnodes</summary>
      <param name="graph">
            the graph containing all nodes in layers and all nodes in incrementalNodes as
            well as the respective edges.
            </param>
      <param name="layers">the Layers structure containing all nodes but the incremental ones.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.LayeredComponentsMerger">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger"></see>
            instance that will be used to
            merge the layerings of separate components into the current layering.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.SeparateComponentsLayerer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer"></see>
            instance used for the layering of separate
            components.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator">
      <summary>
            This implementation returns the minimum distances for each kind of node pair
            based on their type as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type"></see></summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.#ctor">
      <summary>Creates a new instance of TypeBasedDrawingDistanceCalculator</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Dispose(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to dispose internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that was used</param>
      <param name="ldp">the LayoutDataProvider that was used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Edge2EdgeDistance">
      <summary>The distance between edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Main interface method.</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer object that contains the nodes</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="left">
            the left one of the two nodes whose
            minimum distance is to be determined or <see langword="null"></see> if only the left border of the right node is
            of interest.
            </param>
      <param name="right">
            the right one of the two nodes whose
            minimum distance is to be determined or <see langword="null"></see> if only the right border of the left node is
            of interest.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Initialize(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to initialize internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that will be used during subsequent calls</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.MinimumFirstSegmentLength">
      <summary>The minimum length of the first and last segment of an edge.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Node2EdgeDistance">
      <summary>The distance between nodes and edges.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Node2NodeDistance">
      <summary>The distance between nodes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm">
      <summary>This class is an abstract base class for labeling algorithms.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.ApplyPostprocessing">
      <summary>True if the postprocessing step is applied.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Place the labels in the graph.</summary>
      <param name="graph">The graph to label.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.EdgeGroupOverlapAllowed">
      <summary>Specifies whether edge labels may overlap with edges belonging to the same edge group.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.GetProfit(yWorks.yFiles.Layout.LabelCandidate)">
      <summary>Returns the profit model that is used to rank the available positions for each label.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Label(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Place the labels in the graph.</summary>
      <param name="gl">The graph to label.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Label(yWorks.yFiles.Layout.LayoutGraph,System.Object)">
      <summary>Place a subset of the labels.</summary>
      <param name="key">
            The key for a <c>DataProvider</c> in <c>gl</c>. Labels which should be placed return
            <see langword="true"></see>.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Label(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.YList)">
      <summary>Place some labels in the graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.MoveInternalNodeLabels">
      <summary>True if the labeling algorithm is allowed to move internal node labels.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.PlaceEdgeLabels">
      <summary>If labels assigned to nodes in a graph should be placed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.PlaceNodeLabels">
      <summary>If labels assigned to nodes in a graph should be placed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.ProfitModel">
      <summary>The profit model that is used to rank the available positions for each label.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Rects">
      <summary>The set of all generated candidate rectangles.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.RemoveEdgeOverlaps">
      <summary>How label candidates which overlap with edges are handled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.RemoveNodeOverlaps">
      <summary>How label candidates which overlap with nodes are handled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Selection">
      <summary>
            The <c>DataProvider</c> key, under which the labeling selection
            can be retrieved.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.SelectionKey">
      <summary>The labeling selection <c>DataProvider</c> key.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.StoreRects">
      <summary>Specifies whether the candidate rectangles should be stored to be retrieved.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.UseAlternativeSideHandling">
      <summary>
        <see langword="true">
        </see> if the preference on which side of an edge a
            corresponding label should be placed is interpreted by human perception
            instead of always following the edge from source to target.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling">
      <summary>This class places the labels of a graph using a greedy strategy.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling" /> class</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm">
      <summary>Solving labeling problem by reducing it to the maximum independent set problem.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.#ctor">
      <summary>Initializes a new instance of the MISLabelingAlgorithm class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.AssignProfit">
      <summary>Creates a node map which assigns to each node the profit.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.boxesToNodes"></member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.conflictGraph">
      <summary>the conflict graph</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.CreateEdges">
      <summary>Creates one edge between two nodes if the corresponding label candidates are intersecting.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.FoundEdgeOverlap(yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.LineSegment)">
      <summary>Calculates the overlapping factor between a label candidate and an edge segment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.FoundLabelOverlap(yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Algorithms.Edge)">
      <summary>Calculates the overlapping factor between two label candidates.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.FoundNodeOverlap(yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Calculates the overlapping factor between a label candidate and a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.graph"></member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.nodesToBoxes">
      <summary>holds for each node in the conflictGraph the corresponding LabelCandidate</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.nodesToID">
      <summary>holds for each node in the conflictGraph the corresponding integer index of the Label[]</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.OptimizationStrategy">
      <summary>The optimization strategy of the labeling algorithm.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.OptimizationStrategy"></member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.Balanced">
      <summary>Use a balanced optimization strategy.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.NodeOverlap">
      <summary>Use an optimization strategy that especially reduces overlaps between labels and nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.LabelOverlap">
      <summary>Use an optimization strategy that especially reduces overlaps between labels.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.EdgeOverlap">
      <summary>Use an optimization strategy that especially reduces overlaps between labels and edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.None">
      <summary>Use no optimization strategy.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.SALabeling">
      <summary>
            This class is based on the enhanced profit model and places the labels of a graph using a simulated annealing
            strategy taking into account the amount of overlaps of labels.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.SALabeling.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Labeling.SALabeling" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.SALabeling.DeterministicMode">
      <summary>Specifies whether or not this labeling algorithm should work deterministically.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.SALabeling.MaximalDuration">
      <summary>The time limit for the algorithm (in milliseconds).</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.GRIP">
      <summary>
            This class implements a variant of the GRIP algorithm by
            P Gajer and SG Kobourov: "Graph Drawing with
            Intelligent Placement".
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GRIP.#ctor">
      <summary>Creates a new instance of the GRIP layout algorithm</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GRIP.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.Deterministic">
      <summary>Specifies whether or not GRIP works in a deterministic manner.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GRIP.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.FinalRounds">
      <summary>The number of the final rounds</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.InitialTemperature">
      <summary>The initial temperature</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.Laxity">
      <summary>The current laxity value.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.NodeSizeAware">
      <summary>Specifies whether or not GRIP takes average node sizes into account.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.PreferredEdgeLength">
      <summary>The desired edge length</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.Rounds">
      <summary>The number of the initial rounds</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.SmartInitialPlacement">
      <summary>Specifies whether or not initial placements are determined in a smart way.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter">
      <summary>
            This class uses a customizable shuffle layout algorithm to recursively remove node
            overlaps from grouped graph structures.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of GroupedShuffleLayouter
            The given core layouter instance will get to perform its work before the
            actual shuffling takes place.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.GroupBoundsCalculator">
      <summary>The currently installed GroupBoundsCalculator instance</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.ShuffleLayouter">
      <summary>The layouter instance, that will be used for shuffling (removing node overlaps).</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.GroupsPolicy">
      <summary>Node group policy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Layout">
      <summary>
            Node group policy specifier. This layouter will consider grouping
            information of an input graph. It will layout the contents of groups
            in a way that highlights their togetherness.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Fixed">
      <summary>
            Node group policy specifier. This layouter will keep the relative positions
            of nodes that belong to the same group. The layouter will take the
            fixed groups into account when placing the other nodes of the graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Ignore">
      <summary>
            Node group policy specifier. This layouter will ignore all grouping related
            information when laying out the graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.IntersectionBox">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.NodeCenter">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.LessMovement">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.InitialPlacement">
      <summary>Initial placement strategy.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.InitialPlacement.Random">
      <summary>Initial placement strategy. Start with randomly chosen positions.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.InitialPlacement.Zero">
      <summary>Initial placement strategy. Start with all positions set to (0,0,0).</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.InitialPlacement.AsIs">
      <summary>Initial placement strategy. Start with given positions.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter">
      <summary>
            The InteractiveOrganicLayouter is a special organic layouter that offers functionality to change the
            laid out graph while the layouter is running.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.#ctor">
      <summary>Create a new instance of the InteractiveOrganicLayouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.AddStructureUpdate(System.EventHandler,System.EventArgs)">
      <summary>Adds a structural update to the queue.</summary>
      <param name="handler">The handler delegate that will be invoked using <see langword="null"></see> as the sender and <paramref name="args"></paramref> as the event arguments</param>
      <param name="args">The event argument that will be piped to the <paramref name="handler"></paramref> invocation.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.AutomaticStructureUpdateEnabled">
      <summary>Determines whether this algorithm performs automatic structure updates.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns whether this layouter can layout the given graph.</summary>
      <returns>
        <see langword="true">
        </see> if the graph may be laid out, <see langword="false"></see> otherwise.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.CommitPositions">
      <summary>
            This method writes the calculated positions (represented by the internal data structure of this layouter) to
            the LayoutGraph.<br></br>
            This method must only be called while the layouter is running
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running"></see>
            .<p></p>
            There may occur synchronization issues, if
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)"></see>
            is not called
            using a CopiedLayoutGraph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.CommitPositionsSmoothly(System.Double,System.Double)">
      <summary>
            This method transfers the calculated positions (represented by the internal data structure of this layouter) to
            the LayoutGraph.<br></br>
            This method must only be called while the layouter is running
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running"></see>
            .<p></p>
            The positions are not transfered directly.
            </summary>
      <param name="maxMovement">the maximal distance a node is moved</param>
      <param name="factor">determines the node movement (movement = factor * distance between calculated and actual location)</param>
      <returns>
            the biggest movement. This value can be used to estimate the difference between calculated layout
            and actual positions. If the return value is "0" the calculated layout has been transferred completely.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates the layout for the graph.</summary>
      <param name="graph">the graph that is laid out</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.EnableOnlyCore">
      <summary>
            Makes sure that the core of this layouter will not use the usual
            <see cref="T:yWorks.yFiles.Layout.ILayoutStage"></see>
            s,
            like
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter"></see>
            ,
            <see cref="T:yWorks.yFiles.Layout.ParallelEdgeLayouter"></see>
            , etc.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenter(yWorks.yFiles.Algorithms.Node)">
      <summary>Return the actual center of the node</summary>
      <param name="node">
      </param>
      <returns>the center of the node or null if the layouter does not know anything about the node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenterX(yWorks.yFiles.Algorithms.Node)">
      <summary>Return the actual center of the node.</summary>
      <param name="node">
      </param>
      <returns>the center of the node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenterY(yWorks.yFiles.Algorithms.Node)">
      <summary>Return the actual center of the node.</summary>
      <param name="node">
      </param>
      <returns>the center of the node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetStress(yWorks.yFiles.Algorithms.Node)">
      <summary>Gets the stress for the given node.</summary>
      <param name="node">
      </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.LastWakeupTime">
      <summary>The time when the last wake-up has occurred</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.MaxTime">
      <summary>The maximal time the layouter will run (in millis)</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.OutputRestriction">
      <summary>The current OutputRestriction instance set for this instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.PreferredEdgeLength">
      <summary>The preferred edge length.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.PreferredNodeDistance">
      <summary>The preferred node distance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Quality">
      <summary>The quality time ratio set.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running">
      <summary>Specifies whether the layouter is running at the moment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenter(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the center for the node.</summary>
      <param name="node">
      </param>
      <param name="x">
      </param>
      <param name="y">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenterX(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the center of the node.</summary>
      <param name="node">
      </param>
      <param name="x">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenterY(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the center of the node.</summary>
      <param name="node">
      </param>
      <param name="y">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetInertia(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Set the inertia for the node.</summary>
      <param name="node">
      </param>
      <param name="inertia">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetPreferredEdgeLength(yWorks.yFiles.Algorithms.Edge,System.Double)">
      <summary>Sets the preferred edge length for the given edge.</summary>
      <param name="edge">
      </param>
      <param name="newEdgeLength">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetRadius(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the radius for the given node</summary>
      <param name="node">
      </param>
      <param name="radius">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetStress(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the stress for the given node.</summary>
      <param name="node">
      </param>
      <param name="stress">a value between 0 and 1</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Sleeping">
      <summary>Specifies whether the layouter is sleeping.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Calls
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)"></see>
            in a separate, newly started Thread.
            </summary>
      <param name="graph">
            the graph to pass on to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)"></see></param>
      <returns>the Thread that has been created and started.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Stop">
      <summary>Stops the layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StopAndWait">
      <summary>
            Stops a previously
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayout(yWorks.yFiles.Layout.LayoutGraph)">started</see>
            layout
            Thread and blocks until the layout is completed.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Stopped">
      <summary>Specifies whether the layouter has been stopped.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SyncStructure">
      <summary>
            This method synchronizes the CopiedLayoutGraph given as parameter to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)"></see>
            with
            the original graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.WakeUp">
      <summary>This method may be called if something has "changed" and the layouter shall restart/continue layouting.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.WorkingRatio">
      <summary>The actual working ratio.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.OrganicLayouter">
      <summary>A graph layout algorithm that is based on a force directed model.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.#ctor">
      <summary>Returns a new organic Layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.ActivateDeterministicMode">
      <summary>Specifies whether or not this layouter is in deterministic mode.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.ActivateTreeBeautifier">
      <summary>Specifies whether or not to activate the subtree beautifier.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.Attraction">
      <summary>The current attraction.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns always <see langword="true"></see> because this algorithms has no
            preconditions.
            </summary>
      <returns>
        <see langword="true">
        </see>.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.Dispose">
      <summary>Frees resources</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the core layout algorithm.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.FinalTemperature">
      <summary>The final temperature.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.FixedGroupNodesDpKey">
      <summary>DataProvider key used in conjunction with hierarchically grouped graphs.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GravityFactor">
      <summary>The gravity factor.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GroupBoundsCalculator">
      <summary>
            The GroupBoundsCalculator instance that is used for the
            calculation of the group nodes' bounds if a hierarchically grouped graph is
            being laid out.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GroupNodeCompactness">
      <summary>The group node compactness factor.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GroupNodePolicy">
      <summary>The policy for group nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.InitialPlacement">
      <summary>The initial placement strategy.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.InitialTemperature">
      <summary>The initial temperature.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.IterationFactor">
      <summary>The iteration factor of this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.MaximumDuration">
      <summary>The maximum duration granted to this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.ObeyNodeSize">
      <summary>Specifies whether or not node sizes should be considered by this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.PreferredEdgeLength">
      <summary>
            The general edge length that should be attained by this
            layouter.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.PreferredEdgeLengthDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            with a
            LayoutGraph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.Repulsion">
      <summary>The current repulsion.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfAction">
      <summary>The sphere of action for this layouter.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfActionNodesDpKey">
      <summary>DataProvider key used in conjunction with the sphere-of-action feature.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.OutputRestriction">
      <summary>Implementations of this class can be set via a <c>setOutputRestriction(OutputRestriction)</c> method, e.g.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateAspectRatioRestriction(System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter"></see>
            so
            that the bounding box roughly has the given aspect ratio.
            </summary>
      <param name="ratio">the preferred aspect ratio (width/height) of the output</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateCircularCageRestriction(System.Double,System.Double,System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter"></see>
            so
            that the nodes lie within a circle.
            </summary>
      <param name="x">x coordinate of the center of the restriction circle</param>
      <param name="y">y coordinate of the center of the restriction circle</param>
      <param name="radius">the radius of the restriction circle</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateEllipticalCageRestriction(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter"></see>
            so
            that the nodes lie within an ellipse whose main axes are parallel to the coordinate axes.
            </summary>
      <param name="x">x coordinate of the upper left corner</param>
      <param name="y">y coordinate of the upper left corner</param>
      <param name="w">width of the bounding box of the ellipse</param>
      <param name="h">the height of the bounding box of the ellipse</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateRectangularCageRestriction(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter"></see>
            so
            that the nodes lie within the given rectangle.
            </summary>
      <param name="x">x coordinate of the upper-left corner of the restriction rectangle</param>
      <param name="y">y coordinate of the upper-left corner of the restriction rectangle</param>
      <param name="w">width of the restriction rectangle</param>
      <param name="h">height of the restriction rectangle</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction"></see></returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OutputRestriction.None">
      <summary>This restriction actually does not restrict the output.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage">
      <summary>
            This LayoutStage removes node overlaps and guarantees a certain minimal
            node distance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.#ctor(System.Double)">
      <summary>Creates a new instance of RemoveOverlapsLayoutStage</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.#ctor(yWorks.yFiles.Algorithms.Util.YRandom,System.Double)">
      <summary>Creates a new instance of RemoveOverlapsLayoutStage</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.graph">
      <summary>the graph</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.h">
      <summary>heights based on node-indices</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.nodes">
      <summary>the node array</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.random">
      <summary>the source of randomness</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.UpdatePos">
      <summary>updates arrays x and y according to the current centers of the nodes</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.w">
      <summary>widths based on node-indices</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.x">
      <summary>x coordinates based on node-indices</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.y">
      <summary>y coordinates based on node-indices</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.Scope"></member>
    <member name="F:yWorks.yFiles.Layout.Organic.Scope.All">
      <summary>Scope constant - used for layouting all nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.Scope.Subset">
      <summary>
            Scope constant - used for layouting the subset of nodes only.
            The above mentioned subset has to be specified by registering an
            appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            for key
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.Scope.MainlySubset">
      <summary>
            Scope constant - used for layouting mainly the subset of the nodes.
            The above mentioned subset has to be specified by registering an
            appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            for key
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.ShuffleLayouter">
      <summary>
            This layout stage removes node overlaps in a layout graph by using a method
            which is based on a famous russian arcade game.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.ShuffleLayouter.#ctor">
      <summary>Creates a new instance of ShuffleLayouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.BarycenterModeActive">
      <summary>
        <see langword="true">
        </see> if this layouter uses a barycenter based
            node shuffling strategy and <see langword="false"></see> otherwise.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.ShuffleLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.ShuffleLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Performs the force transfer algorithm on the given graph
            after the core layouter has performed its job.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.ShuffleLayouter.FixedNodeDpKey">
      <summary>
            This key can be used to specify a minimal distance for each single node in the graph
            using a data provider.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.HorizontalOverlapCriterium">
      <summary>The horizontal overlap criterion.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.ShuffleLayouter.MinimalDistanceDpKey">
      <summary>
            This key can be used to specify a minimal distance for each single node in the graph
            using a data provider.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.MinimalNodeDistance">
      <summary>
            The minimal distance between nodes that has to be obeyed by this
            layouter.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.SimpleModeActive">
      <summary>Specifies whether or not simple mode is active.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter">
      <summary>
            This class can be used as a convenience class to gain access to a variety of
            organic layout algorithms.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.#ctor">
      <summary>Creates a new SmartOrganicLayouter instance</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Compactness">
      <summary>The property for the compactness of the resulting layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ConfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)">
      <summary>
            Configures the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            and graph instance to adhere to the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey"></see>
            in case
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.All"></see>
            is not set.
            </summary>
      <param name="graph">the graph that will be arranged</param>
      <param name="layouter">the layouter to reconfigure</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Deterministic">
      <summary>Specifies whether the algorithm will behave deterministically in the next layout run.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupBoundsCalculator">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator"></see>
            instance used for calculating the size of group nodes.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null"></see></exception>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeDpKey">
      <summary>The data provider key for specifying how to handle group nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeFixBounds">
      <summary>Group node mode constant that can be used to tag a group node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeFixContents">
      <summary>Group node mode constant that can be used to tag a group node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeNormal">
      <summary>Group node mode constant that can be used to tag a group node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MaximumDuration">
      <summary>The maximum duration this algorithm is allowed to run.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MinimalNodeDistance">
      <summary>
            The current minimal node distance this algorithm should enforce if the
            node overlaps allowance property is set to <see langword="true"></see>.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeEdgeOverlapAvoided">
      <summary>Specifies whether this algorithm is configured to try to avoid node/edge overlaps.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeOverlapsAllowed">
      <summary>Specifies whether node overlaps are allowed (but not encouraged) for the next run.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSizeAware">
      <summary>Determines whether the algorithm should consider the size of the nodes for the layout.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey">
      <summary>The data provider key for specifying the node subset to be laid out.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction">
      <summary>The current OutputRestriction instance set for this instance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredEdgeLength">
      <summary>The currently set default preferred edge length.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredEdgeLengthDpKey">
      <summary>
            The data provider key for specifying the preferred edge lengths for each edge
            The algorithm expects to find
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)"></see>
            integer values associated with
            each edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredMinimalNodeDistance">
      <summary>
            The current preferred minimal node distance this algorithm should use for
            pairs of nodes that are not directly connected by adjacent edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.QualityTimeRatio">
      <summary>The quality to time ratio.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Scope">
      <summary>The scope of the layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.SmartComponentLayout">
      <summary>
            Determines whether this instance should configure the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            in such a way that it respects the
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Scope">scope's</see>
            settings
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.Subset"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.MainlySubset"></see>
            by keeping other nodes pinned, even if they reside in different components.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.UnconfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)">
      <summary>
            Unconfigures the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            from previous
            <see cref="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ConfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)"></see>
            call.
            </summary>
      <param name="graph">the graph that has been arranged</param>
      <param name="layouter">the layouter to unconfigure</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.SphereOfAction">
      <summary>Sphere of action specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SphereOfAction.All">
      <summary>Sphere of action specifier. Displace all nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SphereOfAction.MainlySelection">
      <summary>
            Sphere of action specifier. Displace mainly selected nodes, but allow
            minor movement of unselected nodes as well.
            A node is considered to be selected if the LayoutGraph DataProvider
            registered with the key
            <see cref="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfActionNodesDpKey"></see>
            returns <see langword="true"></see> for that node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SphereOfAction.OnlySelection">
      <summary>
            Sphere of action specifier. Displace only selected nodes
            A node is considered to be selected if the LayoutGraph DataProvider
            registered with the key
            <see cref="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfActionNodesDpKey"></see>
            returns <see langword="true"></see> for that node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage">
      <summary>
            This layout stage replaces edges by a path of nodes before it calls
            a core layouter.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.#ctor">
      <summary>Creates a new instance of SplitEdgeLayouter</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see></summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.ProxyNodeSize">
      <summary>The size used as width/height for proxy nodes, i.e.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.SplitSegmentLength">
      <summary>The split segment length.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter">
      <summary>
            This class is a variant of
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter"></see>
            that tries to arrange nodes in a more
            compact way, even allowing to specify a desired aspect ratio for the bounds of the
            calculated layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter.#ctor">
      <summary>
            Create a new instance of this class with a default aspect ratio of 1 and a
            default grid spacing of 20.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter.AspectRatio">
      <summary>The desired aspect ratio of the resulting layout bounds.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter.GridSpacing">
      <summary>The grid spacing used to place the nodes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter">
      <summary>
            This class is a variant of
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter"></see>
            that can route edges in a way that
            they point to a main layout direction.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
      <returns>
    <see langword="true"></see> for all graphs.</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DirectedEdgeDpKey">
      <summary>
            DataProvider key that is used to mark edges that should be routed in a way that
            point in the main layout direction.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.Grid">
      <summary>The currently set grid spacing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.UseSketchDrawing">
      <summary>If the existing drawing should be used as sketch.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.LayoutStyle">
      <summary>Layout style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal">
      <summary>
            Layout style specifier. In this layout style the size of the nodes will not
            be changed by the algorithm. All edges will be routed orthogonally.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Uniform">
      <summary>
            Layout style specifier. In this layout style a uniform size will be assigned to all
            nodes. All edges will be routed orthogonally.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Box">
      <summary>
            Layout style specifier. In this layout style the size of the original nodes will
            be enlarged in order to save some bends.
            All edges will be routed orthogonally.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Mixed">
      <summary>
            Layout style specifier. In this layout style not all edges will be routed orthogonally.
            Edge segments that directly connect to a node may be routed non-vertically and
            non-horizontally.
            A small uniform size will be assigned to all nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.NormalTree">
      <summary>
            Layout style specifier. Like
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal"></see>
            but all directed subtree structures
            of the graph will be laid out in an optimized way.  All edges will be routed orthogonally.
            The tree edges will be routed in a bus-like fashion.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.FixedMixed">
      <summary>
            Layout style specifier. In this layout style not all edges will be routed orthogonally.
            Edge segments that directly connect to a node may be routed non-vertically and
            non-horizontally.
            The size of nodes will not be altered.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.FixedBox">
      <summary>
            Layout style specifier. Nodes will be placed
            at the same location as with
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.FixedMixed"></see>
            but edges will be routed strictly orthogonally.
            The size of nodes will not be altered.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter">
      <summary>
            This class provides a layout algorithm which produces
            orthogonal drawings of hierarchically grouped graphs.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.#ctor">
      <summary>Creates a new instance of OrthogonalGroupLayouter</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.ComponentLayouter">
      <summary>
            Note that the component layouter set here should work in such a way that
            isolated components inside groups should be reported separately.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.Grid">
      <summary>The grid distance.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.LayoutQuality">
      <summary>The currently set layout quality.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter">
      <summary>
            This class provides a layout algorithm which produces
            orthogonal drawings.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.#ctor">
      <summary>Returns a new instance.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns always <see langword="true"></see>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns an orthogonal graph layout to the given layout graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.Grid">
      <summary>
            The size of the grid on which the nodes and edges are placed.<br></br>
            Default is 20.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.LayoutStyle">
      <summary>The layout style of this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.NodeModel"></member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.OptimizePerceivedBends">
      <summary>
            Specifies whether the algorithm should perform a post processing algorithm
            to reduce perceived bends in the drawing.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseCrossingPostprocessing">
      <summary>If post-processing is used to reduce the number of crossings.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseFaceMaximization">
      <summary>If the layouter should try to maximize one face of the embedding.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseLengthReduction">
      <summary>If the algorithm optimizes over the length of the edges.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseRandomization">
      <summary>If a randomization strategy is used.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseSketchDrawing">
      <summary>If the existing drawing should be used as sketch.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseSpacePostprocessing">
      <summary>If post-processing is used to reduce the space used by the drawing.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Random.RandomLayouter">
      <summary>
            This class generates a layout, where the nodes are placed
            randomly.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Random.RandomLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Random.RandomLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Random.RandomLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns always <see langword="true"></see>, because every graph can be drawn.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Random.RandomLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Perform the layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Random.RandomLayouter.LayoutBounds">
      <summary>The rectangle, inside which the layout should be placed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Random.RandomLayouter.Seed">
      <summary>The radomization seed, with which the layout will be generated.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter">
      <summary>This class represents an edge router.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey">
      <summary>
            This field is used as the key to add a DataProvider to the graph, which specifies the edges, that are affected by
            the edge routing.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.EdgeDistributionStrategy">
      <summary>The currently used edge distribution strategy of this router.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.PathFinderStrategy">
      <summary>The currently used path finder strategy of this router.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder">
      <summary>
            This layouter is a s special version of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            that can be used as a path
            finding strategy in
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.#ctor">
      <summary>Initializes a new instance of the OrthogonalShortestPathPathFinder class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.AffectedEdgesDPKey">
      <summary>The key of a DataProvider that defines the edges, that shall be affected</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see> if the specified core layouter does, and also when there is no core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main entrance to orthogonal edge routing.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelOrientation">
      <summary>Channel orientation specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Vertical">
      <summary>Channel orientation specifier. Used to route edges in a vertical channel.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Horizontal">
      <summary>Channel orientation specifier. Used to route edges in a horizontal channel.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelRouter">
      <summary>
            Class that routes edges within a vertical or horizontal channel
            All edges will then be routed in an orthogonal fashion.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.#ctor(System.Double,System.Double)">
      <summary>Creates a new instance of ChannelRouter for a horizontal channel.</summary>
      <param name="min">the smallest assignable coordinate within the channel</param>
      <param name="max">the largest assignable  coordinate within the channel</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.#ctor(System.Double,System.Double,yWorks.yFiles.Layout.Router.ChannelOrientation)">
      <summary>Creates a new instance of ChannelRouter.</summary>
      <param name="min">the smallest assignable coordinate within the channel</param>
      <param name="max">the largest assignable  coordinate within the channel</param>
      <param name="orientation">
            the direction of the channel. One of
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Vertical"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Horizontal"></see></param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddGroupSegment(System.Object,System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Adds an edge object that belongs to a group of edges
            with source and target coordinates
            to the set of edges that have to be routed within the channel
            Edges sharing the same groupId will be placed on the same channel.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Adds an edge object with source and target coordinates
            to the set of edges that have to be routed within the channel
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.ContainsGroupKey(System.Object)">
      <summary>Determines if the given key has been registered as a grouping key with this instance.</summary>
      <param name="groupKey">
            the key which is used in
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddGroupSegment(System.Object,System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)"></see></param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.ContainsKey(System.Object)">
      <summary>Determines if the given key has been registered already with this instance.</summary>
      <param name="key">
            the key which is used in
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)"></see></param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelRouter.Epsilon">
      <summary>The current epsilon value.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelRouter.EpsilonChannelIgnored">
      <summary>
            Specifies whether subchannels shorter than <c>epsilon</c> are ignored
            by this instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetCoord(System.Object)">
      <summary>Returns the calculated channel coordinate for an added edge object.</summary>
      <param name="key">
            an edge object added with
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)"></see></param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetGroupSubChannelRank(System.Object)">
      <summary>Returns the subchannel rank for the group indicated by the groupKey.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetSubChannelRank(System.Object)">
      <summary>Returns the subchannel rank of this segment within the channel.</summary>
      <param name="key">
            an edge object added with
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)"></see></param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.Route">
      <summary>Routes all added edges within the specified channel.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.SegmentKeys">
      <summary>Returns an iterator over all added segment keys.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.SetChannel(System.Double,System.Double,yWorks.yFiles.Layout.Router.ChannelOrientation)">
      <summary>Sets the channel bounds and direction.</summary>
      <param name="min">the smallest assignable coordinate within the channel</param>
      <param name="max">the largest assignable  coordinate within the channel</param>
      <param name="orientation">
            the orientation of the channel. One of
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Vertical"></see>
            and
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Horizontal"></see></param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelRouter.SubChannelCount">
      <summary>The number of subchannels within this channel.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.CollinearBendHider">
      <summary>Temporarily hides collinear bends on edge paths.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.CollinearBendHider.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.CollinearBendHider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.CollinearBendHider.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.CollinearBendHider.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.CollinearBendHider.SelectedEdgesDpKey">
      <summary>DataProvider key for boolean edge data.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage">
      <summary>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            that adds support for a bus-like routing style.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.MinimalBusDistance">
      <summary>The minimal distance between a bus formed by an edge group and the nodes the grouped edges connect to.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.GroupNodeRouterStage">
      <summary>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            that should be
            applied when routing edges in hierarchically grouped graphs.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.#ctor">
      <summary>Creates a new instance of this class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of this class.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage.
            The coreLayouter must contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            in its layout pipeline.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrganicEdgeRouter">
      <summary>This algorithm routes edges using an organic-like layout approach and style.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.#ctor">
      <summary>
            Creates a new instance of OrganicEdgeRouter with an
            inital minimal distance of 10
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.#ctor(System.Double)">
      <summary>
            Creates a new instance of OrganicEdgeRouter using the given
            initial minimal distance
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage">
      <summary>
            This will return a layout stage which can be given a core layouter, which
            itself should assure that the nodes do not overlap.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.EdgeNodeOverlapAllowed">
      <summary>Specifies whether or not edge-node overlaps are allowed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.MinimalDistance">
      <summary>The minimal distance between nodes and non-incident edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.RouteEdgeDpKey">
      <summary>
            use this key to provide the alogrithm with boolean values for each edge,
            specifying the ones which should be rerouted.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.RoutingAll">
      <summary>
            Specifies whether edges should be rerouted even if they do not obey all
            constraints initially.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.UsingBends">
      <summary>
            Specifies whether given bend coordinates are taken into account when
            determining initial bend positions.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter">
      <summary>This class represents an orthogonal edge router.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.#ctor">
      <summary>Creates a new instance of the Orthogonal Edge Router.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Convenience constructor to simultaneously set a core layout algorithm which will run before the orthogonal edge
            router.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.BadOrthogonal">
      <summary>Specifies whether bad edges should be drawn in an orthogonal fashion.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see> if the specified core layouter does, and also when there is no core layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CenterToSpaceRatio">
      <summary>The currently set ratio between the two complementary weighting strategies center driven and space driven.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CoupledDistances">
      <summary>Specifies whether the minimum distances are coupled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CrossingCost">
      <summary>The cost for each edge crossing of a routed path.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CustomBorderCapacity">
      <summary>The currently set custom value for the capacity of the routing border around the graph's bounding box.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main entrance to orthogonal edge routing.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.GridOrigin">
      <summary>A grid point coordinate used when grid routing is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.GridRouting">
      <summary>Specifies whether or not to route edge segments on grid lines.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.GridSpacing">
      <summary>The grid spacing to be assumed when grid routing is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.InnerPorts">
      <summary>
            Specifies whether edge ports (that do not have a strong port constraint set) should lie inside the node's bounding
            box or on the node's border.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.LocalCrossingMinimization">
      <summary>Specifies whether the local crossing minimization strategy is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MinimumDistance">
      <summary>The minimum distance between edge segments.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MinimumDistanceToNode">
      <summary>The minimum distance between edge segments and nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.Rerouting">
      <summary>Specifies whether rerouting bad edges is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.RoutingStyle">
      <summary>The currently set routing style.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SetGridOrigin(System.Int32,System.Int32)">
      <summary>Sets a grid point coordinate used when grid routing is enabled.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SetProperty(System.String,System.Object)">
      <summary>For internal use only.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SphereOfAction">
      <summary>The currently set sphere of action specifier.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.UseCustomBorderCapacity">
      <summary>Specifies whether a custom value for the capacity of the routing border is used.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter">
      <summary>This class represents an orthogonal edge router.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.AffectedEdgesDpKey">
      <summary>The <c>DataProvider</c> key, which determines the edges, that shall be routed by the algorithm.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.BendCost">
      <summary>The edge cost a bend inside an edge's path will cause.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateBendCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the costs for all bends of the given path by simple multiplicating all bends with the bendcosts.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the costs for all bends of this path</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the edge cost of a possible edge path, to determine which path is the best (cheapest).</summary>
      <param name="edge">the edge whose cost to calculate.</param>
      <param name="path">the edge's path.</param>
      <param name="spc">the source port candidate chosen for this path.</param>
      <param name="tpc">the target port candidate chosen for this path. @return the complete edge cost when choosing this path.</param>
      <returns>the sum of all costs for this edge's path</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCrossingCosts(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Claculates the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateEdgeLength(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the costs for the length of the given path.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the length costs of the given path between 0 and 1</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculatePortCandidateCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the costs for the chosen ports.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the costs for all bends of this path</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateSelfLoopSelfSidePenaltyCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>
            Calculates the extra penalty that is added to the paths cost if the edge is a selfloop and source and target
            ports have the same direction.
            </summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>an extra penalty for paths</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException"></see>
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DefaultAffectedEdgesDpKey">
      <summary>DataProvider key that can be used to determine which edges the edge router will route.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.EdgeCrossingCost">
      <summary>The edge cost an edge crossing will cause.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.EdgeOverlapCost">
      <summary>The cost an edge overlap will cause.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridOrigin">
      <summary>The origin of the grid, which is used for grid routing if enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridRoutingEnabled">
      <summary>Specifies whether or not grid routing is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridWidth">
      <summary>The grid width, that defines the space between two grid lines.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.MinimumDistance">
      <summary>The minimum distance an edge will have to its source and target node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.NodeCrossingCost">
      <summary>The node cost an edge node overlap will cause.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage">
      <summary>This class can be used to distribute overlapping edge segments of orthogonally routed edges.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.AffectedEdgesDpKey">
      <summary>The DataProvider key, which determines the edges, that shall be distributed by the algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.DefaultAffectedEdgesDpKey">
      <summary>DataProvider key that can be used to determine which edges the distribution stage will route.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridEnabled">
      <summary>Specifies whether grid distribution is enabled or not.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridOffsetX">
      <summary>The grid offset in x direction.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridOffsetY">
      <summary>The grid offset in y direction.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridWidth">
      <summary>The grid width that shall be used if grid distribution is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridWidthAdjustable">
      <summary>
            Specifies whether or not the algorithm is allowed to reduce the grid width,
            if segments cannot be distributed using the previously given grid width.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.LockFirstAndLastSegment">
      <summary>Specifies whether the first and last segment of an edge (connected to source or target), will be distributed.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistance">
      <summary>The preferred distance, segments shall have to each other and to the channel's border.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistanceAdjustable">
      <summary>
            What happens if the preferred distance can not be kept, because there is not enough space for the segments
            to be distributed in that distance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOffset(System.Double,System.Double)">
      <summary>Can be used to set the grid origin.</summary>
      <param name="offsetX">the offset in x direction.</param>
      <param name="offsetY">the offset in y direction</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.PatchRouterStage">
      <summary>
            Performance optimization stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PatchRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of PatchRouterStage.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage. The coreLayouter must
            contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            its layout pipline.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.PatchRouterStage.ActivationThreshold">
      <summary>The activation threshold for this class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PatchRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PatchRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns orthogonal edge paths to the edges of a big graph, efficiently.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage">
      <summary>
            Performance optimization stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of ReducedSphereOfActionStage.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage. The coreLayouter must
            contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter"></see>
            its layout pipline.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.ActivationThreshold">
      <summary>The activation threshold for this class.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns orthogonal edge paths to the selected edges of a graph, efficiently.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.RoutingStyle">
      <summary>Routing style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Adhoc">
      <summary>Routing style specifier. Edge segments are drawn ad hoc, i.e., rather crude.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Shortpath">
      <summary>Routing style specifier. Edge segments are drawn the short way, i.e., with the global way of the edge in mind.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Prefermiddle">
      <summary>
            Routing style specifier. Edge segments are drawn with the most distance to already known obstacles such as nodes or
            other edge segments.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage">
      <summary>This LayoutStage will move edge ports, that are outside the corresponding nodes border, to the border.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.SphereOfAction">
      <summary>Sphere of action specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteAllEdges">
      <summary>Sphere of action specifier. Route all edges of the input graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteSelectedEdges">
      <summary>
            Sphere of action specifier. Route only selected edges of the input graph. The selection state of an edge is
            determined by a boolean value returned by the data provider associated with the data provider key
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteEdgesAtSelectedNodes">
      <summary>
            Sphere of action specifier. Route only edges connected to selected nodes. The selection state of a node is
            determined by a boolean value returned by the data provider associated with the data provider key
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedNodesDpKey"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.GraphTransformer">
      <summary>Provides geometric transforms for (sub-)graphs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.#ctor">
      <summary>Creates a new instance of graph transformer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.ApplyBestFitRotationAngle(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
            Performs a rotation of the given graph such that its
            resulting bounding box (approximately) fits best to
            the given area bounds.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">
      <summary>Specifies whether or not the best fit rotation angle will be applied.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns always <see langword="true"></see>.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Performs the selected transformation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.FindBestFitRotationAngle(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
            Returns a rotation angle that, if applied to the given graph,
            would minimize the zoom-level needed to display the graph in
            an area of the given dimension.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.Operation">
      <summary>The transformation operation this layouter performs.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.RotationAngle">
      <summary>The angle of rotation.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleFactor">
      <summary>
            The uniform scaling factor used for the <c>SCALE</c>
            operation.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleFactorX">
      <summary>The scaling factor used for the x-coordinate.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleFactorY">
      <summary>The scaling factor used for the y-coordinate.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleNodeSize">
      <summary>Specifies whether or not to scale node sizes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleToRect(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>
            Scales the coordinates of the given graph in such a way
            that the resulting bounding box of the graph approximately equals
            the bounds of the given rectangle.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetMaximalBounds(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double)">
      <summary>Assures that the given graph fits into the given rectangular bounds.</summary>
      <param name="graph">the graph to modify</param>
      <param name="x">the upper left x coordinate of the bounds</param>
      <param name="y">the upper left y coordinate of the bounds</param>
      <param name="w">the width of the bounds</param>
      <param name="h">the height of the bounds</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetPreferedLayoutSize(System.Double,System.Double)">
      <summary>Sets the preferred layout size for this layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetScaleFactors(System.Double,System.Double)">
      <summary>
            Sets the scaling factors for the x-coordinates and y-coordinates
            used for the <c>SCALE</c> operation.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.Translate(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>Translates the layout coordinates by the vector <c>(dx,dy)</c>.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.GraphZoomer">
      <summary>
            This class contains algorithms which allow for zooming parts of a diagram only
            in a so-called fish-eye (radial) style.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.#ctor">
      <summary>Creates a new instance of GraphZoomer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.AddRadialZoom(yWorks.yFiles.Algorithms.Geometry.YPoint,System.Double,System.Double,System.Double)">
      <summary>
            Adds a zoom operation to the list of operations to be performed on the graph
            during the doLayout phase.
            </summary>
      <param name="center">the center of the zoom</param>
      <param name="innerRadius">
            the radius of the circle around the center inside which the zoom level is
            constantly set to <c>zoomFactor</c></param>
      <param name="outerRadius">
            the radius of the outer circle around the center outside of which the zoomFactor
            should be unchanged. This value must be greater than innerRadius
            </param>
      <param name="zoomFactor">the zoomFactor inside the inner circle</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.AddRectangularZoom(yWorks.yFiles.Algorithms.Geometry.YPoint,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Adds a zoom operation to the list of operations performed during the doLayout
            phase.
            </summary>
      <param name="center">the center of the zoom</param>
      <param name="innerRadius">
            the radius of the rectangular shape around the center inside which the zoom level is
            constantly set to <c>zoomFactor</c></param>
      <param name="outerRadius">
            the radius of the outer rectangular shape around the center outside of which the zoomFactor
            should be unchanged. This value must be greater than innerRadius
            </param>
      <param name="zoomFactor">the zoomFactor inside the inner rectangle</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be layed
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.Zoom(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Transformer.GraphZoomer.IZoom)">
      <summary>Convenience method which applies a custom zoom to the graph</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.ZoomRadial(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>Convenience method which applies a radial zoom to the graph</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.ZoomRectangular(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>Convenience method which applies a rectangular zoom to the graph</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.GraphZoomer.IZoom">
      <summary>This interface can be implemented for custom zoom types.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.IZoom.ModifyPosition(yWorks.yFiles.Util.Geom.Point2D.Double)">
      <summary>
            This method take a Point2D as an argument, modifies it according to its
            zoom policy and writes the modification back to the argument.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.OperationType">
      <summary>Operation type constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.MirrorXaxis">
      <summary>
            Operation type constant. Specifies that the graph should be
            mirrored along the x-axis.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.MirrorYaxis">
      <summary>
            Operation type constant. Specifies that the graph should be
            mirrored along the y-axis.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.Rotate">
      <summary>
            Operation type constant. Specifies that the graph should be
            rotated.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.Scale">
      <summary>
            Operation type constant. Specifies that the graph should be
            scaled.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractNodePlacer">
      <summary>
            Utility class that serves as a basis for implementations of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.#ctor">
      <summary>Creates a new instance of AbstractNodePlacer</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.Clone">
      <summary>Overwritten to support cloning.</summary>
      <returns>an exact copy of this instance</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter">
      </param>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures and then uses the
            abstract method to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.GetNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that queries the DataProvider for the shape of a single
            node as a SubtreeShape instance.
            </summary>
      <param name="node">the node whose shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.GetSubtreeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Convenience method that queries the DataProvider for a SubtreeShape.</summary>
      <param name="node">the root node whose subtree shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.graph">
      <summary>The graph instance this class is working on</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>
            This method initializes the local data structures and then delegates the work
            to the abstract variant.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer">
      <summary>
            This is an abstract base class for NodePlacers that supports rotations.<br></br>
            "Supporting rotation" means that the NodePlacers only implement the default direction (e.g.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Default constructor.</summary>
      <param name="modificationMatrix">the translation for the NodePlacer</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateComparator"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.createdChildren">
      <summary>List containing the created children</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter">
      </param>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateRootNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Convenience method that queries the DataProvider for the shape of a single node as a SubtreeShape instance.</summary>
      <param name="node">the node whose shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateSubtreeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Convenience method that queries the DataProvider for a SubtreeShape.</summary>
      <param name="node">the root node whose subtree shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)"></see>
            to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.GetPortConstraint(yWorks.yFiles.Algorithms.Node)">
      <summary>Lookup method to get the PortConstraint for the local root translated.</summary>
      <param name="localRoot">the local root</param>
      <returns>
            the PortConstraint for the local root. The PortConstraint is translated based on the
            actual modification matrix.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.GetSourcePointAbs(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Translates the absolute source point of the given edge to the "view coordinates" (translated by
            the modification matrix)
            </summary>
      <param name="edge">the source point for is returned</param>
      <returns>the translated absolute source point for the given edge and the actual modification matrix</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.graph">
      <summary>The graph instance this class is working on</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.modificationMatrix">
      <summary>The active modification matrix.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.ModificationMatrix">
      <summary>The actual modification matrix</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.nodeShapeProvider">
      <summary>The actual node shape provider</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>This method initializes the local data structures and then delegates the work to the abstract variant.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Spacing">
      <summary>
            The spacing between subtrees this <c>NodePlacer</c> is
            arranging.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.subtreeShapeProvider">
      <summary>The actual subtree shape provider</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.TranslateDirectionToModel(System.SByte)">
      <summary>Translates a "real" direction into a directionModel direction</summary>
      <param name="realDirection">the "real" direction</param>
      <returns>the translated direction</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.TranslateDirectionToReal(System.SByte)">
      <summary>Translates a modelDirectionModel into the "real" directionModel</summary>
      <param name="modelDirection">the model direction</param>
      <returns>the translated model direction</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.TranslatePoint(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Translates a "real world point" to a "model point"</summary>
      <param name="modificationMatrix">the matrix to apply</param>
      <param name="realWorldPoint">the point with the coords from the real world</param>
      <returns>the model point</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix">
      <summary>
            Instances of this class may be used to configure the
            <see cref="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Available"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Default">
      <summary>no transformation</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.EqualValues(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Compares the values of the actual matrix with the values of the given matrix</summary>
      <param name="result">the given matrix</param>
      <returns>true if all values are the same, false otherwise</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirHor">
      <summary>mirror horizontally</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirHorRot90">
      <summary>mirror horizontally and rotate by 90 degrees counter-clockwise</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirVert">
      <summary>mirror vertically</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirVertRot90">
      <summary>mirror vertically and rotate by 90 degrees counter-clockwise</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Multiply(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Multiplies this matrix with another matrix.</summary>
      <param name="other">the other matrix</param>
      <returns>the product of this and the other matrix</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot180">
      <summary>rotation by 180 degrees</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot270">
      <summary>rotation by 270 degrees counter-clockwise</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot90">
      <summary>rotation by 90 degrees counter-clockwise</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.ToString">
      <summary>Returns a String representation of this matrix.</summary>
      <returns>a String representing this matrix</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment">
      <summary>This class represents the horizontal alignment of the root node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.All"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Center">
      <summary>Horizontal alignment at the center.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.CenterOverChildren">
      <summary>Horizontal alignment at the center.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.GetBounds(yWorks.yFiles.Util.IList)">
      <summary>Calculates the bounds of a list of shapes.</summary>
      <param name="shapes">the list of shapes the bounds shall be calculated of.</param>
      <returns>the bounds around all shapes in the list.</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Leading">
      <summary>Horizontal alignment at the left side of the children</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Left">
      <summary>Horizontal alignment at the left.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Median">
      <summary>Horizontal alignment at the median.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.PlaceParentHorizontal(yWorks.yFiles.Layout.Tree.SubtreeShapeRotated,yWorks.yFiles.Util.IList,yWorks.yFiles.Util.Geom.Rectangle2D,System.Double)">
      <summary>This method moves the rootShape to the right position relative to the children's shapes.</summary>
      <param name="rootShape">the shape of the root node that is moved</param>
      <param name="shapes">list of shapes of the children nodes</param>
      <param name="shapeBounds">cumulated shapes of all children's shapes</param>
      <param name="spacing">the spacing that should be used.</param>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Right">
      <summary>Horizontal alignment at the right.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Trailing">
      <summary>Horizontal alignment at the right side of the children.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ARNodePlacer">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter"></see>
            and implements a
            sophisticated
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.#ctor">
      <summary>
            Creates a new instance of ARNodePlacer with default orientation (vertical),
            aspect ratio (1.0d), fill style (
            <see cref="F:yWorks.yFiles.Layout.Tree.FillStyle.Leading"></see>
            ),
            and default distances (<c>40.0d</c>).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.#ctor(System.Boolean,System.Double,yWorks.yFiles.Layout.Tree.FillStyle,System.Double,System.Double)">
      <summary>
            Creates a new instance of ARNodePlacer with given orientation
            and distances.
            </summary>
      <param name="horizontal">
        <see langword="true">
        </see> for horizontal row mode</param>
      <param name="horizontalDistance">horizontal distance between adjacent elements</param>
      <param name="verticalDistance">vertical distance between adjacent elements</param>
      <param name="aspectRatio">the aspectRatio, this instance should try to obey</param>
      <param name="fillStyle">a fill style constant describing the node distribution</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.AspectRatio">
      <summary>The preferred aspect ratio.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.FillStyle">
      <summary>The fill style.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.Horizontal">
      <summary>
            Specifies whether this instance is configured to create horizontal
            rows of child nodes.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.HorizontalDistance">
      <summary>
            The horizontal distance this NodePlacer should use for the
            arrangement of the elements.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.VerticalDistance">
      <summary>
            The vertical distance this NodePlacer should use for the
            arrangement of the elements.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ARTreeLayouter">
      <summary>
            This tree layouter tries to generate compact tree layouts with a certain aspect
            ratio.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.#ctor">
      <summary>Initializes a new instance of the ARTreeLayouter class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.AspectRatio">
      <summary>The preferred aspect ratio for this <c>ARTreeLayouter</c>.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.BendDistance">
      <summary>The preferred distance between any two bends of an edge.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>The core layouter can layout trees.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.Comparator">
      <summary>
            The
            <see cref="T:System.Collections.IComparer"></see>
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.CreateBends(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object,System.Object)"></member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetAspectRatio(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the aspectRatio that should be used for the subtree starting
            at the given node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetRootPlacement(System.Object)">
      <summary>Returns the desired placement for the given subtree root.</summary>
      <param name="root">the subtree root.</param>
      <returns>
            a symbolic constant representing the desired placement for the
            given subtree root.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetRoutingPolicy(System.Object)">
      <summary>
            Returns the routing policy used by this <c>ARTreeLayouter</c> for
            the given subtree root.
            </summary>
      <param name="root">the subtree root.</param>
      <returns>the routing policy used for the given subtree root.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetSuccessors(yWorks.yFiles.Algorithms.Node)"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.graph"></member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.HorizontalSpace">
      <summary>The horizontal distance between adjacent nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCorner">
      <summary>A data provider value used to specify the placement of the root.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerSide">
      <summary>A data provider value used to specify the placement of the root.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerTop">
      <summary>A data provider value used to specify the placement of the root.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementTop">
      <summary>A data provider value used to specify the placement of the root.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RatioDpkey">
      <summary>The data provider key used to specify target aspect ratio.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RootPlacement">
      <summary>The desired placement of the tree's root node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RootPlacementDpkey">
      <summary>The data provider key used to specify the placement of each subtree root.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingHorizontal">
      <summary>A data provider value used to specify the routing policy of each subtree.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingPolicy">
      <summary>The routing policy used by this <c>ARTreeLayouter</c>.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingPolicyDpkey">
      <summary>The data provider key used to specify the routing policy of each subtree root.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingVertical">
      <summary>A data provider value used to specify the routing policy of each subtree.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.VerticalSpace">
      <summary>The vertical distance between adjacent nodes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AssistantPlacer">
      <summary>
            The assistant placer is a NodePlacer that delegates the node placement to two different node placers depending
            on the type of the children.<br></br>
            The type of a child is recognized using a DataProvider providing booleans.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.#ctor">
      <summary>Creates a default instance with horizontal orientation.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates an AssistantPlacer for the given modification matrix.</summary>
      <param name="modificationMatrix">the modification matrix that is used as translation matrix.</param>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AssistantPlacer.AssistantDpKey">
      <summary>
            Contains a boolean for each node whether it is an assistant or not.<br></br>
            True: Is assistant<br></br>
            False: Is not an assistant<br></br></summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AssistantPlacer.ChildNodePlacer">
      <summary>The child node placer for the non-assistant children.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.CreateComparator">
      <summary>
            Returns <see langword="null"></see>, because no suitable comparator exists for this
            node placer.
            </summary>
      <returns>
        <see langword="null">
        </see>, because no suitable comparator exists for this
            node placer.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates a processor that creates a dummy node and changes the edges for the non-assistant children.</summary>
      <param name="layouter">
      </param>
      <param name="graph">
      </param>
      <param name="currentRoot">
      </param>
      <returns>the processor that changes the graph structure suitable for the AssistantPlacer</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>should not be called and throws a IllegalStateException</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Delegates to the the left right placer.</summary>
      <param name="localRoot">
      </param>
      <param name="connectorMap">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.GetNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the subtree shape for the given child node.</summary>
      <param name="node">the child node the subtree shape is returned for.</param>
      <returns>the subtree shape for the given child node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Places the shapes.</summary>
      <param name="nodeShapeProvider">
      </param>
      <param name="subtreeShapeProvider">
      </param>
      <param name="graph">
      </param>
      <param name="localRoot">
      </param>
      <param name="parentConnectorDirection">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>Should not be called - throws IllegalStateException</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AssistantPlacer.Spacing">
      <summary>
            The spacing between subtrees this <c>NodePlacer</c> is
            arranging.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.BalloonLayouter">
      <summary>
            A tree layouter that lays out the subtrees of the tree in a balloon-like
            fashion.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.BalloonLayouter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.AllowOverlaps">
      <summary>Specifies whether or not to allow partially overlapping nodes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CalcAngles(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Calculates the angle wedge that has to be reserved for the subtree rooted
            at the given node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CalcChildArrangement(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Calculates the child nodes arrangement for a given root node of the
            tree.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns true iff the core layouter can layout the given graph structure.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.CompactnessFactor">
      <summary>The compactness factor for this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.Comparator">
      <summary>
            The
            <see cref="T:System.Collections.IComparer"></see>
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.DetermineRoot">
      <summary>
            Determines the root node of
            <see cref="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph"></see>
            according to the chosen root
            node policy.
            </summary>
      <returns>
            the root node of
            <see cref="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph"></see>
            .
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.FromSketchMode">
      <summary>
            Specifies whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the elements of the tree.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.GetInfo(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the NodeInfo object that is associated with the given node
            while the layouter is active.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.GetPreferredChildWedge(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the preferred child wedge angle in degrees that is
            used for the children of the given root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph">
      <summary>The layout graph being acted upon.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.MinimalEdgeLength">
      <summary>
            The minimal edge length that this layouter assigns
            to laid out edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.PreferredChildWedge">
      <summary>The preferred child wedge angle.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.PreferredRootWedge">
      <summary>
            The preferred radial amount in degrees that stay unoccupied
            around the root node of the graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.RootNodePolicy">
      <summary>
            The root node policy that determines which node
            is chosen as (virtual) tree root for the layout process.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.SortChildNodes(yWorks.yFiles.Algorithms.Node)">
      <summary>Sorts the child nodes of the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo">
      <summary>Encapsulates information bound to a node during the algorithm calculates a layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.AngleSum">
      <summary>The sum of all wedge angles</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.dist">
      <summary>the distance of the node to it's root node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.gapAngle">
      <summary>The angle that of the gap that to the wedge of the previous child node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.lowerAngle">
      <summary>The lower angle of the subtree wedge rooted at the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.upperAngle">
      <summary>The upper angle of the subtree wedge rooted at the node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.BusPlacer">
      <summary>
            The BusPlacer is a special NodePlacer that creates a bus where all child nodes and the root node
            are connected to.<br></br>
            The BusPlacer is rotatable using the constructor
            <see cref="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor">
      <summary>Initializes a new instance with the Default matrix.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Initializes a new BusPlacer with the given modification matrix.</summary>
      <param name="modificationMatrix">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.CreateComparator"></member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child"></param>
      <returns>
    <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.South"></see>
  </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)"></see>
            to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>Places the root node and its children</summary>
      <param name="localRoot">
      </param>
      <param name="parentConnectorDirection">
      </param>
      <returns>the created subtree shape</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ChildPlacement">
      <summary>Placement byte constant used for the <c>childPlacement</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.VerticalToLeft">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees vertically beneath each other
            to the left of the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.VerticalToRight">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees vertically beneath each other
            to the right of the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalUpward">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees horizontally next to each other
            above the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalDownward">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees horizontally next to each other
            below the root node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ConnectorDirection">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.North">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.East">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.South">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.West">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DefaultNodePlacer">
      <summary>
            Versatile default implementation of
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor">
      <summary>
            Creates a new DefaultNodePlacer with default alignment (
            <see cref="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center"></see>
            ),
            default child placement (
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalDownward"></see>
            ),
            and default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork"></see>
            ) and a horizontal and vertical distance
            of <c>40.0d</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.ChildPlacement,System.Double,System.Double)">
      <summary>
            Creates a new DefaultNodePlacer with default alignment (
            <see cref="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center"></see>
            )
            and default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork"></see>
            ).
            </summary>
      <param name="childPlacement">placement constant describing the style of the arrangement</param>
      <param name="verticalDistance">
            the vertical distance between the root node and the subtree shapes or between
            subtree shapes in case of vertical child placement
            </param>
      <param name="horizontalDistance">
            the horizontal distance between the root node and the subtree shapes or between
            subtree shapes in case of horizontal child placement
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.ChildPlacement,yWorks.yFiles.Layout.Tree.RootAlignment,System.Double,System.Double)">
      <summary>
            Creates a new DefaultNodePlacer with default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork"></see>
            ).
            </summary>
      <param name="childPlacement">placement constant describing the style of the arrangement</param>
      <param name="rootAlignment">
            alignment constant describing the position of the root nod
            with respect to the subtrees
            </param>
      <param name="verticalDistance">
            the vertical distance between the root node and the subtree shapes or between
            subtree shapes in case of vertical child placement
            </param>
      <param name="horizontalDistance">
            the horizontal distance between the root node and the subtree shapes or between
            subtree shapes in case of horizontal child placement
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.ChildPlacement,yWorks.yFiles.Layout.Tree.RootAlignment,yWorks.yFiles.Layout.Tree.RoutingStyle,System.Double,System.Double)">
      <summary>Creates a new DefaultNodePlacer.</summary>
      <param name="routingStyle">routing style constant</param>
      <param name="childPlacement">placement constant describing the style of the arrangement</param>
      <param name="rootAlignment">
            alignment constant describing the position of the root nod
            with respect to the subtrees
            </param>
      <param name="verticalDistance">
            the vertical distance between the root node and the subtree shapes or between
            subtree shapes in case of vertical child placement
            </param>
      <param name="horizontalDistance">
            the horizontal distance between the root node and the subtree shapes or between
            subtree shapes in case of horizontal child placement
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CalcParentConnector(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.IEdgeLayout,System.SByte)">
      <summary>Calculates the connector the the parent node.</summary>
      <param name="graph">the graph</param>
      <param name="localRoot">
            the root whose connector must be calculated and stored in the
            subtreeShape
            </param>
      <param name="rootLayout">the NodeLayout of the root node</param>
      <param name="subtreeShape">the shape to be used for the connector information</param>
      <param name="parentEdge">
            the edge that will later be routed according to the
            information in the subtreeShape
            </param>
      <param name="parentEdgeLayout">the current EdgeLayout of the edge</param>
      <param name="direction">
            the direction byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface which should be used for
            the connector
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CalcSourceEdgeLayout(yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Performs the routing of the source side of the edge to
            the given child node.
            </summary>
      <param name="rootLayout">the NodeLayout of the local root node</param>
      <param name="childShape">
            the SubtreeShape instance of the corresponding child's
            subtree
            </param>
      <param name="edge">the edge</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CalcTargetEdgeLayout(yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Performs the routing of the target side of the edge to
            the given child node.
            </summary>
      <param name="rootLayout">the NodeLayout of the local root node</param>
      <param name="childShape">
            the SubtreeShape instance of the corresponding child's
            subtree
            </param>
      <param name="edge">the edge</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.ChildPlacement">
      <summary>The child node placement policy.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CreateComparator">
      <summary>
            Returns a Comparator instance that can be used to register with the
            GenericTreeLayouter.
            </summary>
      <returns>
            a Comparator instance that can be used for the current configuration of
            this instance.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.HorizontalDistance">
      <summary>
            The horizontal distance this <c>NodePlacer</c> should use for the
            arrangement of the elements.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.RootAlignment">
      <summary>The root node alignment policy.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.RoutingStyle">
      <summary>The current routing style byte constant.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.VerticalDistance">
      <summary>
            The vertical distance this NodePlacer should use for the
            arrangement of the elements.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DefaultPortAssignment">
      <summary>This class provides simple default port assignment strategies.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.#ctor">
      <summary>
            Creates a new DefaultPortAssignment instance using mode
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.#ctor(yWorks.yFiles.Layout.Tree.PortAssignmentMode)">
      <summary>Creates a new DefaultPortAssignment instance using the given mode.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,System.Int32)">
      <summary>This method assigns the source port of an edge that goes to a child node.</summary>
      <param name="graph">the graph which contains the node</param>
      <param name="node">the parent node</param>
      <param name="edge">the edge to the child node</param>
      <param name="index">the zero-based index of the child edge</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.AssignParentEdgeTargetPort(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>This method assigns the target port of the edge that goes to the parent node.</summary>
      <param name="graph">the graph which contains the node</param>
      <param name="node">the node</param>
      <param name="edge">the edge to the parent node</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter"></see>
            before the actual layout
            of the graph takes place.
            </summary>
      <param name="graph">the graph instance the node is part of</param>
      <param name="node">the node whose adjacent edges' ports should be set</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.GetSourcePortConstraint(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Int32)">
      <summary>
            Returns the PortConstraint for the given edge or <see langword="null"></see> if no
            PortConstraint is set.
            </summary>
      <param name="graph">the graph the edge is part of</param>
      <param name="edge">the edge whose PortConstraint is to be determined</param>
      <param name="index">the child's index</param>
      <returns>a PortConstraint or <see langword="null"></see></returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.GetTargetPortConstraint(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the PortConstraint for the given edge or <see langword="null"></see> if no
            PortConstraint is set.
            </summary>
      <param name="graph">the graph the edge is part of</param>
      <param name="edge">the edge whose PortConstraint is to be determined</param>
      <returns>a PortConstraint or <see langword="null"></see></returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.Mode">
      <summary>The port assignment mode.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer">
      <summary>
            The DelegatingNodePlacer may be used to layout the children of the actual
            node with two different <c>NodePlacer</c>s.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,yWorks.yFiles.Layout.Tree.INodePlacer,yWorks.yFiles.Layout.Tree.INodePlacer)">
      <summary>Creates a new instance using the given modification matrix an the node placers "this" delegates to.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a processor that partitions child nodes of the specified root node
            into two subsets, one to be arranged by the "upper left"
            <c>NodePlacer</c> and one to be arranged by the "lower right"
            <c>NodePlacer</c>.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)"></see>
            to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetLowerRightChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines the lower right children of the specified root node.</summary>
      <returns>a NodeList containing the lower right nodes.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetUpperLeftChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines the upper left children of the specified root node.</summary>
      <returns>a NodeList containing the upper left nodes.</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.Horizontal">
      <summary>Orientation specifier.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.Orientation">
      <summary>
            The orientation according to which node shapes are aligned by
            this placer.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlacerLowerRight">
      <summary>
            The <c>NodePlacer</c> that is used to layout the nodes on
            the "lower right"
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlacerUpperLeft">
      <summary>
            The <c>NodePlacer</c> that is used to layout the nodes on
            the "upper left"
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>
            Places the shapes of the children using the two node placers
            <see cref="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetUpperLeftChildren(yWorks.yFiles.Algorithms.Node)"></see>
            and
            <see cref="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetLowerRightChildren(yWorks.yFiles.Algorithms.Node)"></see>
            .
            </summary>
      <returns>the subtree shape for the given local root.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DendrogramPlacer">
      <summary>
            This is an implementation of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface that
            can be used to create dendrogram-like tree layouts.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.DendrogramPlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.CreateComparator">
      <summary>Creates a comparator that can be used to do a from sketch layout.</summary>
      <returns>the comparator implementation to use to simulate from sketch layout</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter">
      </param>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            </summary>
      <param name="localRoot">
            the local root node whose child nodes will be provided with
            a byte constant indicating the direction of the connector
            </param>
      <param name="connectorMap">
            the map that should be used for storing the byte constant
            with the child nodes.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DendrogramPlacer.MinimumRootDistance">
      <summary>The distance between the root shape and the bus connecting all of its subtrees.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DendrogramPlacer.MinimumSubtreeDistance">
      <summary>The distance between two adjacent subtree shapes.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main method of the tree layout algorithm.</summary>
      <param name="nodeShapeProvider">
            this instance can be used to obtain an initial shape
            of the root node. This shape can then be merged with all the subtrees' shapes
            and finally be returned by this method.
            </param>
      <param name="subtreeShapeProvider">
            provides access to the pre-calculated shapes of
            the subtrees. It is guaranteed that at the time of the invocation of this
            method for every child node the subtree shape has already been calculated
            </param>
      <param name="graph">the graph which is to be laid out</param>
      <param name="localRoot">the root of the subtree that should be laid out by this method</param>
      <param name="parentConnectorDirection">
            the direction byte constant as it is defined
            in this interface, that must be used for initializing the connector of the
            localRoot node to the parent node of the localRoot node
            </param>
      <returns>the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DoubleLinePlacer">
      <summary>
            The DoubleLinePlacer is a special node placer that places its children in
            two lines.<br></br>
            This node placer is especially useful for leaves with great width.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.#ctor">
      <summary>Creates a new DoubleLinePlacer with the default modification matrix.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates a new DoubleLinePlacer with the given modification matrix.</summary>
      <param name="modificationMatrix">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns
            <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North"></see></summary>
      <param name="child">
      </param>
      <returns>
        <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North">
        </see>
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>Places the subtree in two lines.</summary>
      <param name="localRoot">
      </param>
      <param name="parentConnectorDirection">
      </param>
      <returns>the subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.RootAlignment">
      <summary>The horizontal alignment that is used for the root node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle">
      <summary>Layout style constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle.Plain">
      <summary>Layout style constant. Draw edges as straight lines.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle.Orthogonal">
      <summary>Layout style constant. Draw edges orthogonally in a bus-like fashion.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.FillStyle">
      <summary>Byte constant that can be used for the <c>fillStyle</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Leading">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be aligned with the leading edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Centered">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be centered with the bounds.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Justify">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be justified with the bounds.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Trailing">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be aligned with the trailing edge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.FreePlacer">
      <summary>Placer that can be used as simple "pseudo"-placer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.#ctor">
      <summary>Creates a new instance with the default matrix.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a processor suitable to the FreePlacer.<br></br>
            This processor will change all descendants node placers to FreePlacer.
            </summary>
      <param name="layouter">
      </param>
      <param name="graph">
      </param>
      <param name="currentRoot">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child"></param>
      <returns>
    <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.None"></see>
  </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>Creates the subtree shape</summary>
      <param name="localRoot">
      </param>
      <param name="parentConnectorDirection">
      </param>
      <returns>the created subtree shape</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter">
      <summary>This class implements the basis of a generic tree layout algorithm.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.#ctor">
      <summary>
            Creates a new GenericTreeLayouter with a default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            , a default
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment"></see>
            instance and
            no default edge comparator.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.ChildComparatorDpKey">
      <summary>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:System.Collections.IComparer"></see>
            instance that will be used to sort its outgoing edges.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultChildComparator">
      <summary>
            The default
            <see cref="T:System.Collections.IComparer"></see>
            instance or <see langword="null"></see> that will be used for those subtrees, that
            don't have their own specific instance set via the appropriate DataProvider.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultLeafPlacer">
      <summary>
            The default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            instance that will be used for the leaf nodes of the tree.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultNodePlacer">
      <summary>
            The default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            instance that will be used for those subtrees, that don't haver their own
            specific instance set via the appropriate DataProvider.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultPortAssignment">
      <summary>
            The default
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment"></see>
            instance that will be used for those subtrees, that don't haver their
            own specific instance set via the appropriate DataProvider.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DirectTree">
      <summary>This method is called initially with the graph to calculate a rooted tree.</summary>
      <returns>an EdgeList containing all the edges that need to be reversed</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetChildNodeInEdgeComparator(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method returns a
            <see cref="T:System.Collections.IComparer"></see>
            instance or <see langword="null"></see> that will be used for the sorting of the
            outgoing edges at the given Node.
            </summary>
      <param name="localRoot">the root of the local subtree</param>
      <returns>
            a readily configured instance of
            <see cref="T:System.Collections.IComparer"></see>
            or <see langword="null"></see> that can be used sort the outgoing
            edges of the given node
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetNodePlacer(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method returns a
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            instance that will be used for the placement of the root node and the
            subtree shapes.
            </summary>
      <param name="localRoot">the root of the local subtree</param>
      <returns>
            a readily configured instance of
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            that can be used to layout the subtree under the given
            local root node.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Factory method that creates a SubtreeShape for a given node, that consists of the bounds of the node only.</summary>
      <param name="node">the node that will be represented by a SubTreeShape instance</param>
      <returns>a newly created SubtreeShape describing the bounds of the given node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetPortAssignment(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method returns a
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment"></see>
            instance that will be used for the port assignments at the given Node.
            </summary>
      <param name="localRoot">the root of the local subtree</param>
      <returns>
            a readily configured instance of
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment"></see>
            that can be used to assign the ports of the edges
            at the given local root node.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetRootsArray(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the array of the nodes to be laid out.</summary>
      <param name="root">the node that should be used as the root of the tree</param>
      <returns>all nodes in the graph that should be laid out in order</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetSubtreeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Provides access to the SubTreeShape instances for each node.</summary>
      <param name="localRoot">the node for which the subtree should be returned</param>
      <returns>the SubTreeShape instance if it has been calculated already or <see langword="null"></see> otherwise</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.graph">
      <summary>the graph this layout is running on</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GroupingSupported">
      <summary>True if grouping support is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.IntegratedEdgeLabeling">
      <summary>
            Specifies whether integrated edge labeling is enabled (extension of the
            shapes of subtrees with the labels of the edges).
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.IntegratedNodeLabeling">
      <summary>
            Specifies whether intergrated node labeling is enabled (extension of the
            shapes of the nodes with its labels).
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.LayoutRoot(yWorks.yFiles.Algorithms.Node)">
      <summary>This is the core method of the algorithm.</summary>
      <param name="localRoot">The root to be laid out together with its SubtreeShapes</param>
      <returns>the combined SubtreeShape of the local root node and all of its children and connecting edges</returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.NodePlacerDpKey">
      <summary>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            instance.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.PortAssignmentDpKey">
      <summary>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment"></see>
            instance.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.ReverseEdges(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method is used for the actual reversal of edges.</summary>
      <param name="reversedEdges">the edges that will be reversed by this method</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SourcePortConstraintDataAcceptor">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor"></see>
            implementation
            that can be used to overwrite the source port constraint (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            temporarily for use during the layout.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.TargetPortConstraintDataAcceptor">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor"></see>
            implementation
            that can be used to overwrite the target port constraint (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint"></see>
            temporarily for use during the layout.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape">
      <summary>Instances of this class are used to represent the shape of subtrees during the layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddBoundsToShape(System.Double,System.Double,System.Double,System.Double)">
      <summary>Adds a rectangular shape to the current shape.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddEdgeSegments(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Helper method that takes all edge segments of the given Edge instance and updates the shape bounds with that
            information.
            </summary>
      <param name="lg">the LayoutGraph that contains the edge</param>
      <param name="e">the edge whose path will be used to update the shape</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddLineSegment(System.Double,System.Double,System.Double,System.Double)">
      <summary>Convenience method that updates the shape to respect the given line segment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddTargetPoint(System.Double,System.Double)">
      <summary>Adds another point to the connecting edge (away from the target node).</summary>
      <param name="x">the current x coordinate of the point</param>
      <param name="y">the current x coordinate of the point</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AppendTargetPoints(yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Appends all target points that have previously been added to this shape to the given EdgeLayout instance.</summary>
      <param name="el">the EdgeLayout that will be modified</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AssignValuesTo(yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Copies this instance to another shape, applying a modification matrix.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.Bounds">
      <summary>The current bounds of this SubtreeShape</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection">
      <summary>
            The direction byte constant as defined in this class, that indicates the direction of the last connecting
            edge segment.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorX">
      <summary>
            The current x coordinate of the connection point where the layout algorithm should connect the ingoing
            edge to.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorY">
      <summary>
            The current y coordinate of the connection point where the layout algorithm should connect the ingoing
            edge to.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.CoreBounds">
      <summary>
            Yields the bounds of the
            <see cref="T:yWorks.yFiles.Layout.INodeLayout"></see>
            of the root node.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.CreateCopy(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates a clone of this instance, modifying it using the provided matrix.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.GetBorderLine(System.Int32)">
      <summary>Returns the BorderLine instance for the given direction.</summary>
      <param name="index">
            the direction index either one of the byte constants defined in this class, or 0 to 3, where 0 is
            north and 3 is west
            </param>
      <returns>
            the current
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.BorderLine"></see>
            instance
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MaxX">
      <summary>The current maximum x coordinate of this shape.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MaxY">
      <summary>The current maximum y coordinate of this shape.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MergeWith(yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape)">
      <summary>Merges the given SubtreeShape with this shape's bounds.</summary>
      <param name="other">the shape to be merged with this shape</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MinX">
      <summary>The current minimal x coordinate of this shape.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MinY">
      <summary>The current minimal y coordinate of this shape.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.Move(System.Double,System.Double)">
      <summary>Moves this shape and its connector by the given offsets.</summary>
      <param name="dx">the delta x offset this shape will be moved by</param>
      <param name="dy">the delta y offset this shape will be moved by</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.OriginX">
      <summary>The current x coordinate of the origin of this shape.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.OriginY">
      <summary>The current y coordinate of the origin of this shape.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.UpdateConnectorShape">
      <summary>Adds the line segments of the connector shape to the bounds and borderlines of this SubTreeShape</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.HVTreeLayouter">
      <summary>
            This tree layouter allows to layout a tree such that
            each subgraph rooted at a node can either have a horizontal or
            vertical layout.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.HVTreeLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>The core layouter can layout trees.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.HVTreeLayouter.Comparator">
      <summary>
            The
            <see cref="T:System.Collections.IComparer"></see>
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.GetSuccessors(yWorks.yFiles.Algorithms.Node)"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.graph">
      <summary>The layout graph being acted upon.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.HVTreeLayouter.HorizontalSpace">
      <summary>The horizontal distance between adjacent nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.HorizontalSubtree">
      <summary>Subtree orientation specifier.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.IsHorizontalRoot(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the subtree rooted at the given node should
            be laid out horizontally.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.IsVerticalRoot(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the subtree rooted at the given node should
            be laid out vertically.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.SubtreeOrientationDpkey">
      <summary>
            The data provider key used to specify the subtree orientation
            of each node in the tree.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.HVTreeLayouter.VerticalSpace">
      <summary>The vertical distance between adjacent nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.VerticalSubtree">
      <summary>Subtree orientation specifier.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.INodePlacer">
      <summary>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.INodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter">
      </param>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.INodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            </summary>
      <param name="localRoot">
            the local root node whose child nodes will be provided with
            a byte constant indicating the direction of the connector
            </param>
      <param name="connectorMap">
            the map that should be used for storing the byte constant
            with the child nodes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main method of the tree layout algorithm.</summary>
      <param name="nodeShapeProvider">
            this instance can be used to obtain an initial shape
            of the root node. This shape can then be merged with all the subtrees' shapes
            and finally be returned by this method.
            </param>
      <param name="subtreeShapeProvider">
            provides access to the pre-calculated shapes of
            the subtrees. It is guaranteed that at the time of the invocation of this
            method for every child node the subtree shape has already been calculated
            </param>
      <param name="graph">the graph which is to be laid out</param>
      <param name="localRoot">the root of the subtree that should be laid out by this method</param>
      <param name="parentConnectorDirection">
            the direction byte constant as it is defined
            in this interface, that must be used for initializing the connector of the
            localRoot node to the parent node of the localRoot node
            </param>
      <returns>the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.IPortAssignment">
      <summary>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter"></see>
            .
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.IPortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter"></see>
            before the actual layout
            of the graph takes place.
            </summary>
      <param name="graph">the graph instance the node is part of</param>
      <param name="node">the node whose adjacent edges' ports should be set</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.IProcessor">
      <summary>
            A processor is the possibility for each NodePlacer to prepare (and clean up) the graph for its children.<br></br>
            It is created within
            <see cref="M:yWorks.yFiles.Layout.Tree.INodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)"></see>
            and called by the
            GenericTreeLayouter at specific positions of the life-cycle.<br></br>
            The processor may change the values within the DataMaps for its children.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.IProcessor.PostProcess">
      <summary>This method is called from the GenericTreeLayouter after the layout has finished.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.IProcessor.PreProcess(yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>This method is called before the NodePlacers are called recursively.</summary>
      <param name="nodePlacerDataProvider">
      </param>
      <param name="portAssignmentDataProvider">
      </param>
      <param name="childComparatorProvider">
      </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LayeredNodePlacer">
      <summary>This NodePlacer calculates and respects layers.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.LayeredNodePlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,System.Object)">
      <summary>Default constructor.</summary>
      <param name="modificationMatrix">the translation for the NodePlacer</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.BusAlignment">
      <summary>The actual set bus alignment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an processor that distributes the LayerRoot</summary>
      <param name="layouter">
      </param>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer"></see>
            interface
            </returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.DistanceToParentMapDpKey">
      <summary>References a NodeMap that contains double values.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.Id">
      <summary>The ID.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.LayerSpacing">
      <summary>The spacing between two layers.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.PolylineLabelingEnabled">
      <summary>Specifies whether polyline labeling is used.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.RootAlignment">
      <summary>The alignment strategy for the tree's root node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.RoutingStyle">
      <summary>The routing style.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.VerticalAlignment">
      <summary>The vertical alignment.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle">
      <summary>Layout style constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle.Plain">
      <summary>Layout style constant. Draw edges as straight lines.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle.Orthogonal">
      <summary>Layout style constant. Draw edges orthogonally in a bus-like fashion.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LeafPlacer">
      <summary>This implementation can be used to "place" leafs.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.LeafPlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter">
      </param>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            </summary>
      <param name="localRoot">
            the local root node whose child nodes will be provided with
            a byte constant indicating the direction of the connector
            </param>
      <param name="connectorMap">
            the map that should be used for storing the byte constant
            with the child nodes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main method of the tree layout algorithm.</summary>
      <param name="nodeShapeProvider">
            this instance can be used to obtain an initial shape
            of the root node. This shape can then be merged with all the subtrees' shapes
            and finally be returned by this method.
            </param>
      <param name="subtreeShapeProvider">
            provides access to the pre-calculated shapes of
            the subtrees. It is guaranteed that at the time of the invocation of this
            method for every child node the subtree shape has already been calculated
            </param>
      <param name="graph">the graph which is to be laid out</param>
      <param name="localRoot">the root of the subtree that should be laid out by this method</param>
      <param name="parentConnectorDirection">
            the direction byte constant as it is defined
            in this interface, that must be used for initializing the connector of the
            localRoot node to the parent node of the localRoot node
            </param>
      <returns>the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LeftRightPlacer">
      <summary>The LeftRightPlacer is a NodePlacer that arranges the Nodes on the left and right side of a vertical bus.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.#ctor">
      <summary>Creates a LeftRightPlacer with the default modificationMatrix</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates a LeftRightPlacer with the given modificationMatrix</summary>
      <param name="modificationMatrix">
      </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.CreateComparator">
      <summary>Returns null because no comparator exists for the node placer.</summary>
      <returns>null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child"></param>
      <returns>Should not be reached, throws IllegalStateException</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Determines the direction the children should place their connectors.</summary>
      <param name="localRoot">
      </param>
      <param name="connectorMap">
      </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LeftRightPlacer.PlaceLastOnBottom">
      <summary>Specifies whether the last child is placed at the bottom of the other.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>Places the shapes of the children on the left and right side of a vertical bus.</summary>
      <param name="localRoot">
      </param>
      <param name="parentConnectorDirection">
      </param>
      <returns>the new subtree shape</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.NodeOrderComparator">
      <summary>
            This comparator compares edges by examining the
            <see cref="T:System.IComparable"></see>
            that is obtained by passing the
            <see cref="P:yWorks.yFiles.Algorithms.Edge.Target">target nodes</see>
            to
            the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)">get method</see>
            of the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            bound to the graph via the
            <see cref="F:yWorks.yFiles.Layout.Tree.NodeOrderComparator.NodeOrderDpKey"></see>
            key.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.NodeOrderComparator.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.NodeOrderComparator" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.NodeOrderComparator.Compare(System.Object,System.Object)">
      <summary>
            Object is actually expected to be
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.NodeOrderComparator.NodeOrderDpKey">
      <summary>
            A data provider key that can be used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider"></see>
            for each
            <see cref="T:yWorks.yFiles.Algorithms.Node"></see>
            in the graph that yields a
            <see cref="T:System.IComparable"></see>
            object
            via the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)"></see>
            method.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.Orientation">
      <summary>Orientation specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.Orientation.Vertical">
      <summary>Orientation specifier. Node shapes will be aligned on the y-axis.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ParentConnectorDirection"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.None">
      <summary>
            Byte constant that is as argument to the main method, indicating that no connector
            should be calculated.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.Any">
      <summary>
            Byte constant that is an argument to the main method, indicating that any connector
            direction can be used for the connection to the parent node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into north direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.East">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into east direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.South">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into south direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.West">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into west direction.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.PortAssignmentMode"></member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.PortConstraint">
      <summary>
            Mode constant describing the strategy where edges having
            <ul><li>
            a weak port constraint, i.e., effectively a side constraint, will be anchored
            at the center of that side
            </li><li>
            no port constraint set will be anchored at the center of the node
            </li></ul>
            Edges having a strong port constraint are anchored at that coordinates.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node">
      <summary>
            Mode constant describing the strategy where all ports are reset to the center
            of their nodes.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.PortStyle">
      <summary>Port style constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortStyle.NodeCenter">
      <summary>Port style constant. Uses (0,0) as port offset.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortStyle.BorderCenter">
      <summary>
            Port style constant. Ports will lie at the center
            of a node border.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortStyle.BorderDistributed">
      <summary>
            Port style constant. Ports will be distributed
            evenly on the side of a node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.RootAlignment">
      <summary>Alignment byte constant used for the <c>rootAlignment</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.LeadingOffset">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root ahead of all the child subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Leading">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root with the first of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root at the center of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Median">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root at the median of the connection points to its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Trailing">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root at with the last of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.TrailingOffset">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root after all of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.TrailingOnBus">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root after all of its subtrees and centered on the bus.
            Note: The vertical/horizontal distance between the root node and the subtree shapes depend on the value
            of parameters verticalDistance/horizontalDistance passed to the Constructor.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.LeadingOnBus">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root ahead of all the child subtrees and centered on the bus.
            Note: The vertical/horizontal distance between the root node and the subtree shapes depend on the value
            of parameters verticalDistance/horizontalDistance passed to the Constructor.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.RootNodePolicy">
      <summary>Root node policy specifier constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.DirectedRoot">
      <summary>
            Root node policy specifier constant. A node with indegree 0
            is chosen as root node of the tree. If no node with that property
            is present the an arbitrary node is chosen.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.CenterRoot">
      <summary>
            Root node policy specifier constant. A center node
            will be chosen as root node of the tree.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.WeightedCenterRoot">
      <summary>
            Root node policy specifier constant. A weighted center node
            will be chosen as root node of the tree.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.RoutingStyle">
      <summary>Routing style byte constant used for the <c>routingStyle</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in orthogonally routed child node
            connectors where the bends are placed in the channel between the
            root node and the child nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.ForkAtRoot">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in orthogonally routed child node
            connectors with one bend each placed next to the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Straight">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in straight connections to the child nodes.
            Edges may overlap nodes in this case.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.PolyLine">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in straight connections to the connector of the subtree.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.SimpleNodePlacer">
      <summary>This is a "default" NodePlacer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.#ctor">
      <summary>
            Default constructor that creates an instance with the modification matrix
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Default"></see></summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Constructor that creates an instance with the given modification matrix.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment)">
      <summary>Constructor that creates an instance with the given modification matrix and the horizontal root alignment</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.CreateBus">
      <summary>Specifies whether a bus should be created between the parent and its children.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns
            <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North"></see>
            .
            </summary>
      <returns>
        <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North">
        </see>
            .
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,System.SByte)">
      <summary>Places the children in a single row.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.RootAlignment">
      <summary>The horizontal alignment of the root node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.SubtreeShapeRotated">
      <summary>Decorates a SubtreeShape and provides rotated access on it.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SubtreeShapeRotated.#ctor">
      <summary>For testing purposes only</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.TreeComponentLayouter">
      <summary>
            This stage can be used to do mix layouts for tree-like subgraph structures and
            the non-tree like rest of a graph.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of TreeComponentLayouter using the specified
            layouter for layouting the subtrees.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true"></see> iff the given graph can be layed
            out by this algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayoutUsingDummies(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Called by
            <see cref="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)"></see>
            to delegate to the
            <see cref="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CoreLayouter"></see>
            , adding the dummy provider to the graph instance.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DummyNodeDpKey">
      <summary>
            During the mainrun of the layout dummy nodes can be identified by looking
            at the value of the registered DataProvider which can be obtained from
            the graph using this key.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.OrientationOptimizationActive">
      <summary>
        <see langword="true">
        </see> if this layouter tries to improve tree component
            placement by changing the components orientation and <see langword="false"></see>
            otherwise.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.TreeComponentCoreLayouter">
      <summary>The core layouter used for tree components.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.TreeLayouter">
      <summary>Implementation of a layout algorithm for trees.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeLayouter.#ctor">
      <summary>Creates a new instance of TreeLayouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.BusAlignment">
      <summary>The actual set bus alignment.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns true iff the core layouter can layout the given
            graph structure.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.Comparator">
      <summary>
            The comparator for outgoing edges at a node
            This comparator defines the relative order
            of the child nodes in the layout to be calculated.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Starts the tree layout process</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.GroupingSupported">
      <summary>True if grouping support is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.IntegratedNodeLabeling">
      <summary>Specifies whether integrated node labeling is enabled.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.LayoutStyle">
      <summary>The layout style of this layouter.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.MinimalLayerDistance">
      <summary>The minimal distance between adjacent layers for the layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.MinimalNodeDistance">
      <summary>
            The minimum horizontal distance between adjacent nodes
            for this layouter.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.ModificationMatrix">
      <summary>The modification matrix that is used to rotate / mirror the tree layout.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.PortStyle">
      <summary>The port assignment style.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.VerticalAlignment">
      <summary>The vertical alignment.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.TreeReductionStage">
      <summary>
            This stage can be used to layout non-tree structures with a
            tree layout algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.TreeReductionStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true"></see>.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.CreateStraightlineRouter">
      <summary>
            Creates a layouter that can be used to route all non-tree edges
            as a single straight-line segment.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter">
      <summary>The currently set edge router for non-tree edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgesDpKey">
      <summary>
            Dataprovider key that can be used to explicitly mark (some) edges
            that should not be considered to belong to a tree.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgeSelectionKey">
      <summary>The currently set non-tree edge selection key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.RouteNonTreeEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Routes the non-tree edges.</summary>
      <param name="graph">graph that can contain tree and non-tree edges.</param>
      <param name="nonTreeEdgeMap">
            an edge map that marks all non-tree edges
            in the graph with boolean value <see langword="true"></see>.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.XCoordComparator">
      <summary>
            This comparator compares edges by examining the x-coordinates of the centers
            of their target nodes.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.XCoordComparator.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.XCoordComparator" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.XCoordComparator.Compare(System.Object,System.Object)">
      <summary>
            Object is actually expected to be
            <see cref="T:yWorks.yFiles.Algorithms.Edge"></see>
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Util.ICollection">
      <summary>Collection is the root of the collection hierarchy.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Add(System.Object)">
      <summary>
            Attempts to add <c>object</c> to the contents of this
            <c>Collection</c>.
            </summary>
      <param name="object">the object to add</param>
      <returns>
        <see langword="true">
        </see> if this <c>Collection</c> is
            modified, <see langword="false"></see> otherwise
            </returns>
      <exception cref="T:System.NotSupportedException">when adding to this Collection is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of the object is inappropriate for this
            Collection
            </exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to this Collection</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Attempts to add all of the objects contained in <c>collection</c>
            to the contents of this collection.
            </summary>
      <param name="collection">the Collection of objects</param>
      <returns>true if this Collection is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when adding to this Collection is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of an object is inappropriate for this
            Collection
            </exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this Collection</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Clear">
      <summary>Removes all elements from this Collection, leaving it empty.</summary>
      <exception cref="T:System.NotSupportedException">when removing from this Collection is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Contains(System.Object)">
      <summary>Searches this Collection for the specified object.</summary>
      <param name="object">the object to search for</param>
      <returns>true if object is an element of this Collection, false otherwise</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.ContainsAll(yWorks.yFiles.Util.ICollection)">
      <summary>Searches this Collection for all objects in the specified Collection.</summary>
      <param name="collection">the Collection of objects</param>
      <returns>
            true if all objects in the specified Collection are elements of
            this Collection, false otherwise
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.ICollection.Count">
      <summary>A count of how many objects are contained by this collection.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.ICollection.Empty">
      <summary>Answers if this Collection has no elements, a size of zero.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Equals(System.Object)">
      <summary>
            Compares the argument to the receiver, and answers true if they represent
            the <em>same</em> object using a class specific comparison.
            </summary>
      <param name="object">Object the object to compare with this object.</param>
      <returns>
            boolean <see langword="true"></see> if the object is the same as this
            object <see langword="false"></see> if it is different from this object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.GetHashCode">
      <summary>Answers an integer hash code for the receiver.</summary>
      <returns>the receiver's hash</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Iterator">
      <summary>
            Returns an instance of
            <see cref="T:yWorks.yFiles.Util.IIterator"></see>
            that may be used to access the
            objects contained by this collection.
            </summary>
      <returns>an iterator for accessing the collection contents</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Remove(System.Object)">
      <summary>
            Removes the first occurrence of the specified object from this
            Collection.
            </summary>
      <param name="object">the object to remove</param>
      <returns>true if this Collection is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this Collection is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Removes all occurrences in this Collection of each object in the
            specified Collection.
            </summary>
      <param name="collection">the Collection of objects to remove</param>
      <returns>true if this Collection is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this Collection is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.RetainAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Removes all objects from this Collection that are not also found in the
            contents of <c>collection</c>.
            </summary>
      <param name="collection">the Collection of objects to retain</param>
      <returns>true if this Collection is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this Collection is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.ToArray">
      <summary>Answers a new array containing all elements contained in this Collection.</summary>
      <returns>an array of the elements from this Collection</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.ToArray(System.Array)">
      <summary>Answers an array containing all elements contained in this Collection.</summary>
      <param name="array">the array</param>
      <returns>an array of the elements from this Collection</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
            when the type of an element in this Collection cannot be
            stored in the type of the specified array
            </exception>
    </member>
    <member name="T:yWorks.yFiles.Util.IIterator">
      <summary>An Iterator is used to sequence over a collection of objects.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.IIterator.HasNext">
      <summary>Answers if there are more elements to iterate.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IIterator.Next">
      <summary>Answers the next object in the iteration.</summary>
      <returns>the next object</returns>
      <exception cref="T:System.InvalidOperationException">when there are no more elements</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IIterator.Remove">
      <summary>
            Removes the last object returned by <c>next</c> from the
            collection.
            </summary>
      <exception cref="T:System.NotSupportedException">
            when removing is not supported by the collection being
            iterated
            </exception>
      <exception cref="T:System.InvalidOperationException">
            when <c>next</c> has not been called, or
            <c>remove</c> has already been called after the
            last call to <c>next</c></exception>
    </member>
    <member name="T:yWorks.yFiles.Util.IList">
      <summary>List is a collection which maintains an ordering for its elements.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Add(System.Int32,System.Object)">
      <summary>Inserts the specified object into this Vector at the specified location.</summary>
      <param name="location">the index at which to insert</param>
      <param name="object">the object to add</param>
      <exception cref="T:System.NotSupportedException">when adding to this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of the object is inappropriate for this
            List
            </exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to this List</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Add(System.Object)">
      <summary>Adds the specified object at the end of this List.</summary>
      <param name="object">the object to add</param>
      <returns>true</returns>
      <exception cref="T:System.NotSupportedException">when adding to this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of the object is inappropriate for this
            List
            </exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to this List</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.AddAll(System.Int32,yWorks.yFiles.Util.ICollection)">
      <summary>
            Inserts the objects in the specified Collection at the specified location
            in this List.
            </summary>
      <param name="location">the index at which to insert</param>
      <param name="collection">the Collection of objects</param>
      <returns>true if this List is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when adding to this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of an object is inappropriate for this List</exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this List</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>Adds the objects in the specified Collection to the end of this List.</summary>
      <param name="collection">the Collection of objects</param>
      <returns>true if this List is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when adding to this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of an object is inappropriate for this List</exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this List</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Clear">
      <summary>Removes all elements from this List, leaving it empty.</summary>
      <exception cref="T:System.NotSupportedException">when removing from this List is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Contains(System.Object)">
      <summary>Searches this List for the specified object.</summary>
      <param name="object">the object to search for</param>
      <returns>true if object is an element of this List, false otherwise</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ContainsAll(yWorks.yFiles.Util.ICollection)">
      <summary>Searches this List for all objects in the specified Collection.</summary>
      <param name="collection">the Collection of objects</param>
      <returns>
            true if all objects in the specified Collection are elements of
            this List, false otherwise
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.IList.Count">
      <summary>Answers the number of elements in this List.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.IList.Empty">
      <summary>Answers if this List has no elements, a size of zero.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Equals(System.Object)">
      <summary>
            Compares the argument to the receiver, and answers true if they represent
            the <em>same</em> object using a class specific comparison.
            </summary>
      <param name="object">Object the object to compare with this object.</param>
      <returns>
            boolean <see langword="true"></see> if the object is the same as this
            object <see langword="false"></see> if it is different from this object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Get(System.Int32)">
      <summary>Answers the element at the specified location in this List.</summary>
      <param name="location">the index of the element to return</param>
      <returns>the element at the specified location</returns>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.GetHashCode">
      <summary>Answers an integer hash code for the receiver.</summary>
      <returns>the receiver's hash</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.IndexOf(System.Object)">
      <summary>
            Searches this List for the specified object and returns the index of the
            first occurrence.
            </summary>
      <param name="object">the object to search for</param>
      <returns>the index of the first occurrence of the object</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Iterator">
      <summary>Answers an Iterator on the elements of this List.</summary>
      <returns>an Iterator on the elements of this List</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.LastIndexOf(System.Object)">
      <summary>
            Searches this List for the specified object and returns the index of the
            last occurrence.
            </summary>
      <param name="object">the object to search for</param>
      <returns>the index of the last occurrence of the object</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ListIterator">
      <summary>Answers a ListIterator on the elements of this List.</summary>
      <returns>a ListIterator on the elements of this List</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ListIterator(System.Int32)">
      <summary>Answers a ListIterator on the elements of this List.</summary>
      <param name="location">the index at which to start the iteration</param>
      <returns>a ListIterator on the elements of this List</returns>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Remove(System.Int32)">
      <summary>Removes the object at the specified location from this List.</summary>
      <param name="location">the index of the object to remove</param>
      <returns>the removed object</returns>
      <exception cref="T:System.NotSupportedException">when removing from this List is not supported</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Remove(System.Object)">
      <summary>Removes the first occurrence of the specified object from this List.</summary>
      <param name="object">the object to remove</param>
      <returns>true if this List is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this List is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Removes all occurrences in this List of each object in the specified
            Collection.
            </summary>
      <param name="collection">the Collection of objects to remove</param>
      <returns>true if this List is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this List is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.RetainAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Removes all objects from this List that are not contained in the
            specified Collection.
            </summary>
      <param name="collection">the Collection of objects to retain</param>
      <returns>true if this List is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this List is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Set(System.Int32,System.Object)">
      <summary>
            Replaces the element at the specified location in this List with the
            specified object.
            </summary>
      <param name="location">the index at which to put the specified object</param>
      <param name="object">the object to add</param>
      <returns>the previous element at the index</returns>
      <exception cref="T:System.NotSupportedException">when replacing elements in this List is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of an object is inappropriate for this List</exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this List</exception>
      <exception cref="T:System.IndexOutOfRangeException">when <c>location &lt; 0 || &gt;= size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.SubList(System.Int32,System.Int32)">
      <summary>
            Answers a List of the specified portion of this List from the start index
            to one less than the end index.
            </summary>
      <param name="start">the index at which to start the sublist</param>
      <param name="end">the index one past the end of the sublist</param>
      <returns>a List of a portion of this List</returns>
      <exception cref="T:System.IndexOutOfRangeException">
            when <c>start &lt; 0, start &gt; end</c> or
            <c>end &gt; size()</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ToArray">
      <summary>Answers an array containing all elements contained in this List.</summary>
      <returns>an array of the elements from this List</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ToArray(System.Array)">
      <summary>Answers an array containing all elements contained in this List.</summary>
      <param name="array">the array</param>
      <returns>an array of the elements from this List</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
            when the type of an element in this List cannot be stored
            in the type of the specified array
            </exception>
    </member>
    <member name="T:yWorks.yFiles.Util.IListIterator">
      <summary>An ListIterator is used to sequence over a List of objects.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Add(System.Object)">
      <summary>
            Inserts the specified object into the list between <c>next</c>
            and <c>previous</c>.
            </summary>
      <param name="object">the object to insert</param>
      <exception cref="T:System.NotSupportedException">when adding is not supported by the list being iterated</exception>
      <exception cref="T:System.InvalidCastException">when the class of the object is inappropriate for the list</exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to the list</exception>
    </member>
    <member name="P:yWorks.yFiles.Util.IListIterator.HasNext">
      <summary>Answers if there are more elements to iterate.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.HasPrevious">
      <summary>Answers if there are previous elements to iterate.</summary>
      <returns>true if there are previous elements, false otherwise</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Next">
      <summary>Answers the next object in the iteration.</summary>
      <returns>the next object</returns>
      <exception cref="T:System.InvalidOperationException">when there are no more elements</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.NextIndex">
      <summary>Answers the index of the next object in the iteration.</summary>
      <returns>the index of the next object</returns>
      <exception cref="T:System.InvalidOperationException">when there are no more elements</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Previous">
      <summary>Answers the previous object in the iteration.</summary>
      <returns>the previous object</returns>
      <exception cref="T:System.InvalidOperationException">when there are no previous elements</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.PreviousIndex">
      <summary>Answers the index of the previous object in the iteration.</summary>
      <returns>the index of the previous object</returns>
      <exception cref="T:System.InvalidOperationException">when there are no previous elements</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Remove">
      <summary>
            Removes the last object returned by <c>next</c> or
            <c>previous</c> from the list.
            </summary>
      <exception cref="T:System.NotSupportedException">when removing is not supported by the list being iterated</exception>
      <exception cref="T:System.InvalidOperationException">
            when <c>next</c> or <c>previous</c> have
            not been called, or <c>remove</c> or
            <c>add</c> have already been called after the last
            call to <c>next</c> or <c>previous</c></exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Set(System.Object)">
      <summary>
            Replaces the last object returned by <c>next</c> or
            <c>previous</c> with the specified object.
            </summary>
      <param name="object">the object to add</param>
      <exception cref="T:System.NotSupportedException">when adding is not supported by the list being iterated</exception>
      <exception cref="T:System.InvalidCastException">when the class of the object is inappropriate for the list</exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to the list</exception>
      <exception cref="T:System.InvalidOperationException">
            when <c>next</c> or <c>previous</c> have
            not been called, or <c>remove</c> or
            <c>add</c> have already been called after the last
            call to <c>next</c> or <c>previous</c></exception>
    </member>
    <member name="T:yWorks.yFiles.Util.IMap">
      <summary>Map has a set of keys, each key is mapped to a single value.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Clear">
      <summary>Removes all elements from this Map, leaving it empty.</summary>
      <exception cref="T:System.NotSupportedException">when removing from this Map is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.ContainsKey(System.Object)">
      <summary>Searches this Map for the specified key.</summary>
      <param name="key">the object to search for</param>
      <returns>true if <c>key</c> is a key of this Map, false otherwise</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.ContainsValue(System.Object)">
      <summary>Searches this Map for the specified value.</summary>
      <param name="value">the object to search for</param>
      <returns>
            true if <c>value</c> is a value of this Map, false
            otherwise
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.IMap.Empty">
      <summary>Answers if this Map has no elements, a size of zero.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.EntrySet">
      <summary>
            Returns a <c>Set</c> whose elements comprise all of the mappings
            that are to be found in this <c>Map</c>.
            </summary>
      <returns>a <c>Set</c> of the mappings</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Equals(System.Object)">
      <summary>
            Compares the argument to the receiver, and answers true if they represent
            the <em>same</em> object using a class specific comparison.
            </summary>
      <param name="object">Object the object to compare with this object.</param>
      <returns>
            boolean <see langword="true"></see> if the object is the same as this
            object <see langword="false"></see> if it is different from this object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Get(System.Object)">
      <summary>Answers the value of the mapping with the specified key.</summary>
      <param name="key">the key</param>
      <returns>the value of the mapping with the specified key</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.GetHashCode">
      <summary>Answers an integer hash code for the receiver.</summary>
      <returns>the receiver's hash</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.KeySet">
      <summary>Answers a Set of the keys contained in this Map.</summary>
      <returns>a Set of the keys</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Put(System.Object,System.Object)">
      <summary>Maps the specified key to the specified value.</summary>
      <param name="key">the key</param>
      <param name="value">the value</param>
      <returns>
            the value of any previous mapping with the specified key or null
            if there was no mapping
            </returns>
      <exception cref="T:System.NotSupportedException">when adding to this Map is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of the key or value is inappropriate for
            this Map
            </exception>
      <exception cref="T:System.ArgumentException">when the key or value cannot be added to this Map</exception>
      <exception cref="T:System.ArgumentNullException">
            when the key or value is null and this Map does not
            support null keys or values
            </exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.PutAll(yWorks.yFiles.Util.IMap)">
      <summary>Copies every mapping in the specified Map to this Map.</summary>
      <param name="map">the Map to copy mappings from</param>
      <exception cref="T:System.NotSupportedException">when adding to this Map is not supported</exception>
      <exception cref="T:System.InvalidCastException">
            when the class of a key or value is inappropriate for this
            Map
            </exception>
      <exception cref="T:System.ArgumentException">when a key or value cannot be added to this Map</exception>
      <exception cref="T:System.ArgumentNullException">
            when a key or value is null and this Map does not support
            null keys or values
            </exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Remove(System.Object)">
      <summary>Removes a mapping with the specified key from this Map.</summary>
      <param name="key">the key of the mapping to remove</param>
      <returns>
            the value of the removed mapping or null if key is not a key in
            this Map
            </returns>
      <exception cref="T:System.NotSupportedException">when removing from this Map is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Size">
      <summary>Answers the number of elements in this Map.</summary>
      <returns>the number of elements in this Map</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Values">
      <summary>
            Returns all of the current <c>Map</c> values in a
            <c>Collection</c>.
            </summary>
      <returns>a Collection of the values</returns>
    </member>
    <member name="T:yWorks.yFiles.Util.IMapEntry">
      <summary>Map.Entry is a key/value mapping which is contained in a Map.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IMapEntry.Equals(System.Object)">
      <summary>
            Compares the specified object to this Map.Entry and answer if they
            are equal.
            </summary>
      <param name="object">the object to compare with this object</param>
      <returns>
            true if the specified object is equal to this Map.Entry,
            false otherwise
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.IMapEntry.GetHashCode">
      <summary>Answers an integer hash code for the receiver.</summary>
      <returns>the receiver's hash</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.IMapEntry.Key">
      <summary>The key.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IMapEntry.SetValue(System.Object)">
      <summary>Sets the value.</summary>
      <param name="object">the new value</param>
      <returns>object</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.IMapEntry.Value">
      <summary>The value.</summary>
    </member>
    <member name="T:yWorks.yFiles.Util.ISet">
      <summary>Set is a collection which does not allow duplicate elements.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Add(System.Object)">
      <summary>Adds the specified object to this Set.</summary>
      <param name="object">the object to add</param>
      <returns>true if this Set is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when adding to this Set is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of the object is inappropriate for this Set</exception>
      <exception cref="T:System.ArgumentException">when the object cannot be added to this Set</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Adds the objects in the specified Collection which do not exist in this
            Set.
            </summary>
      <param name="collection">the Collection of objects</param>
      <returns>true if this Set is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when adding to this Set is not supported</exception>
      <exception cref="T:System.InvalidCastException">when the class of an object is inappropriate for this Set</exception>
      <exception cref="T:System.ArgumentException">when an object cannot be added to this Set</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Clear">
      <summary>Removes all elements from this Set, leaving it empty.</summary>
      <exception cref="T:System.NotSupportedException">when removing from this Set is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Contains(System.Object)">
      <summary>Searches this Set for the specified object.</summary>
      <param name="object">the object to search for</param>
      <returns>true if object is an element of this Set, false otherwise</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.ContainsAll(yWorks.yFiles.Util.ICollection)">
      <summary>Searches this Set for all objects in the specified Collection.</summary>
      <param name="collection">the Collection of objects</param>
      <returns>
            true if all objects in the specified Collection are elements of
            this Set, false otherwise
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.ISet.Count">
      <summary>Answers the number of elements in this Set.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.ISet.Empty">
      <summary>Answers if this Set has no elements, a size of zero.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Equals(System.Object)">
      <summary>
            Compares the argument to the receiver, and answers true if they represent
            the <em>same</em> object using a class specific comparison.
            </summary>
      <param name="object">Object the object to compare with this object.</param>
      <returns>
            boolean <see langword="true"></see> if the object is the same as this
            object <see langword="false"></see> if it is different from this object.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.GetHashCode">
      <summary>Answers an integer hash code for the receiver.</summary>
      <returns>the receiver's hash</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Iterator">
      <summary>Answers an Iterator on the elements of this Set.</summary>
      <returns>an Iterator on the elements of this Set</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Remove(System.Object)">
      <summary>Removes any occurrence of the specified object from this Set.</summary>
      <param name="object">the object to remove</param>
      <returns>true if this Set is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this Set is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>Removes all objects in the specified Collection from this Set.</summary>
      <param name="collection">the Collection of objects to remove</param>
      <returns>true if this Set is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this Set is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.RetainAll(yWorks.yFiles.Util.ICollection)">
      <summary>
            Removes all objects from this Set that are not contained in the specified
            Collection.
            </summary>
      <param name="collection">the Collection of objects to retain</param>
      <returns>true if this Set is modified, false otherwise</returns>
      <exception cref="T:System.NotSupportedException">when removing from this Set is not supported</exception>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.ToArray">
      <summary>Answers an array containing all elements contained in this Set.</summary>
      <returns>an array of the elements from this Set</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.ToArray(System.Array)">
      <summary>Answers an array containing all elements contained in this Set.</summary>
      <param name="array">the array</param>
      <returns>an array of the elements from this Set</returns>
      <exception cref="T:System.ArrayTypeMismatchException">
            when the type of an element in this Set cannot be stored
            in the type of the specified array
            </exception>
    </member>
    <member name="T:yWorks.yFiles.Util.Random">
      <summary>
            This class provides methods that generates pseudo-random numbers of different
            types, such as int, long, double and float using either
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.#ctor">
      <summary>
            Construct a random generator with the current time of day in milliseconds
            as the initial state.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.#ctor(System.Int64)">
      <summary>
            Construct a random generator with the given <c>seed</c> as the
            initial state.
            </summary>
      <param name="seed">
            the seed that will determine the initial state of this random
            number generator
            </param>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.Next(System.Int32)">
      <summary>
            Returns a pseudo-random uniformly distributed <c>int</c> value of
            the number of bits specified by the argument <c>bits</c>.
            </summary>
      <param name="bits">number of bits of the returned value</param>
      <returns>a pseudo-randomly generated int</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextBoolean">
      <summary>
            Answers the next pseudo-random, uniformly distributed boolean value
            generated by this generator.
            </summary>
      <returns>boolean a pseudo-random, uniformly distributed boolean value</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextBytes(System.SByte[])">
      <summary>
            Modifies the byte array by a random sequence of bytes generated by this
            random number generator.
            </summary>
      <param name="buf">non-null array to contain the new random bytes</param>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextDouble">
      <summary>
            Generates a normally distributed random double number between 0.0
            inclusively and 1.0 exclusively.
            </summary>
      <returns>a random double between 0.0 and 1.0</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextFloat">
      <summary>
            Generates a normally distributed random float number between 0.0
            inclusively and 1.0 exclusively.
            </summary>
      <returns>a random float between 0.0 and 1.0</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextGaussian">
      <summary>
            Returns a pseudo-randomly generated, normally distributed
            <c>double</c> value with mean 0.0 and a standard deviation value
            of <c>1.0</c>.
            </summary>
      <returns>a pseudo-randomly generated double</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextInt">
      <summary>
            Generates a uniformly distributed 32-bit <c>int</c> value from
            the this random number sequence.
            </summary>
      <returns>a randomly generated <c>int</c></returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextInt(System.Int32)">
      <summary>
            Returns a new pseudo-random integer value which is uniformly distributed
            between 0 (inclusively) and <c>n</c> (exclusively).
            </summary>
      <param name="n">the upper limit of the values that can be returned</param>
      <returns>a randomly generated <c>int</c> between 0 and n</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextLong">
      <summary>
            Generates a uniformly distributed 64-bit <c>int</c> value from
            the this random number sequence.
            </summary>
      <returns>64-bit <c>int</c> random number</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Random.Seed">
      <summary>
            Modifies the seed using a linear congruential formula, as found in <i>The
            Art of Computer Programming, Volume 2</i>, by Donald E.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Insets"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Insets" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.bottom"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.Clone">
      <summary>
                    Creates a new object that is a copy of the current instance.
                </summary>
      <returns>
                    A new object that is a copy of this instance.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.Equals(System.Object)">
      <summary>
                    Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
                </summary>
      <param name="obj">
                    The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. 
                </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
                </returns>
      <exception cref="T:System.NullReferenceException">
                    The <paramref name="obj" /> parameter is null.
                </exception>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.left"></member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.right"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.Set(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.top"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Point2D"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Point2D" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Clone">
      <summary>
                    Creates a new object that is a copy of the current instance.
                </summary>
      <returns>
                    A new object that is a copy of this instance.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Distance(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Distance(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Distance(yWorks.yFiles.Util.Geom.Point2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.DistanceSq(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.DistanceSq(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.DistanceSq(yWorks.yFiles.Util.Geom.Point2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Equals(System.Object)">
      <summary>
                    Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
                </summary>
      <param name="obj">
                    The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. 
                </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
                </returns>
      <exception cref="T:System.NullReferenceException">
                    The <paramref name="obj" /> parameter is null.
                </exception>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Location"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.SetLocation(System.Double,System.Double)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.X"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Y"></member>
    <member name="T:yWorks.yFiles.Util.Geom.Point2D.Double"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Point2D.Double" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.#ctor(System.Double,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Point2D.Double" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.SetLocation(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Double.X"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Double.Y"></member>
    <member name="T:yWorks.yFiles.Util.Geom.Rectangle"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor(System.Int32,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Add(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Add(yWorks.yFiles.Util.Geom.Rectangle)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Bounds"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Bounds2D"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(System.Int32,System.Int32,System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(yWorks.yFiles.Util.Geom.Rectangle)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.CreateIntersection(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.CreateUnion(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Empty"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Equals(System.Object)">
      <summary>
                    Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
                </summary>
      <param name="obj">
                    The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. 
                </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
                </returns>
      <exception cref="T:System.NullReferenceException">
                    The <paramref name="obj" /> parameter is null.
                </exception>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Grow(System.Int32,System.Int32)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Height"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Inside(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Intersection(yWorks.yFiles.Util.Geom.Rectangle)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Intersects(yWorks.yFiles.Util.Geom.Rectangle)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Move(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Outcode(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Reshape(System.Int32,System.Int32,System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Resize(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetBounds(yWorks.yFiles.Util.Geom.Rectangle)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetLocation(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetRect(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetSize(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Translate(System.Int32,System.Int32)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Union(yWorks.yFiles.Util.Geom.Rectangle)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Width"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.X"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Y"></member>
    <member name="T:yWorks.yFiles.Util.Geom.Rectangle2D"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Add(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Add(yWorks.yFiles.Util.Geom.Point2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Add(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Bounds"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Bounds2D"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.CenterX"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.CenterY"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Clone">
      <summary>
                    Creates a new object that is a copy of the current instance.
                </summary>
      <returns>
                    A new object that is a copy of this instance.
                </returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.CreateIntersection(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.CreateUnion(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Empty"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Equals(System.Object)">
      <summary>
                    Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
                </summary>
      <param name="obj">
                    The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. 
                </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
                </returns>
      <exception cref="T:System.NullReferenceException">
                    The <paramref name="obj" /> parameter is null.
                </exception>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Frame"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.GetHashCode">
      <summary>
                    Serves as a hash function for a particular type. 
                </summary>
      <returns>
                    A hash code for the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Height"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Intersect(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Intersects(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Intersects(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.IntersectsLine(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MaxX"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MaxY"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MinX"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MinY"></member>
    <member name="F:yWorks.yFiles.Util.Geom.Rectangle2D.OutBottom"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Outcode(System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Outcode(yWorks.yFiles.Util.Geom.Point2D)"></member>
    <member name="F:yWorks.yFiles.Util.Geom.Rectangle2D.OutLeft"></member>
    <member name="F:yWorks.yFiles.Util.Geom.Rectangle2D.OutRight"></member>
    <member name="F:yWorks.yFiles.Util.Geom.Rectangle2D.OutTop"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Rect"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrame(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromCenter(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromCenter(yWorks.yFiles.Util.Geom.Point2D,yWorks.yFiles.Util.Geom.Point2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromDiagonal(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromDiagonal(yWorks.yFiles.Util.Geom.Point2D,yWorks.yFiles.Util.Geom.Point2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetRect(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Union(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Width"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.X"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Y"></member>
    <member name="T:yWorks.yFiles.Util.Geom.Rectangle2D.Double"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D.Double" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D.Double" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Bounds2D"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.CreateIntersection(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.CreateUnion(yWorks.yFiles.Util.Geom.Rectangle2D)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Empty"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Height"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Outcode(System.Double,System.Double)"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Rect"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.SetRect(System.Double,System.Double,System.Double,System.Double)"></member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.ToString">
      <summary>
                    Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </summary>
      <returns>
                    A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                </returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Width"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.X"></member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Y"></member>
  </members>
</doc>