//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 formula.g 2011-12-08 16:00:30

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class formulaLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int A=4;
	public const int ADD=5;
	public const int ALFA=6;
	public const int ALFANUM=7;
	public const int ALFA_=8;
	public const int ARG_SEPARATOR=9;
	public const int ARRAY=10;
	public const int CALL=11;
	public const int CELL=12;
	public const int COLUMN=13;
	public const int COLUMN_RANGE=14;
	public const int CONCAT=15;
	public const int DEFINED_NAME=16;
	public const int DIGIT=17;
	public const int DIV=18;
	public const int E=19;
	public const int EQ=20;
	public const int ERROR=21;
	public const int EXP=22;
	public const int F=23;
	public const int FALSE=24;
	public const int FILEPREFIX=25;
	public const int FUNCTION_NAME=26;
	public const int GT=27;
	public const int GTE=28;
	public const int INTERSECTION=29;
	public const int L=30;
	public const int LEFT_CURLY=31;
	public const int LEFT_PAREN=32;
	public const int LT=33;
	public const int LTE=34;
	public const int MUL=35;
	public const int NAME=36;
	public const int NE=37;
	public const int NUMBER=38;
	public const int PAREN=39;
	public const int PERCENT=40;
	public const int R=41;
	public const int RANGE=42;
	public const int RIGHT_CURLY=43;
	public const int RIGHT_PAREN=44;
	public const int ROW=45;
	public const int ROW_RANGE=46;
	public const int S=47;
	public const int SHEET=48;
	public const int SHEETPREFIX=49;
	public const int SHEETRANGE=50;
	public const int SIGN=51;
	public const int STRING=52;
	public const int SUB=53;
	public const int T=54;
	public const int TRUE=55;
	public const int U=56;
	public const int UNION=57;
	public const int WHITESPACE=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;

    // delegates
    // delegators

	public formulaLexer()
	{
		OnCreated();
	}

	public formulaLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public formulaLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "formula.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__59();
	partial void LeaveRule_T__59();

	// $ANTLR start "T__59"
	[GrammarRule("T__59")]
	private void mT__59()
	{
		EnterRule_T__59();
		EnterRule("T__59", 1);
		TraceIn("T__59", 1);
		try
		{
			int _type = T__59;
			int _channel = DefaultTokenChannel;
			// formula.g:8:7: ( '#DIV/0!' )
			DebugEnterAlt(1);
			// formula.g:8:9: '#DIV/0!'
			{
			DebugLocation(8, 9);
			Match("#DIV/0!"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__59", 1);
			LeaveRule("T__59", 1);
			LeaveRule_T__59();
		}
	}
	// $ANTLR end "T__59"

	partial void EnterRule_T__60();
	partial void LeaveRule_T__60();

	// $ANTLR start "T__60"
	[GrammarRule("T__60")]
	private void mT__60()
	{
		EnterRule_T__60();
		EnterRule("T__60", 2);
		TraceIn("T__60", 2);
		try
		{
			int _type = T__60;
			int _channel = DefaultTokenChannel;
			// formula.g:9:7: ( '#N/A' )
			DebugEnterAlt(1);
			// formula.g:9:9: '#N/A'
			{
			DebugLocation(9, 9);
			Match("#N/A"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__60", 2);
			LeaveRule("T__60", 2);
			LeaveRule_T__60();
		}
	}
	// $ANTLR end "T__60"

	partial void EnterRule_T__61();
	partial void LeaveRule_T__61();

	// $ANTLR start "T__61"
	[GrammarRule("T__61")]
	private void mT__61()
	{
		EnterRule_T__61();
		EnterRule("T__61", 3);
		TraceIn("T__61", 3);
		try
		{
			int _type = T__61;
			int _channel = DefaultTokenChannel;
			// formula.g:10:7: ( '#NAME?' )
			DebugEnterAlt(1);
			// formula.g:10:9: '#NAME?'
			{
			DebugLocation(10, 9);
			Match("#NAME?"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__61", 3);
			LeaveRule("T__61", 3);
			LeaveRule_T__61();
		}
	}
	// $ANTLR end "T__61"

	partial void EnterRule_T__62();
	partial void LeaveRule_T__62();

	// $ANTLR start "T__62"
	[GrammarRule("T__62")]
	private void mT__62()
	{
		EnterRule_T__62();
		EnterRule("T__62", 4);
		TraceIn("T__62", 4);
		try
		{
			int _type = T__62;
			int _channel = DefaultTokenChannel;
			// formula.g:11:7: ( '#NULL!' )
			DebugEnterAlt(1);
			// formula.g:11:9: '#NULL!'
			{
			DebugLocation(11, 9);
			Match("#NULL!"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__62", 4);
			LeaveRule("T__62", 4);
			LeaveRule_T__62();
		}
	}
	// $ANTLR end "T__62"

	partial void EnterRule_T__63();
	partial void LeaveRule_T__63();

	// $ANTLR start "T__63"
	[GrammarRule("T__63")]
	private void mT__63()
	{
		EnterRule_T__63();
		EnterRule("T__63", 5);
		TraceIn("T__63", 5);
		try
		{
			int _type = T__63;
			int _channel = DefaultTokenChannel;
			// formula.g:12:7: ( '#NUM!' )
			DebugEnterAlt(1);
			// formula.g:12:9: '#NUM!'
			{
			DebugLocation(12, 9);
			Match("#NUM!"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__63", 5);
			LeaveRule("T__63", 5);
			LeaveRule_T__63();
		}
	}
	// $ANTLR end "T__63"

	partial void EnterRule_T__64();
	partial void LeaveRule_T__64();

	// $ANTLR start "T__64"
	[GrammarRule("T__64")]
	private void mT__64()
	{
		EnterRule_T__64();
		EnterRule("T__64", 6);
		TraceIn("T__64", 6);
		try
		{
			int _type = T__64;
			int _channel = DefaultTokenChannel;
			// formula.g:13:7: ( '#REF!' )
			DebugEnterAlt(1);
			// formula.g:13:9: '#REF!'
			{
			DebugLocation(13, 9);
			Match("#REF!"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__64", 6);
			LeaveRule("T__64", 6);
			LeaveRule_T__64();
		}
	}
	// $ANTLR end "T__64"

	partial void EnterRule_T__65();
	partial void LeaveRule_T__65();

	// $ANTLR start "T__65"
	[GrammarRule("T__65")]
	private void mT__65()
	{
		EnterRule_T__65();
		EnterRule("T__65", 7);
		TraceIn("T__65", 7);
		try
		{
			int _type = T__65;
			int _channel = DefaultTokenChannel;
			// formula.g:14:7: ( '#VALUE!' )
			DebugEnterAlt(1);
			// formula.g:14:9: '#VALUE!'
			{
			DebugLocation(14, 9);
			Match("#VALUE!"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__65", 7);
			LeaveRule("T__65", 7);
			LeaveRule_T__65();
		}
	}
	// $ANTLR end "T__65"

	partial void EnterRule_T__66();
	partial void LeaveRule_T__66();

	// $ANTLR start "T__66"
	[GrammarRule("T__66")]
	private void mT__66()
	{
		EnterRule_T__66();
		EnterRule("T__66", 8);
		TraceIn("T__66", 8);
		try
		{
			int _type = T__66;
			int _channel = DefaultTokenChannel;
			// formula.g:15:7: ( ':' )
			DebugEnterAlt(1);
			// formula.g:15:9: ':'
			{
			DebugLocation(15, 9);
			Match(':'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__66", 8);
			LeaveRule("T__66", 8);
			LeaveRule_T__66();
		}
	}
	// $ANTLR end "T__66"

	partial void EnterRule_T__67();
	partial void LeaveRule_T__67();

	// $ANTLR start "T__67"
	[GrammarRule("T__67")]
	private void mT__67()
	{
		EnterRule_T__67();
		EnterRule("T__67", 9);
		TraceIn("T__67", 9);
		try
		{
			int _type = T__67;
			int _channel = DefaultTokenChannel;
			// formula.g:16:7: ( ';' )
			DebugEnterAlt(1);
			// formula.g:16:9: ';'
			{
			DebugLocation(16, 9);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__67", 9);
			LeaveRule("T__67", 9);
			LeaveRule_T__67();
		}
	}
	// $ANTLR end "T__67"

	partial void EnterRule_ADD();
	partial void LeaveRule_ADD();

	// $ANTLR start "ADD"
	[GrammarRule("ADD")]
	private void mADD()
	{
		EnterRule_ADD();
		EnterRule("ADD", 10);
		TraceIn("ADD", 10);
		try
		{
			int _type = ADD;
			int _channel = DefaultTokenChannel;
			// formula.g:48:2: ( '+' )
			DebugEnterAlt(1);
			// formula.g:48:4: '+'
			{
			DebugLocation(48, 4);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ADD", 10);
			LeaveRule("ADD", 10);
			LeaveRule_ADD();
		}
	}
	// $ANTLR end "ADD"

	partial void EnterRule_SUB();
	partial void LeaveRule_SUB();

	// $ANTLR start "SUB"
	[GrammarRule("SUB")]
	private void mSUB()
	{
		EnterRule_SUB();
		EnterRule("SUB", 11);
		TraceIn("SUB", 11);
		try
		{
			int _type = SUB;
			int _channel = DefaultTokenChannel;
			// formula.g:51:2: ( '-' )
			DebugEnterAlt(1);
			// formula.g:51:4: '-'
			{
			DebugLocation(51, 4);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SUB", 11);
			LeaveRule("SUB", 11);
			LeaveRule_SUB();
		}
	}
	// $ANTLR end "SUB"

	partial void EnterRule_MUL();
	partial void LeaveRule_MUL();

	// $ANTLR start "MUL"
	[GrammarRule("MUL")]
	private void mMUL()
	{
		EnterRule_MUL();
		EnterRule("MUL", 12);
		TraceIn("MUL", 12);
		try
		{
			int _type = MUL;
			int _channel = DefaultTokenChannel;
			// formula.g:54:2: ( '*' )
			DebugEnterAlt(1);
			// formula.g:54:4: '*'
			{
			DebugLocation(54, 4);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MUL", 12);
			LeaveRule("MUL", 12);
			LeaveRule_MUL();
		}
	}
	// $ANTLR end "MUL"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 13);
		TraceIn("DIV", 13);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// formula.g:57:2: ( '/' )
			DebugEnterAlt(1);
			// formula.g:57:4: '/'
			{
			DebugLocation(57, 4);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 13);
			LeaveRule("DIV", 13);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_EXP();
	partial void LeaveRule_EXP();

	// $ANTLR start "EXP"
	[GrammarRule("EXP")]
	private void mEXP()
	{
		EnterRule_EXP();
		EnterRule("EXP", 14);
		TraceIn("EXP", 14);
		try
		{
			int _type = EXP;
			int _channel = DefaultTokenChannel;
			// formula.g:60:2: ( '^' )
			DebugEnterAlt(1);
			// formula.g:60:4: '^'
			{
			DebugLocation(60, 4);
			Match('^'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXP", 14);
			LeaveRule("EXP", 14);
			LeaveRule_EXP();
		}
	}
	// $ANTLR end "EXP"

	partial void EnterRule_CONCAT();
	partial void LeaveRule_CONCAT();

	// $ANTLR start "CONCAT"
	[GrammarRule("CONCAT")]
	private void mCONCAT()
	{
		EnterRule_CONCAT();
		EnterRule("CONCAT", 15);
		TraceIn("CONCAT", 15);
		try
		{
			int _type = CONCAT;
			int _channel = DefaultTokenChannel;
			// formula.g:63:2: ( '&' )
			DebugEnterAlt(1);
			// formula.g:63:4: '&'
			{
			DebugLocation(63, 4);
			Match('&'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CONCAT", 15);
			LeaveRule("CONCAT", 15);
			LeaveRule_CONCAT();
		}
	}
	// $ANTLR end "CONCAT"

	partial void EnterRule_LEFT_PAREN();
	partial void LeaveRule_LEFT_PAREN();

	// $ANTLR start "LEFT_PAREN"
	[GrammarRule("LEFT_PAREN")]
	private void mLEFT_PAREN()
	{
		EnterRule_LEFT_PAREN();
		EnterRule("LEFT_PAREN", 16);
		TraceIn("LEFT_PAREN", 16);
		try
		{
			int _type = LEFT_PAREN;
			int _channel = DefaultTokenChannel;
			// formula.g:66:2: ( '(' )
			DebugEnterAlt(1);
			// formula.g:66:4: '('
			{
			DebugLocation(66, 4);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LEFT_PAREN", 16);
			LeaveRule("LEFT_PAREN", 16);
			LeaveRule_LEFT_PAREN();
		}
	}
	// $ANTLR end "LEFT_PAREN"

	partial void EnterRule_RIGHT_PAREN();
	partial void LeaveRule_RIGHT_PAREN();

	// $ANTLR start "RIGHT_PAREN"
	[GrammarRule("RIGHT_PAREN")]
	private void mRIGHT_PAREN()
	{
		EnterRule_RIGHT_PAREN();
		EnterRule("RIGHT_PAREN", 17);
		TraceIn("RIGHT_PAREN", 17);
		try
		{
			int _type = RIGHT_PAREN;
			int _channel = DefaultTokenChannel;
			// formula.g:69:2: ( ')' )
			DebugEnterAlt(1);
			// formula.g:69:4: ')'
			{
			DebugLocation(69, 4);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RIGHT_PAREN", 17);
			LeaveRule("RIGHT_PAREN", 17);
			LeaveRule_RIGHT_PAREN();
		}
	}
	// $ANTLR end "RIGHT_PAREN"

	partial void EnterRule_LEFT_CURLY();
	partial void LeaveRule_LEFT_CURLY();

	// $ANTLR start "LEFT_CURLY"
	[GrammarRule("LEFT_CURLY")]
	private void mLEFT_CURLY()
	{
		EnterRule_LEFT_CURLY();
		EnterRule("LEFT_CURLY", 18);
		TraceIn("LEFT_CURLY", 18);
		try
		{
			int _type = LEFT_CURLY;
			int _channel = DefaultTokenChannel;
			// formula.g:72:2: ( '{' )
			DebugEnterAlt(1);
			// formula.g:72:4: '{'
			{
			DebugLocation(72, 4);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LEFT_CURLY", 18);
			LeaveRule("LEFT_CURLY", 18);
			LeaveRule_LEFT_CURLY();
		}
	}
	// $ANTLR end "LEFT_CURLY"

	partial void EnterRule_RIGHT_CURLY();
	partial void LeaveRule_RIGHT_CURLY();

	// $ANTLR start "RIGHT_CURLY"
	[GrammarRule("RIGHT_CURLY")]
	private void mRIGHT_CURLY()
	{
		EnterRule_RIGHT_CURLY();
		EnterRule("RIGHT_CURLY", 19);
		TraceIn("RIGHT_CURLY", 19);
		try
		{
			int _type = RIGHT_CURLY;
			int _channel = DefaultTokenChannel;
			// formula.g:75:2: ( '}' )
			DebugEnterAlt(1);
			// formula.g:75:4: '}'
			{
			DebugLocation(75, 4);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RIGHT_CURLY", 19);
			LeaveRule("RIGHT_CURLY", 19);
			LeaveRule_RIGHT_CURLY();
		}
	}
	// $ANTLR end "RIGHT_CURLY"

	partial void EnterRule_PERCENT();
	partial void LeaveRule_PERCENT();

	// $ANTLR start "PERCENT"
	[GrammarRule("PERCENT")]
	private void mPERCENT()
	{
		EnterRule_PERCENT();
		EnterRule("PERCENT", 20);
		TraceIn("PERCENT", 20);
		try
		{
			int _type = PERCENT;
			int _channel = DefaultTokenChannel;
			// formula.g:78:2: ( '%' )
			DebugEnterAlt(1);
			// formula.g:78:4: '%'
			{
			DebugLocation(78, 4);
			Match('%'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PERCENT", 20);
			LeaveRule("PERCENT", 20);
			LeaveRule_PERCENT();
		}
	}
	// $ANTLR end "PERCENT"

	partial void EnterRule_ARG_SEPARATOR();
	partial void LeaveRule_ARG_SEPARATOR();

	// $ANTLR start "ARG_SEPARATOR"
	[GrammarRule("ARG_SEPARATOR")]
	private void mARG_SEPARATOR()
	{
		EnterRule_ARG_SEPARATOR();
		EnterRule("ARG_SEPARATOR", 21);
		TraceIn("ARG_SEPARATOR", 21);
		try
		{
			int _type = ARG_SEPARATOR;
			int _channel = DefaultTokenChannel;
			// formula.g:81:2: ( ',' )
			DebugEnterAlt(1);
			// formula.g:81:4: ','
			{
			DebugLocation(81, 4);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ARG_SEPARATOR", 21);
			LeaveRule("ARG_SEPARATOR", 21);
			LeaveRule_ARG_SEPARATOR();
		}
	}
	// $ANTLR end "ARG_SEPARATOR"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 22);
		TraceIn("EQ", 22);
		try
		{
			int _type = EQ;
			int _channel = DefaultTokenChannel;
			// formula.g:84:2: ( '=' )
			DebugEnterAlt(1);
			// formula.g:84:4: '='
			{
			DebugLocation(84, 4);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQ", 22);
			LeaveRule("EQ", 22);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 23);
		TraceIn("LT", 23);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// formula.g:87:2: ( '<' )
			DebugEnterAlt(1);
			// formula.g:87:4: '<'
			{
			DebugLocation(87, 4);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 23);
			LeaveRule("LT", 23);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 24);
		TraceIn("GT", 24);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// formula.g:90:2: ( '>' )
			DebugEnterAlt(1);
			// formula.g:90:4: '>'
			{
			DebugLocation(90, 4);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 24);
			LeaveRule("GT", 24);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_LTE();
	partial void LeaveRule_LTE();

	// $ANTLR start "LTE"
	[GrammarRule("LTE")]
	private void mLTE()
	{
		EnterRule_LTE();
		EnterRule("LTE", 25);
		TraceIn("LTE", 25);
		try
		{
			int _type = LTE;
			int _channel = DefaultTokenChannel;
			// formula.g:93:2: ( '<=' )
			DebugEnterAlt(1);
			// formula.g:93:4: '<='
			{
			DebugLocation(93, 4);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LTE", 25);
			LeaveRule("LTE", 25);
			LeaveRule_LTE();
		}
	}
	// $ANTLR end "LTE"

	partial void EnterRule_GTE();
	partial void LeaveRule_GTE();

	// $ANTLR start "GTE"
	[GrammarRule("GTE")]
	private void mGTE()
	{
		EnterRule_GTE();
		EnterRule("GTE", 26);
		TraceIn("GTE", 26);
		try
		{
			int _type = GTE;
			int _channel = DefaultTokenChannel;
			// formula.g:96:2: ( '>=' )
			DebugEnterAlt(1);
			// formula.g:96:4: '>='
			{
			DebugLocation(96, 4);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GTE", 26);
			LeaveRule("GTE", 26);
			LeaveRule_GTE();
		}
	}
	// $ANTLR end "GTE"

	partial void EnterRule_NE();
	partial void LeaveRule_NE();

	// $ANTLR start "NE"
	[GrammarRule("NE")]
	private void mNE()
	{
		EnterRule_NE();
		EnterRule("NE", 27);
		TraceIn("NE", 27);
		try
		{
			int _type = NE;
			int _channel = DefaultTokenChannel;
			// formula.g:99:2: ( '<>' )
			DebugEnterAlt(1);
			// formula.g:99:4: '<>'
			{
			DebugLocation(99, 4);
			Match("<>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NE", 27);
			LeaveRule("NE", 27);
			LeaveRule_NE();
		}
	}
	// $ANTLR end "NE"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 28);
		TraceIn("STRING", 28);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			// formula.g:106:2: ( '\"' (~ ( '\"' ) | '\"\"' )* '\"' )
			DebugEnterAlt(1);
			// formula.g:106:5: '\"' (~ ( '\"' ) | '\"\"' )* '\"'
			{
			DebugLocation(106, 5);
			Match('\"'); 
			DebugLocation(106, 9);
			// formula.g:106:9: (~ ( '\"' ) | '\"\"' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=3;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1=='\"'))
				{
					int LA1_2 = input.LA(2);

					if ((LA1_2=='\"'))
					{
						alt1 = 2;
					}


				}
				else if (((LA1_1>='\u0000' && LA1_1<='!')||(LA1_1>='#' && LA1_1<='\uFFFF')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:106:11: ~ ( '\"' )
					{
					DebugLocation(106, 11);
					input.Consume();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// formula.g:106:20: '\"\"'
					{
					DebugLocation(106, 20);
					Match("\"\""); 


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(106, 27);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING", 28);
			LeaveRule("STRING", 28);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 29);
		TraceIn("DIGIT", 29);
		try
		{
			// formula.g:111:2: ( '0' .. '9' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(111, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 29);
			LeaveRule("DIGIT", 29);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_SIGN();
	partial void LeaveRule_SIGN();

	// $ANTLR start "SIGN"
	[GrammarRule("SIGN")]
	private void mSIGN()
	{
		EnterRule_SIGN();
		EnterRule("SIGN", 30);
		TraceIn("SIGN", 30);
		try
		{
			// formula.g:115:2: ( ADD | SUB )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(115, 2);
			if (input.LA(1)=='+'||input.LA(1)=='-')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("SIGN", 30);
			LeaveRule("SIGN", 30);
			LeaveRule_SIGN();
		}
	}
	// $ANTLR end "SIGN"

	partial void EnterRule_ALFA();
	partial void LeaveRule_ALFA();

	// $ANTLR start "ALFA"
	[GrammarRule("ALFA")]
	private void mALFA()
	{
		EnterRule_ALFA();
		EnterRule("ALFA", 31);
		TraceIn("ALFA", 31);
		try
		{
			// formula.g:119:2: ( 'a' .. 'z' | 'A' .. 'Z' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(119, 2);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("ALFA", 31);
			LeaveRule("ALFA", 31);
			LeaveRule_ALFA();
		}
	}
	// $ANTLR end "ALFA"

	partial void EnterRule_ALFA_();
	partial void LeaveRule_ALFA_();

	// $ANTLR start "ALFA_"
	[GrammarRule("ALFA_")]
	private void mALFA_()
	{
		EnterRule_ALFA_();
		EnterRule("ALFA_", 32);
		TraceIn("ALFA_", 32);
		try
		{
			// formula.g:123:2: ( ALFA | '_' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(123, 2);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("ALFA_", 32);
			LeaveRule("ALFA_", 32);
			LeaveRule_ALFA_();
		}
	}
	// $ANTLR end "ALFA_"

	partial void EnterRule_ALFANUM();
	partial void LeaveRule_ALFANUM();

	// $ANTLR start "ALFANUM"
	[GrammarRule("ALFANUM")]
	private void mALFANUM()
	{
		EnterRule_ALFANUM();
		EnterRule("ALFANUM", 33);
		TraceIn("ALFANUM", 33);
		try
		{
			// formula.g:127:2: ( ALFA_ | DIGIT )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(127, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("ALFANUM", 33);
			LeaveRule("ALFANUM", 33);
			LeaveRule_ALFANUM();
		}
	}
	// $ANTLR end "ALFANUM"

	partial void EnterRule_ROW();
	partial void LeaveRule_ROW();

	// $ANTLR start "ROW"
	[GrammarRule("ROW")]
	private void mROW()
	{
		EnterRule_ROW();
		EnterRule("ROW", 34);
		TraceIn("ROW", 34);
		try
		{
			// formula.g:131:2: ( ( DIGIT )+ )
			DebugEnterAlt(1);
			// formula.g:131:4: ( DIGIT )+
			{
			DebugLocation(131, 4);
			// formula.g:131:4: ( DIGIT )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>='0' && LA2_1<='9')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(131, 4);
					input.Consume();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		finally
		{
			TraceOut("ROW", 34);
			LeaveRule("ROW", 34);
			LeaveRule_ROW();
		}
	}
	// $ANTLR end "ROW"

	partial void EnterRule_COLUMN();
	partial void LeaveRule_COLUMN();

	// $ANTLR start "COLUMN"
	[GrammarRule("COLUMN")]
	private void mCOLUMN()
	{
		EnterRule_COLUMN();
		EnterRule("COLUMN", 35);
		TraceIn("COLUMN", 35);
		try
		{
			// formula.g:135:2: ( ( ALFA )+ )
			DebugEnterAlt(1);
			// formula.g:135:4: ( ALFA )+
			{
			DebugLocation(135, 4);
			// formula.g:135:4: ( ALFA )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if (((LA3_1>='A' && LA3_1<='Z')||(LA3_1>='a' && LA3_1<='z')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(135, 4);
					input.Consume();


					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

		}
		finally
		{
			TraceOut("COLUMN", 35);
			LeaveRule("COLUMN", 35);
			LeaveRule_COLUMN();
		}
	}
	// $ANTLR end "COLUMN"

	partial void EnterRule_NUMBER();
	partial void LeaveRule_NUMBER();

	// $ANTLR start "NUMBER"
	[GrammarRule("NUMBER")]
	private void mNUMBER()
	{
		EnterRule_NUMBER();
		EnterRule("NUMBER", 36);
		TraceIn("NUMBER", 36);
		try
		{
			int _type = NUMBER;
			int _channel = DefaultTokenChannel;
			// formula.g:137:2: ( ( DIGIT )+ ( '.' ( DIGIT )+ )? ( E SIGN ( DIGIT )+ )? )
			DebugEnterAlt(1);
			// formula.g:137:4: ( DIGIT )+ ( '.' ( DIGIT )+ )? ( E SIGN ( DIGIT )+ )?
			{
			DebugLocation(137, 4);
			// formula.g:137:4: ( DIGIT )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>='0' && LA4_1<='9')))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(137, 4);
					input.Consume();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(137, 11);
			// formula.g:137:11: ( '.' ( DIGIT )+ )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1=='.'))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:137:12: '.' ( DIGIT )+
				{
				DebugLocation(137, 12);
				Match('.'); 
				DebugLocation(137, 16);
				// formula.g:137:16: ( DIGIT )+
				int cnt5=0;
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if (((LA5_1>='0' && LA5_1<='9')))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:
						{
						DebugLocation(137, 16);
						input.Consume();


						}
						break;

					default:
						if (cnt5 >= 1)
							goto loop5;

						EarlyExitException eee5 = new EarlyExitException( 5, input );
						DebugRecognitionException(eee5);
						throw eee5;
					}
					cnt5++;
				}
				loop5:
					;

				} finally { DebugExitSubRule(5); }


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(137, 28);
			// formula.g:137:28: ( E SIGN ( DIGIT )+ )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1=='E'||LA8_1=='e'))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:137:29: E SIGN ( DIGIT )+
				{
				DebugLocation(137, 29);
				mE(); 
				DebugLocation(137, 31);
				mSIGN(); 
				DebugLocation(137, 36);
				// formula.g:137:36: ( DIGIT )+
				int cnt7=0;
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_1 = input.LA(1);

					if (((LA7_1>='0' && LA7_1<='9')))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:
						{
						DebugLocation(137, 36);
						input.Consume();


						}
						break;

					default:
						if (cnt7 >= 1)
							goto loop7;

						EarlyExitException eee7 = new EarlyExitException( 7, input );
						DebugRecognitionException(eee7);
						throw eee7;
					}
					cnt7++;
				}
				loop7:
					;

				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NUMBER", 36);
			LeaveRule("NUMBER", 36);
			LeaveRule_NUMBER();
		}
	}
	// $ANTLR end "NUMBER"

	partial void EnterRule_TRUE();
	partial void LeaveRule_TRUE();

	// $ANTLR start "TRUE"
	[GrammarRule("TRUE")]
	private void mTRUE()
	{
		EnterRule_TRUE();
		EnterRule("TRUE", 37);
		TraceIn("TRUE", 37);
		try
		{
			int _type = TRUE;
			int _channel = DefaultTokenChannel;
			// formula.g:140:2: ( T R U E )
			DebugEnterAlt(1);
			// formula.g:140:4: T R U E
			{
			DebugLocation(140, 4);
			mT(); 
			DebugLocation(140, 6);
			mR(); 
			DebugLocation(140, 8);
			mU(); 
			DebugLocation(140, 10);
			mE(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRUE", 37);
			LeaveRule("TRUE", 37);
			LeaveRule_TRUE();
		}
	}
	// $ANTLR end "TRUE"

	partial void EnterRule_FALSE();
	partial void LeaveRule_FALSE();

	// $ANTLR start "FALSE"
	[GrammarRule("FALSE")]
	private void mFALSE()
	{
		EnterRule_FALSE();
		EnterRule("FALSE", 38);
		TraceIn("FALSE", 38);
		try
		{
			int _type = FALSE;
			int _channel = DefaultTokenChannel;
			// formula.g:143:2: ( F A L S E )
			DebugEnterAlt(1);
			// formula.g:143:4: F A L S E
			{
			DebugLocation(143, 4);
			mF(); 
			DebugLocation(143, 6);
			mA(); 
			DebugLocation(143, 8);
			mL(); 
			DebugLocation(143, 10);
			mS(); 
			DebugLocation(143, 12);
			mE(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FALSE", 38);
			LeaveRule("FALSE", 38);
			LeaveRule_FALSE();
		}
	}
	// $ANTLR end "FALSE"

	partial void EnterRule_T();
	partial void LeaveRule_T();

	// $ANTLR start "T"
	[GrammarRule("T")]
	private void mT()
	{
		EnterRule_T();
		EnterRule("T", 39);
		TraceIn("T", 39);
		try
		{
			// formula.g:145:12: ( 'T' | 't' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(145, 12);
			if (input.LA(1)=='T'||input.LA(1)=='t')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("T", 39);
			LeaveRule("T", 39);
			LeaveRule_T();
		}
	}
	// $ANTLR end "T"

	partial void EnterRule_R();
	partial void LeaveRule_R();

	// $ANTLR start "R"
	[GrammarRule("R")]
	private void mR()
	{
		EnterRule_R();
		EnterRule("R", 40);
		TraceIn("R", 40);
		try
		{
			// formula.g:146:12: ( 'R' | 'r' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(146, 12);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("R", 40);
			LeaveRule("R", 40);
			LeaveRule_R();
		}
	}
	// $ANTLR end "R"

	partial void EnterRule_U();
	partial void LeaveRule_U();

	// $ANTLR start "U"
	[GrammarRule("U")]
	private void mU()
	{
		EnterRule_U();
		EnterRule("U", 41);
		TraceIn("U", 41);
		try
		{
			// formula.g:147:12: ( 'U' | 'u' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(147, 12);
			if (input.LA(1)=='U'||input.LA(1)=='u')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("U", 41);
			LeaveRule("U", 41);
			LeaveRule_U();
		}
	}
	// $ANTLR end "U"

	partial void EnterRule_E();
	partial void LeaveRule_E();

	// $ANTLR start "E"
	[GrammarRule("E")]
	private void mE()
	{
		EnterRule_E();
		EnterRule("E", 42);
		TraceIn("E", 42);
		try
		{
			// formula.g:148:12: ( 'E' | 'e' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(148, 12);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("E", 42);
			LeaveRule("E", 42);
			LeaveRule_E();
		}
	}
	// $ANTLR end "E"

	partial void EnterRule_F();
	partial void LeaveRule_F();

	// $ANTLR start "F"
	[GrammarRule("F")]
	private void mF()
	{
		EnterRule_F();
		EnterRule("F", 43);
		TraceIn("F", 43);
		try
		{
			// formula.g:150:12: ( 'F' | 'f' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(150, 12);
			if (input.LA(1)=='F'||input.LA(1)=='f')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("F", 43);
			LeaveRule("F", 43);
			LeaveRule_F();
		}
	}
	// $ANTLR end "F"

	partial void EnterRule_A();
	partial void LeaveRule_A();

	// $ANTLR start "A"
	[GrammarRule("A")]
	private void mA()
	{
		EnterRule_A();
		EnterRule("A", 44);
		TraceIn("A", 44);
		try
		{
			// formula.g:151:12: ( 'A' | 'a' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(151, 12);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("A", 44);
			LeaveRule("A", 44);
			LeaveRule_A();
		}
	}
	// $ANTLR end "A"

	partial void EnterRule_L();
	partial void LeaveRule_L();

	// $ANTLR start "L"
	[GrammarRule("L")]
	private void mL()
	{
		EnterRule_L();
		EnterRule("L", 45);
		TraceIn("L", 45);
		try
		{
			// formula.g:152:12: ( 'L' | 'l' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(152, 12);
			if (input.LA(1)=='L'||input.LA(1)=='l')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("L", 45);
			LeaveRule("L", 45);
			LeaveRule_L();
		}
	}
	// $ANTLR end "L"

	partial void EnterRule_S();
	partial void LeaveRule_S();

	// $ANTLR start "S"
	[GrammarRule("S")]
	private void mS()
	{
		EnterRule_S();
		EnterRule("S", 46);
		TraceIn("S", 46);
		try
		{
			// formula.g:153:12: ( 'S' | 's' )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(153, 12);
			if (input.LA(1)=='S'||input.LA(1)=='s')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("S", 46);
			LeaveRule("S", 46);
			LeaveRule_S();
		}
	}
	// $ANTLR end "S"

	partial void EnterRule_FUNCTION_NAME();
	partial void LeaveRule_FUNCTION_NAME();

	// $ANTLR start "FUNCTION_NAME"
	[GrammarRule("FUNCTION_NAME")]
	private void mFUNCTION_NAME()
	{
		EnterRule_FUNCTION_NAME();
		EnterRule("FUNCTION_NAME", 47);
		TraceIn("FUNCTION_NAME", 47);
		try
		{
			int _type = FUNCTION_NAME;
			int _channel = DefaultTokenChannel;
			// formula.g:158:2: ( ALFA ( ALFANUM | '.' )* '(' )
			DebugEnterAlt(1);
			// formula.g:158:4: ALFA ( ALFANUM | '.' )* '('
			{
			DebugLocation(158, 4);
			mALFA(); 
			DebugLocation(158, 9);
			// formula.g:158:9: ( ALFANUM | '.' )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1=='.'||(LA9_1>='0' && LA9_1<='9')||(LA9_1>='A' && LA9_1<='Z')||LA9_1=='_'||(LA9_1>='a' && LA9_1<='z')))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(158, 9);
					input.Consume();


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(158, 27);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FUNCTION_NAME", 47);
			LeaveRule("FUNCTION_NAME", 47);
			LeaveRule_FUNCTION_NAME();
		}
	}
	// $ANTLR end "FUNCTION_NAME"

	partial void EnterRule_CELL();
	partial void LeaveRule_CELL();

	// $ANTLR start "CELL"
	[GrammarRule("CELL")]
	private void mCELL()
	{
		EnterRule_CELL();
		EnterRule("CELL", 48);
		TraceIn("CELL", 48);
		try
		{
			int _type = CELL;
			int _channel = DefaultTokenChannel;
			// formula.g:161:2: ( ( '$' )? ( ALFA )+ ( '$' )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// formula.g:161:4: ( '$' )? ( ALFA )+ ( '$' )? ( DIGIT )+
			{
			DebugLocation(161, 4);
			// formula.g:161:4: ( '$' )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1=='$'))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:161:4: '$'
				{
				DebugLocation(161, 4);
				Match('$'); 

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(161, 9);
			// formula.g:161:9: ( ALFA )+
			int cnt11=0;
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if (((LA11_1>='A' && LA11_1<='Z')||(LA11_1>='a' && LA11_1<='z')))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(161, 9);
					input.Consume();


					}
					break;

				default:
					if (cnt11 >= 1)
						goto loop11;

					EarlyExitException eee11 = new EarlyExitException( 11, input );
					DebugRecognitionException(eee11);
					throw eee11;
				}
				cnt11++;
			}
			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(161, 15);
			// formula.g:161:15: ( '$' )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1=='$'))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:161:15: '$'
				{
				DebugLocation(161, 15);
				Match('$'); 

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(161, 20);
			// formula.g:161:20: ( DIGIT )+
			int cnt13=0;
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if (((LA13_1>='0' && LA13_1<='9')))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(161, 20);
					input.Consume();


					}
					break;

				default:
					if (cnt13 >= 1)
						goto loop13;

					EarlyExitException eee13 = new EarlyExitException( 13, input );
					DebugRecognitionException(eee13);
					throw eee13;
				}
				cnt13++;
			}
			loop13:
				;

			} finally { DebugExitSubRule(13); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CELL", 48);
			LeaveRule("CELL", 48);
			LeaveRule_CELL();
		}
	}
	// $ANTLR end "CELL"

	partial void EnterRule_ROW_RANGE();
	partial void LeaveRule_ROW_RANGE();

	// $ANTLR start "ROW_RANGE"
	[GrammarRule("ROW_RANGE")]
	private void mROW_RANGE()
	{
		EnterRule_ROW_RANGE();
		EnterRule("ROW_RANGE", 49);
		TraceIn("ROW_RANGE", 49);
		try
		{
			int _type = ROW_RANGE;
			int _channel = DefaultTokenChannel;
			// formula.g:164:2: ( ( '$' )? ( DIGIT )+ ':' ( '$' )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// formula.g:164:4: ( '$' )? ( DIGIT )+ ':' ( '$' )? ( DIGIT )+
			{
			DebugLocation(164, 4);
			// formula.g:164:4: ( '$' )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1=='$'))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:164:4: '$'
				{
				DebugLocation(164, 4);
				Match('$'); 

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(164, 9);
			// formula.g:164:9: ( DIGIT )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if (((LA15_1>='0' && LA15_1<='9')))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(164, 9);
					input.Consume();


					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(164, 16);
			Match(':'); 
			DebugLocation(164, 20);
			// formula.g:164:20: ( '$' )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1=='$'))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:164:20: '$'
				{
				DebugLocation(164, 20);
				Match('$'); 

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(164, 25);
			// formula.g:164:25: ( DIGIT )+
			int cnt17=0;
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if (((LA17_1>='0' && LA17_1<='9')))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(164, 25);
					input.Consume();


					}
					break;

				default:
					if (cnt17 >= 1)
						goto loop17;

					EarlyExitException eee17 = new EarlyExitException( 17, input );
					DebugRecognitionException(eee17);
					throw eee17;
				}
				cnt17++;
			}
			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ROW_RANGE", 49);
			LeaveRule("ROW_RANGE", 49);
			LeaveRule_ROW_RANGE();
		}
	}
	// $ANTLR end "ROW_RANGE"

	partial void EnterRule_COLUMN_RANGE();
	partial void LeaveRule_COLUMN_RANGE();

	// $ANTLR start "COLUMN_RANGE"
	[GrammarRule("COLUMN_RANGE")]
	private void mCOLUMN_RANGE()
	{
		EnterRule_COLUMN_RANGE();
		EnterRule("COLUMN_RANGE", 50);
		TraceIn("COLUMN_RANGE", 50);
		try
		{
			int _type = COLUMN_RANGE;
			int _channel = DefaultTokenChannel;
			// formula.g:167:2: ( ( '$' )? ( ALFA )+ ':' ( '$' )? ( ALFA )+ )
			DebugEnterAlt(1);
			// formula.g:167:4: ( '$' )? ( ALFA )+ ':' ( '$' )? ( ALFA )+
			{
			DebugLocation(167, 4);
			// formula.g:167:4: ( '$' )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1=='$'))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:167:4: '$'
				{
				DebugLocation(167, 4);
				Match('$'); 

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(167, 9);
			// formula.g:167:9: ( ALFA )+
			int cnt19=0;
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if (((LA19_1>='A' && LA19_1<='Z')||(LA19_1>='a' && LA19_1<='z')))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(167, 9);
					input.Consume();


					}
					break;

				default:
					if (cnt19 >= 1)
						goto loop19;

					EarlyExitException eee19 = new EarlyExitException( 19, input );
					DebugRecognitionException(eee19);
					throw eee19;
				}
				cnt19++;
			}
			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(167, 15);
			Match(':'); 
			DebugLocation(167, 19);
			// formula.g:167:19: ( '$' )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1=='$'))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:167:19: '$'
				{
				DebugLocation(167, 19);
				Match('$'); 

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(167, 24);
			// formula.g:167:24: ( ALFA )+
			int cnt21=0;
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if (((LA21_1>='A' && LA21_1<='Z')||(LA21_1>='a' && LA21_1<='z')))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(167, 24);
					input.Consume();


					}
					break;

				default:
					if (cnt21 >= 1)
						goto loop21;

					EarlyExitException eee21 = new EarlyExitException( 21, input );
					DebugRecognitionException(eee21);
					throw eee21;
				}
				cnt21++;
			}
			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLUMN_RANGE", 50);
			LeaveRule("COLUMN_RANGE", 50);
			LeaveRule_COLUMN_RANGE();
		}
	}
	// $ANTLR end "COLUMN_RANGE"

	partial void EnterRule_RANGE();
	partial void LeaveRule_RANGE();

	// $ANTLR start "RANGE"
	[GrammarRule("RANGE")]
	private void mRANGE()
	{
		EnterRule_RANGE();
		EnterRule("RANGE", 51);
		TraceIn("RANGE", 51);
		try
		{
			int _type = RANGE;
			int _channel = DefaultTokenChannel;
			// formula.g:170:2: ( CELL ':' CELL )
			DebugEnterAlt(1);
			// formula.g:170:4: CELL ':' CELL
			{
			DebugLocation(170, 4);
			mCELL(); 
			DebugLocation(170, 9);
			Match(':'); 
			DebugLocation(170, 13);
			mCELL(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RANGE", 51);
			LeaveRule("RANGE", 51);
			LeaveRule_RANGE();
		}
	}
	// $ANTLR end "RANGE"

	partial void EnterRule_FILEPREFIX();
	partial void LeaveRule_FILEPREFIX();

	// $ANTLR start "FILEPREFIX"
	[GrammarRule("FILEPREFIX")]
	private void mFILEPREFIX()
	{
		EnterRule_FILEPREFIX();
		EnterRule("FILEPREFIX", 52);
		TraceIn("FILEPREFIX", 52);
		try
		{
			// formula.g:175:2: ( '[' (~ ']' )* ']' )
			DebugEnterAlt(1);
			// formula.g:175:4: '[' (~ ']' )* ']'
			{
			DebugLocation(175, 4);
			Match('['); 
			DebugLocation(175, 8);
			// formula.g:175:8: (~ ']' )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if (((LA22_1>='\u0000' && LA22_1<='\\')||(LA22_1>='^' && LA22_1<='\uFFFF')))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(175, 8);
					input.Consume();


					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(175, 19);
			Match(']'); 

			}

		}
		finally
		{
			TraceOut("FILEPREFIX", 52);
			LeaveRule("FILEPREFIX", 52);
			LeaveRule_FILEPREFIX();
		}
	}
	// $ANTLR end "FILEPREFIX"

	partial void EnterRule_SHEETRANGE();
	partial void LeaveRule_SHEETRANGE();

	// $ANTLR start "SHEETRANGE"
	[GrammarRule("SHEETRANGE")]
	private void mSHEETRANGE()
	{
		EnterRule_SHEETRANGE();
		EnterRule("SHEETRANGE", 53);
		TraceIn("SHEETRANGE", 53);
		try
		{
			// formula.g:179:2: ( '\\'' (~ '\\'' )* '\\'' |~ ( ' ' | '!' ) )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1=='\''))
			{
				int LA24_2 = input.LA(2);

				if (((LA24_2>='\u0000' && LA24_2<='\uFFFF')))
				{
					alt24 = 1;
				}
				else
				{
					alt24 = 2;
				}
			}
			else if (((LA24_1>='\u0000' && LA24_1<='\u001F')||(LA24_1>='\"' && LA24_1<='&')||(LA24_1>='(' && LA24_1<='\uFFFF')))
			{
				alt24 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:179:4: '\\'' (~ '\\'' )* '\\''
				{
				DebugLocation(179, 4);
				Match('\''); 
				DebugLocation(179, 9);
				// formula.g:179:9: (~ '\\'' )*
				try { DebugEnterSubRule(23);
				while (true)
				{
					int alt23=2;
					try { DebugEnterDecision(23, false);
					int LA23_1 = input.LA(1);

					if (((LA23_1>='\u0000' && LA23_1<='&')||(LA23_1>='(' && LA23_1<='\uFFFF')))
					{
						alt23 = 1;
					}


					} finally { DebugExitDecision(23); }
					switch ( alt23 )
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:
						{
						DebugLocation(179, 9);
						input.Consume();


						}
						break;

					default:
						goto loop23;
					}
				}

				loop23:
					;

				} finally { DebugExitSubRule(23); }

				DebugLocation(179, 21);
				Match('\''); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:180:4: ~ ( ' ' | '!' )
				{
				DebugLocation(180, 4);
				input.Consume();


				}
				break;

			}
		}
		finally
		{
			TraceOut("SHEETRANGE", 53);
			LeaveRule("SHEETRANGE", 53);
			LeaveRule_SHEETRANGE();
		}
	}
	// $ANTLR end "SHEETRANGE"

	partial void EnterRule_SHEETPREFIX();
	partial void LeaveRule_SHEETPREFIX();

	// $ANTLR start "SHEETPREFIX"
	[GrammarRule("SHEETPREFIX")]
	private void mSHEETPREFIX()
	{
		EnterRule_SHEETPREFIX();
		EnterRule("SHEETPREFIX", 54);
		TraceIn("SHEETPREFIX", 54);
		try
		{
			int _type = SHEETPREFIX;
			int _channel = DefaultTokenChannel;
			// formula.g:182:2: ( ( FILEPREFIX )? SHEETRANGE '!' )
			DebugEnterAlt(1);
			// formula.g:182:4: ( FILEPREFIX )? SHEETRANGE '!'
			{
			DebugLocation(182, 4);
			// formula.g:182:4: ( FILEPREFIX )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1=='['))
			{
				int LA25_2 = input.LA(2);

				if ((LA25_2=='!'))
				{
					int LA25_3 = input.LA(3);

					if (((LA25_3>='\u0000' && LA25_3<='\uFFFF')))
					{
						alt25 = 1;
					}
				}
				else if (((LA25_2>='\u0000' && LA25_2<=' ')||(LA25_2>='\"' && LA25_2<='\uFFFF')))
				{
					alt25 = 1;
				}
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:182:4: FILEPREFIX
				{
				DebugLocation(182, 4);
				mFILEPREFIX(); 

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(182, 17);
			mSHEETRANGE(); 
			DebugLocation(182, 28);
			Match('!'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SHEETPREFIX", 54);
			LeaveRule("SHEETPREFIX", 54);
			LeaveRule_SHEETPREFIX();
		}
	}
	// $ANTLR end "SHEETPREFIX"

	partial void EnterRule_DEFINED_NAME();
	partial void LeaveRule_DEFINED_NAME();

	// $ANTLR start "DEFINED_NAME"
	[GrammarRule("DEFINED_NAME")]
	private void mDEFINED_NAME()
	{
		EnterRule_DEFINED_NAME();
		EnterRule("DEFINED_NAME", 55);
		TraceIn("DEFINED_NAME", 55);
		try
		{
			int _type = DEFINED_NAME;
			int _channel = DefaultTokenChannel;
			// formula.g:185:2: ( ALFA_ ( ALFANUM )* )
			DebugEnterAlt(1);
			// formula.g:185:4: ALFA_ ( ALFANUM )*
			{
			DebugLocation(185, 4);
			mALFA_(); 
			DebugLocation(185, 10);
			// formula.g:185:10: ( ALFANUM )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if (((LA26_1>='0' && LA26_1<='9')||(LA26_1>='A' && LA26_1<='Z')||LA26_1=='_'||(LA26_1>='a' && LA26_1<='z')))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(185, 10);
					input.Consume();


					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEFINED_NAME", 55);
			LeaveRule("DEFINED_NAME", 55);
			LeaveRule_DEFINED_NAME();
		}
	}
	// $ANTLR end "DEFINED_NAME"

	partial void EnterRule_WHITESPACE();
	partial void LeaveRule_WHITESPACE();

	// $ANTLR start "WHITESPACE"
	[GrammarRule("WHITESPACE")]
	private void mWHITESPACE()
	{
		EnterRule_WHITESPACE();
		EnterRule("WHITESPACE", 56);
		TraceIn("WHITESPACE", 56);
		try
		{
			int _type = WHITESPACE;
			int _channel = DefaultTokenChannel;
			// formula.g:188:2: ( ( ' ' )+ )
			DebugEnterAlt(1);
			// formula.g:188:4: ( ' ' )+
			{
			DebugLocation(188, 4);
			// formula.g:188:4: ( ' ' )+
			int cnt27=0;
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==' '))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:188:4: ' '
					{
					DebugLocation(188, 4);
					Match(' '); 

					}
					break;

				default:
					if (cnt27 >= 1)
						goto loop27;

					EarlyExitException eee27 = new EarlyExitException( 27, input );
					DebugRecognitionException(eee27);
					throw eee27;
				}
				cnt27++;
			}
			loop27:
				;

			} finally { DebugExitSubRule(27); }

			DebugLocation(188, 10);
			 _channel = Hidden; 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHITESPACE", 56);
			LeaveRule("WHITESPACE", 56);
			LeaveRule_WHITESPACE();
		}
	}
	// $ANTLR end "WHITESPACE"

	public override void mTokens()
	{
		// formula.g:1:8: ( T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | ADD | SUB | MUL | DIV | EXP | CONCAT | LEFT_PAREN | RIGHT_PAREN | LEFT_CURLY | RIGHT_CURLY | PERCENT | ARG_SEPARATOR | EQ | LT | GT | LTE | GTE | NE | STRING | NUMBER | TRUE | FALSE | FUNCTION_NAME | CELL | ROW_RANGE | COLUMN_RANGE | RANGE | SHEETPREFIX | DEFINED_NAME | WHITESPACE )
		int alt28=39;
		try { DebugEnterDecision(28, false);
		try
		{
			alt28 = dfa28.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(28); }
		switch (alt28)
		{
		case 1:
			DebugEnterAlt(1);
			// formula.g:1:10: T__59
			{
			DebugLocation(1, 10);
			mT__59(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// formula.g:1:16: T__60
			{
			DebugLocation(1, 16);
			mT__60(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// formula.g:1:22: T__61
			{
			DebugLocation(1, 22);
			mT__61(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// formula.g:1:28: T__62
			{
			DebugLocation(1, 28);
			mT__62(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// formula.g:1:34: T__63
			{
			DebugLocation(1, 34);
			mT__63(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// formula.g:1:40: T__64
			{
			DebugLocation(1, 40);
			mT__64(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// formula.g:1:46: T__65
			{
			DebugLocation(1, 46);
			mT__65(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// formula.g:1:52: T__66
			{
			DebugLocation(1, 52);
			mT__66(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// formula.g:1:58: T__67
			{
			DebugLocation(1, 58);
			mT__67(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// formula.g:1:64: ADD
			{
			DebugLocation(1, 64);
			mADD(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// formula.g:1:68: SUB
			{
			DebugLocation(1, 68);
			mSUB(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// formula.g:1:72: MUL
			{
			DebugLocation(1, 72);
			mMUL(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// formula.g:1:76: DIV
			{
			DebugLocation(1, 76);
			mDIV(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// formula.g:1:80: EXP
			{
			DebugLocation(1, 80);
			mEXP(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// formula.g:1:84: CONCAT
			{
			DebugLocation(1, 84);
			mCONCAT(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// formula.g:1:91: LEFT_PAREN
			{
			DebugLocation(1, 91);
			mLEFT_PAREN(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// formula.g:1:102: RIGHT_PAREN
			{
			DebugLocation(1, 102);
			mRIGHT_PAREN(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// formula.g:1:114: LEFT_CURLY
			{
			DebugLocation(1, 114);
			mLEFT_CURLY(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// formula.g:1:125: RIGHT_CURLY
			{
			DebugLocation(1, 125);
			mRIGHT_CURLY(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// formula.g:1:137: PERCENT
			{
			DebugLocation(1, 137);
			mPERCENT(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// formula.g:1:145: ARG_SEPARATOR
			{
			DebugLocation(1, 145);
			mARG_SEPARATOR(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// formula.g:1:159: EQ
			{
			DebugLocation(1, 159);
			mEQ(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// formula.g:1:162: LT
			{
			DebugLocation(1, 162);
			mLT(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// formula.g:1:165: GT
			{
			DebugLocation(1, 165);
			mGT(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// formula.g:1:168: LTE
			{
			DebugLocation(1, 168);
			mLTE(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// formula.g:1:172: GTE
			{
			DebugLocation(1, 172);
			mGTE(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// formula.g:1:176: NE
			{
			DebugLocation(1, 176);
			mNE(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// formula.g:1:179: STRING
			{
			DebugLocation(1, 179);
			mSTRING(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// formula.g:1:186: NUMBER
			{
			DebugLocation(1, 186);
			mNUMBER(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// formula.g:1:193: TRUE
			{
			DebugLocation(1, 193);
			mTRUE(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// formula.g:1:198: FALSE
			{
			DebugLocation(1, 198);
			mFALSE(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// formula.g:1:204: FUNCTION_NAME
			{
			DebugLocation(1, 204);
			mFUNCTION_NAME(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// formula.g:1:218: CELL
			{
			DebugLocation(1, 218);
			mCELL(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// formula.g:1:223: ROW_RANGE
			{
			DebugLocation(1, 223);
			mROW_RANGE(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// formula.g:1:233: COLUMN_RANGE
			{
			DebugLocation(1, 233);
			mCOLUMN_RANGE(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// formula.g:1:246: RANGE
			{
			DebugLocation(1, 246);
			mRANGE(); 

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// formula.g:1:252: SHEETPREFIX
			{
			DebugLocation(1, 252);
			mSHEETPREFIX(); 

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// formula.g:1:264: DEFINED_NAME
			{
			DebugLocation(1, 264);
			mDEFINED_NAME(); 

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// formula.g:1:277: WHITESPACE
			{
			DebugLocation(1, 277);
			mWHITESPACE(); 

			}
			break;

		}

	}


	#region DFA
	DFA28 dfa28;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa28 = new DFA28(this, SpecialStateTransition28);
	}

	private class DFA28 : DFA
	{
		private const string DFA28_eotS =
			"\x2\xFFFF\x1\x20\x1\x21\x1\x22\x1\x23\x1\x24\x1\x25\x1\x26\x1\x27\x1"+
			"\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x2D\x1\x2E\x1\x31\x1\x33\x1\xFFFF"+
			"\x1\x36\x3\x39\x2\xFFFF\x1\x39\x19\xFFFF\x1\x19\x2\xFFFF\x1\x36\x2\xFFFF"+
			"\x1\x39\x1\x47\x2\xFFFF\x2\x39\x1\xFFFF\x1\x39\x4\xFFFF\x1\x39\x2\xFFFF"+
			"\x1\x47\x1\x39\x2\xFFFF\x1\x4F\x1\x39\x1\xFFFF\x1\x51\x1\xFFFF";
		private const string DFA28_eofS =
			"\x52\xFFFF";
		private const string DFA28_minS =
			"\x1\x0\x12\x21\x1\x0\x5\x21\x1\xFFFF\x1\x21\x2\xFFFF\x1\x2F\x16\xFFFF"+
			"\x1\x0\x2\xFFFF\x1\x30\x2\xFFFF\x1\x24\x1\x28\x1\xFFFF\x1\x30\x1\x24"+
			"\x1\x28\x1\xFFFF\x2\x24\x2\xFFFF\x1\x4C\x1\x24\x2\xFFFF\x1\x30\x1\x24"+
			"\x2\xFFFF\x2\x24\x1\xFFFF\x1\x24\x1\xFFFF";
		private const string DFA28_maxS =
			"\x1\xFFFF\x1\x56\xF\x21\x1\x3E\x1\x3D\x1\xFFFF\x1\x3A\x4\x7A\x1\xFFFF"+
			"\x1\x21\x2\xFFFF\x1\x55\x16\xFFFF\x1\xFFFF\x2\xFFFF\x1\x3A\x2\xFFFF\x2"+
			"\x7A\x1\xFFFF\x1\x39\x2\x7A\x1\xFFFF\x2\x7A\x2\xFFFF\x1\x4D\x1\x7A\x2"+
			"\xFFFF\x1\x3A\x1\x7A\x2\xFFFF\x2\x7A\x1\xFFFF\x1\x7A\x1\xFFFF";
		private const string DFA28_acceptS =
			"\x19\xFFFF\x1\x25\x1\xFFFF\x1\x27\x1\x1\x1\xFFFF\x1\x6\x1\x7\x1\x8\x1"+
			"\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1\x13\x1"+
			"\x14\x1\x15\x1\x16\x1\x19\x1\x1B\x1\x17\x1\x1A\x1\x18\x1\xFFFF\x1\x1C"+
			"\x1\x1D\x1\xFFFF\x1\x22\x1\x26\x2\xFFFF\x1\x20\x3\xFFFF\x1\x23\x2\xFFFF"+
			"\x1\x2\x1\x3\x2\xFFFF\x1\x21\x1\x24\x2\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1"+
			"\x1E\x1\xFFFF\x1\x1F";
		private const string DFA28_specialS =
			"\x1\x0\x12\xFFFF\x1\x1\x20\xFFFF\x1\x2\x1D\xFFFF}>";
		private static readonly string[] DFA28_transitionS =
			{
				"\x20\x19\x1\x1B\x1\xFFFF\x1\x13\x1\x1\x1\x18\x1\xE\x1\x9\x1\x19\x1\xA"+
				"\x1\xB\x1\x6\x1\x4\x1\xF\x1\x5\x1\x19\x1\x7\xA\x14\x1\x2\x1\x3\x1\x11"+
				"\x1\x10\x1\x12\x2\x19\x5\x17\x1\x16\xD\x17\x1\x15\x6\x17\x3\x19\x1\x8"+
				"\x1\x1A\x1\x19\x5\x17\x1\x16\xD\x17\x1\x15\x6\x17\x1\xC\x1\x19\x1\xD"+
				"\xFF82\x19",
				"\x1\x19\x22\xFFFF\x1\x1C\x9\xFFFF\x1\x1D\x3\xFFFF\x1\x1E\x3\xFFFF\x1"+
				"\x1F",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19",
				"\x1\x19\x1B\xFFFF\x1\x2F\x1\x30",
				"\x1\x19\x1B\xFFFF\x1\x32",
				"\x21\x35\x1\x34\xFFDE\x35",
				"\x1\x19\xE\xFFFF\xA\x37\x1\x38",
				"\x1\x19\x2\xFFFF\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA"+
				"\x3B\x1\x40\x6\xFFFF\x11\x3E\x1\x3A\x8\x3E\x4\xFFFF\x1\x3F\x1\xFFFF"+
				"\x11\x3E\x1\x3A\x8\x3E",
				"\x1\x19\x2\xFFFF\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA"+
				"\x3B\x1\x40\x6\xFFFF\x1\x41\x19\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x1\x41"+
				"\x19\x3E",
				"\x1\x19\x2\xFFFF\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA"+
				"\x3B\x1\x40\x6\xFFFF\x1A\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x1A\x3E",
				"\x1\x19\xE\xFFFF\xA\x38\x7\xFFFF\x1A\x42\x6\xFFFF\x1A\x42",
				"",
				"\x1\x19",
				"",
				"",
				"\x1\x43\x11\xFFFF\x1\x44\x13\xFFFF\x1\x45",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x0\x35",
				"",
				"",
				"\xA\x37\x1\x38",
				"",
				"",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x14\x3E\x1\x46\x5\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x14\x3E\x1\x46\x5\x3E",
				"\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x48\x6\xFFFF\x1A\x3F\x4\xFFFF"+
				"\x1\x3F\x1\xFFFF\x1A\x3F",
				"",
				"\xA\x49",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x1A\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x1A\x3E",
				"\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3F\x7\xFFFF\x1A\x3F\x4\xFFFF\x1"+
				"\x3F\x1\xFFFF\x1A\x3F",
				"",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\xB\x3E\x1\x4A\xE\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\xB\x3E\x1\x4A\xE\x3E",
				"\x1\x3D\xB\xFFFF\xA\x49\x1\x40\x6\xFFFF\x1A\x42\x6\xFFFF\x1A\x42",
				"",
				"",
				"\x1\x4B\x1\x4C",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x4\x3E\x1\x4D\x15\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x4\x3E\x1\x4D\x15\x3E",
				"",
				"",
				"\xA\x49\x1\x48",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x12\x3E\x1\x4E\x7\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x12\x3E\x1\x4E\x7\x3E",
				"",
				"",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x1A\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x1A\x3E",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x4\x3E\x1\x50\x15\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x4\x3E\x1\x50\x15\x3E",
				"",
				"\x1\x3D\x3\xFFFF\x1\x3C\x5\xFFFF\x1\x3C\x1\xFFFF\xA\x3B\x1\x40\x6\xFFFF"+
				"\x1A\x3E\x4\xFFFF\x1\x3F\x1\xFFFF\x1A\x3E",
				""
			};

		private static readonly short[] DFA28_eot = DFA.UnpackEncodedString(DFA28_eotS);
		private static readonly short[] DFA28_eof = DFA.UnpackEncodedString(DFA28_eofS);
		private static readonly char[] DFA28_min = DFA.UnpackEncodedStringToUnsignedChars(DFA28_minS);
		private static readonly char[] DFA28_max = DFA.UnpackEncodedStringToUnsignedChars(DFA28_maxS);
		private static readonly short[] DFA28_accept = DFA.UnpackEncodedString(DFA28_acceptS);
		private static readonly short[] DFA28_special = DFA.UnpackEncodedString(DFA28_specialS);
		private static readonly short[][] DFA28_transition;

		static DFA28()
		{
			int numStates = DFA28_transitionS.Length;
			DFA28_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA28_transition[i] = DFA.UnpackEncodedString(DFA28_transitionS[i]);
			}
		}

		public DFA28( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 28;
			this.eot = DFA28_eot;
			this.eof = DFA28_eof;
			this.min = DFA28_min;
			this.max = DFA28_max;
			this.accept = DFA28_accept;
			this.special = DFA28_special;
			this.transition = DFA28_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | ADD | SUB | MUL | DIV | EXP | CONCAT | LEFT_PAREN | RIGHT_PAREN | LEFT_CURLY | RIGHT_CURLY | PERCENT | ARG_SEPARATOR | EQ | LT | GT | LTE | GTE | NE | STRING | NUMBER | TRUE | FALSE | FUNCTION_NAME | CELL | ROW_RANGE | COLUMN_RANGE | RANGE | SHEETPREFIX | DEFINED_NAME | WHITESPACE );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition28(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA28_1 = input.LA(1);
		int index28_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				if ((LA28_1=='#')) {s = 1;}

				else if ((LA28_1==':')) {s = 2;}

				else if ((LA28_1==';')) {s = 3;}

				else if ((LA28_1=='+')) {s = 4;}

				else if ((LA28_1=='-')) {s = 5;}

				else if ((LA28_1=='*')) {s = 6;}

				else if ((LA28_1=='/')) {s = 7;}

				else if ((LA28_1=='^')) {s = 8;}

				else if ((LA28_1=='&')) {s = 9;}

				else if ((LA28_1=='(')) {s = 10;}

				else if ((LA28_1==')')) {s = 11;}

				else if ((LA28_1=='{')) {s = 12;}

				else if ((LA28_1=='}')) {s = 13;}

				else if ((LA28_1=='%')) {s = 14;}

				else if ((LA28_1==',')) {s = 15;}

				else if ((LA28_1=='=')) {s = 16;}

				else if ((LA28_1=='<')) {s = 17;}

				else if ((LA28_1=='>')) {s = 18;}

				else if ((LA28_1=='\"')) {s = 19;}

				else if (((LA28_1>='0' && LA28_1<='9'))) {s = 20;}

				else if ((LA28_1=='T'||LA28_1=='t')) {s = 21;}

				else if ((LA28_1=='F'||LA28_1=='f')) {s = 22;}

				else if (((LA28_1>='A' && LA28_1<='E')||(LA28_1>='G' && LA28_1<='S')||(LA28_1>='U' && LA28_1<='Z')||(LA28_1>='a' && LA28_1<='e')||(LA28_1>='g' && LA28_1<='s')||(LA28_1>='u' && LA28_1<='z'))) {s = 23;}

				else if ((LA28_1=='$')) {s = 24;}

				else if (((LA28_1>='\u0000' && LA28_1<='\u001F')||LA28_1=='\''||LA28_1=='.'||(LA28_1>='?' && LA28_1<='@')||(LA28_1>='[' && LA28_1<=']')||LA28_1=='`'||LA28_1=='|'||(LA28_1>='~' && LA28_1<='\uFFFF'))) {s = 25;}

				else if ((LA28_1=='_')) {s = 26;}

				else if ((LA28_1==' ')) {s = 27;}

				break;
			}
		case 1:
			{
				if ((LA28_1=='!')) {s = 52;}

				else if (((LA28_1>='\u0000' && LA28_1<=' ')||(LA28_1>='\"' && LA28_1<='\uFFFF'))) {s = 53;}

				break;
			}
		case 2:
			{
				if (((LA28_1>='\u0000' && LA28_1<='\uFFFF'))) {s = 53;}

				else s = 25;

				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		NoViableAltException nvae = new NoViableAltException(dfa.Description, 28, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
 
	#endregion

}
