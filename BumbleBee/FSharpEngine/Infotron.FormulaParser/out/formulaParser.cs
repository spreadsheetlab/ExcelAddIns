//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 formula.g 2011-12-08 16:00:29

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Infotron.FormulaParser 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class formulaParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "A", "ADD", "ALFA", "ALFANUM", "ALFA_", "ARG_SEPARATOR", "ARRAY", "CALL", "CELL", "COLUMN", "COLUMN_RANGE", "CONCAT", "DEFINED_NAME", "DIGIT", "DIV", "E", "EQ", "ERROR", "EXP", "F", "FALSE", "FILEPREFIX", "FUNCTION_NAME", "GT", "GTE", "INTERSECTION", "L", "LEFT_CURLY", "LEFT_PAREN", "LT", "LTE", "MUL", "NAME", "NE", "NUMBER", "PAREN", "PERCENT", "R", "RANGE", "RIGHT_CURLY", "RIGHT_PAREN", "ROW", "ROW_RANGE", "S", "SHEET", "SHEETPREFIX", "SHEETRANGE", "SIGN", "STRING", "SUB", "T", "TRUE", "U", "UNION", "WHITESPACE", "'#DIV/0!'", "'#N/A'", "'#NAME?'", "'#NULL!'", "'#NUM!'", "'#REF!'", "'#VALUE!'", "':'", "';'"
	};
	public const int EOF=-1;
	public const int A=4;
	public const int ADD=5;
	public const int ALFA=6;
	public const int ALFANUM=7;
	public const int ALFA_=8;
	public const int ARG_SEPARATOR=9;
	public const int ARRAY=10;
	public const int CALL=11;
	public const int CELL=12;
	public const int COLUMN=13;
	public const int COLUMN_RANGE=14;
	public const int CONCAT=15;
	public const int DEFINED_NAME=16;
	public const int DIGIT=17;
	public const int DIV=18;
	public const int E=19;
	public const int EQ=20;
	public const int ERROR=21;
	public const int EXP=22;
	public const int F=23;
	public const int FALSE=24;
	public const int FILEPREFIX=25;
	public const int FUNCTION_NAME=26;
	public const int GT=27;
	public const int GTE=28;
	public const int INTERSECTION=29;
	public const int L=30;
	public const int LEFT_CURLY=31;
	public const int LEFT_PAREN=32;
	public const int LT=33;
	public const int LTE=34;
	public const int MUL=35;
	public const int NAME=36;
	public const int NE=37;
	public const int NUMBER=38;
	public const int PAREN=39;
	public const int PERCENT=40;
	public const int R=41;
	public const int RANGE=42;
	public const int RIGHT_CURLY=43;
	public const int RIGHT_PAREN=44;
	public const int ROW=45;
	public const int ROW_RANGE=46;
	public const int S=47;
	public const int SHEET=48;
	public const int SHEETPREFIX=49;
	public const int SHEETRANGE=50;
	public const int SIGN=51;
	public const int STRING=52;
	public const int SUB=53;
	public const int T=54;
	public const int TRUE=55;
	public const int U=56;
	public const int UNION=57;
	public const int WHITESPACE=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;

	public formulaParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public formulaParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return formulaParser.tokenNames; } }
	public override string GrammarFileName { get { return "formula.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_formula();
	partial void LeaveRule_formula();
	// $ANTLR start "formula"
	// formula.g:193:1: public formula : '=' ! expression EOF !;
	[GrammarRule("formula")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> formula()
	{
		EnterRule_formula();
		EnterRule("formula", 1);
		TraceIn("formula", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal1 = default(CommonToken);
		CommonToken EOF3 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression2 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal1_tree = default(CommonTree);
		CommonTree EOF3_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "formula");
		DebugLocation(193, 23);
		try
		{
			// formula.g:194:2: ( '=' ! expression EOF !)
			DebugEnterAlt(1);
			// formula.g:194:4: '=' ! expression EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(194, 7);
			char_literal1=(CommonToken)Match(input,EQ,Follow._EQ_in_formula798); 
			DebugLocation(194, 9);
			PushFollow(Follow._expression_in_formula801);
			expression2=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression2.Tree);
			DebugLocation(194, 23);
			EOF3=(CommonToken)Match(input,EOF,Follow._EOF_in_formula803); 

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formula", 1);
			LeaveRule("formula", 1);
			LeaveRule_formula();
		}
		DebugLocation(194, 23);
		} finally { DebugExitRule(GrammarFileName, "formula"); }
		return retval;

	}
	// $ANTLR end "formula"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// formula.g:196:1: expression : ( arrayExpression | scalarExpression );
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 2);
		TraceIn("expression", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> arrayExpression4 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> scalarExpression5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(196, 1);
		try
		{
			// formula.g:197:2: ( arrayExpression | scalarExpression )
			int alt1=2;
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==LEFT_CURLY))
			{
				alt1 = 1;
			}
			else if ((LA1_1==ADD||LA1_1==CELL||LA1_1==COLUMN_RANGE||LA1_1==DEFINED_NAME||LA1_1==FALSE||LA1_1==FUNCTION_NAME||LA1_1==LEFT_PAREN||LA1_1==NUMBER||LA1_1==RANGE||LA1_1==ROW_RANGE||LA1_1==SHEETPREFIX||(LA1_1>=STRING && LA1_1<=SUB)||LA1_1==TRUE||(LA1_1>=59 && LA1_1<=65)))
			{
				alt1 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:197:4: arrayExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(197, 4);
				PushFollow(Follow._arrayExpression_in_expression813);
				arrayExpression4=arrayExpression();
				PopFollow();

				adaptor.AddChild(root_0, arrayExpression4.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:198:4: scalarExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(198, 4);
				PushFollow(Follow._scalarExpression_in_expression818);
				scalarExpression5=scalarExpression();
				PopFollow();

				adaptor.AddChild(root_0, scalarExpression5.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 2);
			LeaveRule("expression", 2);
			LeaveRule_expression();
		}
		DebugLocation(199, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_arrayExpression();
	partial void LeaveRule_arrayExpression();
	// $ANTLR start "arrayExpression"
	// formula.g:201:1: arrayExpression : '{' arrayRow '}' -> ^( ARRAY arrayRow ) ;
	[GrammarRule("arrayExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> arrayExpression()
	{
		EnterRule_arrayExpression();
		EnterRule("arrayExpression", 3);
		TraceIn("arrayExpression", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal6 = default(CommonToken);
		CommonToken char_literal8 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> arrayRow7 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal6_tree = default(CommonTree);
		CommonTree char_literal8_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LEFT_CURLY=new RewriteRuleITokenStream(adaptor,"token LEFT_CURLY");
		RewriteRuleITokenStream stream_RIGHT_CURLY=new RewriteRuleITokenStream(adaptor,"token RIGHT_CURLY");
		RewriteRuleSubtreeStream stream_arrayRow=new RewriteRuleSubtreeStream(adaptor,"rule arrayRow");
		try { DebugEnterRule(GrammarFileName, "arrayExpression");
		DebugLocation(201, 1);
		try
		{
			// formula.g:202:2: ( '{' arrayRow '}' -> ^( ARRAY arrayRow ) )
			DebugEnterAlt(1);
			// formula.g:202:4: '{' arrayRow '}'
			{
			DebugLocation(202, 4);
			char_literal6=(CommonToken)Match(input,LEFT_CURLY,Follow._LEFT_CURLY_in_arrayExpression830);  
			stream_LEFT_CURLY.Add(char_literal6);

			DebugLocation(202, 8);
			PushFollow(Follow._arrayRow_in_arrayExpression832);
			arrayRow7=arrayRow();
			PopFollow();

			stream_arrayRow.Add(arrayRow7.Tree);
			DebugLocation(202, 17);
			char_literal8=(CommonToken)Match(input,RIGHT_CURLY,Follow._RIGHT_CURLY_in_arrayExpression834);  
			stream_RIGHT_CURLY.Add(char_literal8);



			{
			// AST REWRITE
			// elements: arrayRow
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 202:21: -> ^( ARRAY arrayRow )
			{
				DebugLocation(202, 24);
				// formula.g:202:24: ^( ARRAY arrayRow )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(202, 26);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY, "ARRAY"), root_1);

				DebugLocation(202, 32);
				adaptor.AddChild(root_1, stream_arrayRow.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayExpression", 3);
			LeaveRule("arrayExpression", 3);
			LeaveRule_arrayExpression();
		}
		DebugLocation(203, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayExpression"); }
		return retval;

	}
	// $ANTLR end "arrayExpression"

	partial void EnterRule_arrayRow();
	partial void LeaveRule_arrayRow();
	// $ANTLR start "arrayRow"
	// formula.g:205:1: arrayRow : arrayColumn ( ';' ^ arrayColumn )* ;
	[GrammarRule("arrayRow")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> arrayRow()
	{
		EnterRule_arrayRow();
		EnterRule("arrayRow", 4);
		TraceIn("arrayRow", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal10 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> arrayColumn9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> arrayColumn11 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal10_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "arrayRow");
		DebugLocation(205, 1);
		try
		{
			// formula.g:206:2: ( arrayColumn ( ';' ^ arrayColumn )* )
			DebugEnterAlt(1);
			// formula.g:206:4: arrayColumn ( ';' ^ arrayColumn )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(206, 4);
			PushFollow(Follow._arrayColumn_in_arrayRow853);
			arrayColumn9=arrayColumn();
			PopFollow();

			adaptor.AddChild(root_0, arrayColumn9.Tree);
			DebugLocation(206, 16);
			// formula.g:206:16: ( ';' ^ arrayColumn )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==67))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:206:18: ';' ^ arrayColumn
					{
					DebugLocation(206, 21);
					char_literal10=(CommonToken)Match(input,67,Follow._67_in_arrayRow857); 
					char_literal10_tree = (CommonTree)adaptor.Create(char_literal10);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal10_tree, root_0);
					DebugLocation(206, 23);
					PushFollow(Follow._arrayColumn_in_arrayRow860);
					arrayColumn11=arrayColumn();
					PopFollow();

					adaptor.AddChild(root_0, arrayColumn11.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayRow", 4);
			LeaveRule("arrayRow", 4);
			LeaveRule_arrayRow();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayRow"); }
		return retval;

	}
	// $ANTLR end "arrayRow"

	partial void EnterRule_arrayColumn();
	partial void LeaveRule_arrayColumn();
	// $ANTLR start "arrayColumn"
	// formula.g:209:1: arrayColumn : expression ( ',' ^ expression )* ;
	[GrammarRule("arrayColumn")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> arrayColumn()
	{
		EnterRule_arrayColumn();
		EnterRule("arrayColumn", 5);
		TraceIn("arrayColumn", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal13 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression12 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression14 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal13_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "arrayColumn");
		DebugLocation(209, 1);
		try
		{
			// formula.g:210:2: ( expression ( ',' ^ expression )* )
			DebugEnterAlt(1);
			// formula.g:210:4: expression ( ',' ^ expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(210, 4);
			PushFollow(Follow._expression_in_arrayColumn874);
			expression12=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression12.Tree);
			DebugLocation(210, 15);
			// formula.g:210:15: ( ',' ^ expression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==ARG_SEPARATOR))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:210:17: ',' ^ expression
					{
					DebugLocation(210, 20);
					char_literal13=(CommonToken)Match(input,ARG_SEPARATOR,Follow._ARG_SEPARATOR_in_arrayColumn878); 
					char_literal13_tree = (CommonTree)adaptor.Create(char_literal13);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal13_tree, root_0);
					DebugLocation(210, 22);
					PushFollow(Follow._expression_in_arrayColumn881);
					expression14=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression14.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayColumn", 5);
			LeaveRule("arrayColumn", 5);
			LeaveRule_arrayColumn();
		}
		DebugLocation(211, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayColumn"); }
		return retval;

	}
	// $ANTLR end "arrayColumn"

	partial void EnterRule_scalarExpression();
	partial void LeaveRule_scalarExpression();
	// $ANTLR start "scalarExpression"
	// formula.g:213:1: scalarExpression : conditionalExpression ;
	[GrammarRule("scalarExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> scalarExpression()
	{
		EnterRule_scalarExpression();
		EnterRule("scalarExpression", 6);
		TraceIn("scalarExpression", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> conditionalExpression15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "scalarExpression");
		DebugLocation(213, 1);
		try
		{
			// formula.g:214:2: ( conditionalExpression )
			DebugEnterAlt(1);
			// formula.g:214:4: conditionalExpression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(214, 4);
			PushFollow(Follow._conditionalExpression_in_scalarExpression895);
			conditionalExpression15=conditionalExpression();
			PopFollow();

			adaptor.AddChild(root_0, conditionalExpression15.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("scalarExpression", 6);
			LeaveRule("scalarExpression", 6);
			LeaveRule_scalarExpression();
		}
		DebugLocation(215, 1);
		} finally { DebugExitRule(GrammarFileName, "scalarExpression"); }
		return retval;

	}
	// $ANTLR end "scalarExpression"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// formula.g:217:1: conditionalExpression : concatenateExpression ( ( '=' | '<' | '>' | '<=' | '>=' | '<>' ) ^ concatenateExpression )* ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 7);
		TraceIn("conditionalExpression", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set17 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> concatenateExpression16 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> concatenateExpression18 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree set17_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(217, 1);
		try
		{
			// formula.g:218:2: ( concatenateExpression ( ( '=' | '<' | '>' | '<=' | '>=' | '<>' ) ^ concatenateExpression )* )
			DebugEnterAlt(1);
			// formula.g:218:4: concatenateExpression ( ( '=' | '<' | '>' | '<=' | '>=' | '<>' ) ^ concatenateExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(218, 4);
			PushFollow(Follow._concatenateExpression_in_conditionalExpression906);
			concatenateExpression16=concatenateExpression();
			PopFollow();

			adaptor.AddChild(root_0, concatenateExpression16.Tree);
			DebugLocation(218, 26);
			// formula.g:218:26: ( ( '=' | '<' | '>' | '<=' | '>=' | '<>' ) ^ concatenateExpression )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==EQ||(LA4_1>=GT && LA4_1<=GTE)||(LA4_1>=LT && LA4_1<=LTE)||LA4_1==NE))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:218:28: ( '=' | '<' | '>' | '<=' | '>=' | '<>' ) ^ concatenateExpression
					{
					DebugLocation(218, 66);

					set17=(CommonToken)input.LT(1);
					set17=(CommonToken)input.LT(1);
					if (input.LA(1)==EQ||(input.LA(1)>=GT && input.LA(1)<=GTE)||(input.LA(1)>=LT && input.LA(1)<=LTE)||input.LA(1)==NE)
					{
						input.Consume();
						root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set17), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(218, 68);
					PushFollow(Follow._concatenateExpression_in_conditionalExpression935);
					concatenateExpression18=concatenateExpression();
					PopFollow();

					adaptor.AddChild(root_0, concatenateExpression18.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 7);
			LeaveRule("conditionalExpression", 7);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_concatenateExpression();
	partial void LeaveRule_concatenateExpression();
	// $ANTLR start "concatenateExpression"
	// formula.g:221:1: concatenateExpression : termExpression ( '&' ^ termExpression )* ;
	[GrammarRule("concatenateExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> concatenateExpression()
	{
		EnterRule_concatenateExpression();
		EnterRule("concatenateExpression", 8);
		TraceIn("concatenateExpression", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal20 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> termExpression19 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> termExpression21 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "concatenateExpression");
		DebugLocation(221, 1);
		try
		{
			// formula.g:222:2: ( termExpression ( '&' ^ termExpression )* )
			DebugEnterAlt(1);
			// formula.g:222:4: termExpression ( '&' ^ termExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(222, 4);
			PushFollow(Follow._termExpression_in_concatenateExpression949);
			termExpression19=termExpression();
			PopFollow();

			adaptor.AddChild(root_0, termExpression19.Tree);
			DebugLocation(222, 19);
			// formula.g:222:19: ( '&' ^ termExpression )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==CONCAT))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:222:21: '&' ^ termExpression
					{
					DebugLocation(222, 24);
					char_literal20=(CommonToken)Match(input,CONCAT,Follow._CONCAT_in_concatenateExpression953); 
					char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal20_tree, root_0);
					DebugLocation(222, 26);
					PushFollow(Follow._termExpression_in_concatenateExpression956);
					termExpression21=termExpression();
					PopFollow();

					adaptor.AddChild(root_0, termExpression21.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concatenateExpression", 8);
			LeaveRule("concatenateExpression", 8);
			LeaveRule_concatenateExpression();
		}
		DebugLocation(223, 1);
		} finally { DebugExitRule(GrammarFileName, "concatenateExpression"); }
		return retval;

	}
	// $ANTLR end "concatenateExpression"

	partial void EnterRule_termExpression();
	partial void LeaveRule_termExpression();
	// $ANTLR start "termExpression"
	// formula.g:225:1: termExpression : factorExpression ( ( '+' | '-' ) ^ factorExpression )* ;
	[GrammarRule("termExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> termExpression()
	{
		EnterRule_termExpression();
		EnterRule("termExpression", 9);
		TraceIn("termExpression", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set23 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> factorExpression22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> factorExpression24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree set23_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "termExpression");
		DebugLocation(225, 1);
		try
		{
			// formula.g:226:2: ( factorExpression ( ( '+' | '-' ) ^ factorExpression )* )
			DebugEnterAlt(1);
			// formula.g:226:4: factorExpression ( ( '+' | '-' ) ^ factorExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(226, 4);
			PushFollow(Follow._factorExpression_in_termExpression970);
			factorExpression22=factorExpression();
			PopFollow();

			adaptor.AddChild(root_0, factorExpression22.Tree);
			DebugLocation(226, 21);
			// formula.g:226:21: ( ( '+' | '-' ) ^ factorExpression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==ADD||LA6_1==SUB))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:226:23: ( '+' | '-' ) ^ factorExpression
					{
					DebugLocation(226, 34);

					set23=(CommonToken)input.LT(1);
					set23=(CommonToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==SUB)
					{
						input.Consume();
						root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set23), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(226, 36);
					PushFollow(Follow._factorExpression_in_termExpression983);
					factorExpression24=factorExpression();
					PopFollow();

					adaptor.AddChild(root_0, factorExpression24.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("termExpression", 9);
			LeaveRule("termExpression", 9);
			LeaveRule_termExpression();
		}
		DebugLocation(227, 1);
		} finally { DebugExitRule(GrammarFileName, "termExpression"); }
		return retval;

	}
	// $ANTLR end "termExpression"

	partial void EnterRule_factorExpression();
	partial void LeaveRule_factorExpression();
	// $ANTLR start "factorExpression"
	// formula.g:229:1: factorExpression : powerExpression ( ( '*' | '/' ) ^ powerExpression )* ;
	[GrammarRule("factorExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> factorExpression()
	{
		EnterRule_factorExpression();
		EnterRule("factorExpression", 10);
		TraceIn("factorExpression", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set26 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> powerExpression25 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> powerExpression27 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree set26_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "factorExpression");
		DebugLocation(229, 1);
		try
		{
			// formula.g:230:2: ( powerExpression ( ( '*' | '/' ) ^ powerExpression )* )
			DebugEnterAlt(1);
			// formula.g:230:4: powerExpression ( ( '*' | '/' ) ^ powerExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(230, 4);
			PushFollow(Follow._powerExpression_in_factorExpression997);
			powerExpression25=powerExpression();
			PopFollow();

			adaptor.AddChild(root_0, powerExpression25.Tree);
			DebugLocation(230, 20);
			// formula.g:230:20: ( ( '*' | '/' ) ^ powerExpression )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==DIV||LA7_1==MUL))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:230:22: ( '*' | '/' ) ^ powerExpression
					{
					DebugLocation(230, 33);

					set26=(CommonToken)input.LT(1);
					set26=(CommonToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MUL)
					{
						input.Consume();
						root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set26), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(230, 35);
					PushFollow(Follow._powerExpression_in_factorExpression1010);
					powerExpression27=powerExpression();
					PopFollow();

					adaptor.AddChild(root_0, powerExpression27.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("factorExpression", 10);
			LeaveRule("factorExpression", 10);
			LeaveRule_factorExpression();
		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "factorExpression"); }
		return retval;

	}
	// $ANTLR end "factorExpression"

	partial void EnterRule_powerExpression();
	partial void LeaveRule_powerExpression();
	// $ANTLR start "powerExpression"
	// formula.g:233:1: powerExpression : unaryExpression ( '^' ^ unaryExpression )* ;
	[GrammarRule("powerExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> powerExpression()
	{
		EnterRule_powerExpression();
		EnterRule("powerExpression", 11);
		TraceIn("powerExpression", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal29 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpression28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpression30 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal29_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "powerExpression");
		DebugLocation(233, 1);
		try
		{
			// formula.g:234:2: ( unaryExpression ( '^' ^ unaryExpression )* )
			DebugEnterAlt(1);
			// formula.g:234:4: unaryExpression ( '^' ^ unaryExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(234, 4);
			PushFollow(Follow._unaryExpression_in_powerExpression1024);
			unaryExpression28=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression28.Tree);
			DebugLocation(234, 20);
			// formula.g:234:20: ( '^' ^ unaryExpression )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==EXP))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:234:22: '^' ^ unaryExpression
					{
					DebugLocation(234, 25);
					char_literal29=(CommonToken)Match(input,EXP,Follow._EXP_in_powerExpression1028); 
					char_literal29_tree = (CommonTree)adaptor.Create(char_literal29);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal29_tree, root_0);
					DebugLocation(234, 27);
					PushFollow(Follow._unaryExpression_in_powerExpression1031);
					unaryExpression30=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, unaryExpression30.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("powerExpression", 11);
			LeaveRule("powerExpression", 11);
			LeaveRule_powerExpression();
		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "powerExpression"); }
		return retval;

	}
	// $ANTLR end "powerExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// formula.g:237:1: unaryExpression : ( ( '-' | '+' ) ^ unaryExpression | percentageExpression );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 12);
		TraceIn("unaryExpression", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set31 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpression32 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> percentageExpression33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree set31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(237, 1);
		try
		{
			// formula.g:238:2: ( ( '-' | '+' ) ^ unaryExpression | percentageExpression )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ADD||LA9_1==SUB))
			{
				alt9 = 1;
			}
			else if ((LA9_1==CELL||LA9_1==COLUMN_RANGE||LA9_1==DEFINED_NAME||LA9_1==FALSE||LA9_1==FUNCTION_NAME||LA9_1==LEFT_PAREN||LA9_1==NUMBER||LA9_1==RANGE||LA9_1==ROW_RANGE||LA9_1==SHEETPREFIX||LA9_1==STRING||LA9_1==TRUE||(LA9_1>=59 && LA9_1<=65)))
			{
				alt9 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:238:4: ( '-' | '+' ) ^ unaryExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(238, 15);

				set31=(CommonToken)input.LT(1);
				set31=(CommonToken)input.LT(1);
				if (input.LA(1)==ADD||input.LA(1)==SUB)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set31), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(238, 17);
				PushFollow(Follow._unaryExpression_in_unaryExpression1054);
				unaryExpression32=unaryExpression();
				PopFollow();

				adaptor.AddChild(root_0, unaryExpression32.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:239:4: percentageExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(239, 4);
				PushFollow(Follow._percentageExpression_in_unaryExpression1059);
				percentageExpression33=percentageExpression();
				PopFollow();

				adaptor.AddChild(root_0, percentageExpression33.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 12);
			LeaveRule("unaryExpression", 12);
			LeaveRule_unaryExpression();
		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_percentageExpression();
	partial void LeaveRule_percentageExpression();
	// $ANTLR start "percentageExpression"
	// formula.g:242:1: percentageExpression : primitiveExpression ( '%' ^)* ;
	[GrammarRule("percentageExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> percentageExpression()
	{
		EnterRule_percentageExpression();
		EnterRule("percentageExpression", 13);
		TraceIn("percentageExpression", 13);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal35 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> primitiveExpression34 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal35_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "percentageExpression");
		DebugLocation(242, 1);
		try
		{
			// formula.g:243:2: ( primitiveExpression ( '%' ^)* )
			DebugEnterAlt(1);
			// formula.g:243:4: primitiveExpression ( '%' ^)*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(243, 4);
			PushFollow(Follow._primitiveExpression_in_percentageExpression1070);
			primitiveExpression34=primitiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, primitiveExpression34.Tree);
			DebugLocation(243, 24);
			// formula.g:243:24: ( '%' ^)*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==PERCENT))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:243:26: '%' ^
					{
					DebugLocation(243, 29);
					char_literal35=(CommonToken)Match(input,PERCENT,Follow._PERCENT_in_percentageExpression1074); 
					char_literal35_tree = (CommonTree)adaptor.Create(char_literal35);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal35_tree, root_0);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("percentageExpression", 13);
			LeaveRule("percentageExpression", 13);
			LeaveRule_percentageExpression();
		}
		DebugLocation(244, 1);
		} finally { DebugExitRule(GrammarFileName, "percentageExpression"); }
		return retval;

	}
	// $ANTLR end "percentageExpression"

	partial void EnterRule_primitiveExpression();
	partial void LeaveRule_primitiveExpression();
	// $ANTLR start "primitiveExpression"
	// formula.g:246:1: primitiveExpression : ( literal | nestedExpression | function | cell | referenceExpression );
	[GrammarRule("primitiveExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> primitiveExpression()
	{
		EnterRule_primitiveExpression();
		EnterRule("primitiveExpression", 14);
		TraceIn("primitiveExpression", 14);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> literal36 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> nestedExpression37 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> function38 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> cell39 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> referenceExpression40 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "primitiveExpression");
		DebugLocation(246, 1);
		try
		{
			// formula.g:247:2: ( literal | nestedExpression | function | cell | referenceExpression )
			int alt11=5;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case DEFINED_NAME:
			case FALSE:
			case NUMBER:
			case STRING:
			case TRUE:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 65:
				{
				alt11 = 1;
				}
				break;
			case LEFT_PAREN:
				{
				alt11 = 2;
				}
				break;
			case FUNCTION_NAME:
				{
				alt11 = 3;
				}
				break;
			case SHEETPREFIX:
				{
				int LA11_2 = input.LA(2);

				if ((LA11_2==CELL))
				{
					alt11 = 4;
				}
				else if ((LA11_2==COLUMN_RANGE||LA11_2==RANGE||LA11_2==ROW_RANGE))
				{
					alt11 = 5;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CELL:
				{
				alt11 = 4;
				}
				break;
			case COLUMN_RANGE:
			case RANGE:
			case ROW_RANGE:
				{
				alt11 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:247:4: literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(247, 4);
				PushFollow(Follow._literal_in_primitiveExpression1089);
				literal36=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal36.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:248:4: nestedExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(248, 4);
				PushFollow(Follow._nestedExpression_in_primitiveExpression1094);
				nestedExpression37=nestedExpression();
				PopFollow();

				adaptor.AddChild(root_0, nestedExpression37.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// formula.g:249:4: function
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(249, 4);
				PushFollow(Follow._function_in_primitiveExpression1099);
				function38=function();
				PopFollow();

				adaptor.AddChild(root_0, function38.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// formula.g:250:4: cell
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(250, 4);
				PushFollow(Follow._cell_in_primitiveExpression1104);
				cell39=cell();
				PopFollow();

				adaptor.AddChild(root_0, cell39.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// formula.g:251:4: referenceExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(251, 4);
				PushFollow(Follow._referenceExpression_in_primitiveExpression1109);
				referenceExpression40=referenceExpression();
				PopFollow();

				adaptor.AddChild(root_0, referenceExpression40.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitiveExpression", 14);
			LeaveRule("primitiveExpression", 14);
			LeaveRule_primitiveExpression();
		}
		DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "primitiveExpression"); }
		return retval;

	}
	// $ANTLR end "primitiveExpression"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// formula.g:254:1: literal : ( NUMBER | STRING | boolean | DEFINED_NAME -> ^( NAME DEFINED_NAME ) | errorExpression -> ^( ERROR errorExpression ) );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 15);
		TraceIn("literal", 15);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NUMBER41 = default(CommonToken);
		CommonToken STRING42 = default(CommonToken);
		CommonToken DEFINED_NAME44 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> boolean43 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> errorExpression45 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NUMBER41_tree = default(CommonTree);
		CommonTree STRING42_tree = default(CommonTree);
		CommonTree DEFINED_NAME44_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DEFINED_NAME=new RewriteRuleITokenStream(adaptor,"token DEFINED_NAME");
		RewriteRuleSubtreeStream stream_errorExpression=new RewriteRuleSubtreeStream(adaptor,"rule errorExpression");
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(254, 1);
		try
		{
			// formula.g:255:2: ( NUMBER | STRING | boolean | DEFINED_NAME -> ^( NAME DEFINED_NAME ) | errorExpression -> ^( ERROR errorExpression ) )
			int alt12=5;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case NUMBER:
				{
				alt12 = 1;
				}
				break;
			case STRING:
				{
				alt12 = 2;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt12 = 3;
				}
				break;
			case DEFINED_NAME:
				{
				alt12 = 4;
				}
				break;
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 65:
				{
				alt12 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:255:4: NUMBER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(255, 4);
				NUMBER41=(CommonToken)Match(input,NUMBER,Follow._NUMBER_in_literal1120); 
				NUMBER41_tree = (CommonTree)adaptor.Create(NUMBER41);
				adaptor.AddChild(root_0, NUMBER41_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:256:4: STRING
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(256, 4);
				STRING42=(CommonToken)Match(input,STRING,Follow._STRING_in_literal1126); 
				STRING42_tree = (CommonTree)adaptor.Create(STRING42);
				adaptor.AddChild(root_0, STRING42_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// formula.g:257:4: boolean
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(257, 4);
				PushFollow(Follow._boolean_in_literal1132);
				boolean43=boolean();
				PopFollow();

				adaptor.AddChild(root_0, boolean43.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// formula.g:258:4: DEFINED_NAME
				{
				DebugLocation(258, 4);
				DEFINED_NAME44=(CommonToken)Match(input,DEFINED_NAME,Follow._DEFINED_NAME_in_literal1138);  
				stream_DEFINED_NAME.Add(DEFINED_NAME44);



				{
				// AST REWRITE
				// elements: DEFINED_NAME
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 258:17: -> ^( NAME DEFINED_NAME )
				{
					DebugLocation(258, 20);
					// formula.g:258:20: ^( NAME DEFINED_NAME )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(258, 22);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME, "NAME"), root_1);

					DebugLocation(258, 27);
					adaptor.AddChild(root_1, stream_DEFINED_NAME.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// formula.g:259:4: errorExpression
				{
				DebugLocation(259, 4);
				PushFollow(Follow._errorExpression_in_literal1151);
				errorExpression45=errorExpression();
				PopFollow();

				stream_errorExpression.Add(errorExpression45.Tree);


				{
				// AST REWRITE
				// elements: errorExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 259:20: -> ^( ERROR errorExpression )
				{
					DebugLocation(259, 23);
					// formula.g:259:23: ^( ERROR errorExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(259, 25);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ERROR, "ERROR"), root_1);

					DebugLocation(259, 31);
					adaptor.AddChild(root_1, stream_errorExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 15);
			LeaveRule("literal", 15);
			LeaveRule_literal();
		}
		DebugLocation(260, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"

	partial void EnterRule_referenceExpression();
	partial void LeaveRule_referenceExpression();
	// $ANTLR start "referenceExpression"
	// formula.g:267:1: referenceExpression : range ( ( ':' ^| WHITESPACE ^) range )* ;
	[GrammarRule("referenceExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> referenceExpression()
	{
		EnterRule_referenceExpression();
		EnterRule("referenceExpression", 16);
		TraceIn("referenceExpression", 16);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal47 = default(CommonToken);
		CommonToken WHITESPACE48 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> range46 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> range49 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal47_tree = default(CommonTree);
		CommonTree WHITESPACE48_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "referenceExpression");
		DebugLocation(267, 1);
		try
		{
			// formula.g:268:5: ( range ( ( ':' ^| WHITESPACE ^) range )* )
			DebugEnterAlt(1);
			// formula.g:268:7: range ( ( ':' ^| WHITESPACE ^) range )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(268, 7);
			PushFollow(Follow._range_in_referenceExpression1178);
			range46=range();
			PopFollow();

			adaptor.AddChild(root_0, range46.Tree);
			DebugLocation(268, 13);
			// formula.g:268:13: ( ( ':' ^| WHITESPACE ^) range )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==WHITESPACE||LA14_1==66))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:268:15: ( ':' ^| WHITESPACE ^) range
					{
					DebugLocation(268, 15);
					// formula.g:268:15: ( ':' ^| WHITESPACE ^)
					int alt13=2;
					try { DebugEnterSubRule(13);
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==66))
					{
						alt13 = 1;
					}
					else if ((LA13_1==WHITESPACE))
					{
						alt13 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:268:17: ':' ^
						{
						DebugLocation(268, 20);
						char_literal47=(CommonToken)Match(input,66,Follow._66_in_referenceExpression1184); 
						char_literal47_tree = (CommonTree)adaptor.Create(char_literal47);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal47_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// formula.g:268:24: WHITESPACE ^
						{
						DebugLocation(268, 34);
						WHITESPACE48=(CommonToken)Match(input,WHITESPACE,Follow._WHITESPACE_in_referenceExpression1189); 
						WHITESPACE48_tree = (CommonTree)adaptor.Create(WHITESPACE48);
						root_0 = (CommonTree)adaptor.BecomeRoot(WHITESPACE48_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(13); }

					DebugLocation(268, 38);
					PushFollow(Follow._range_in_referenceExpression1194);
					range49=range();
					PopFollow();

					adaptor.AddChild(root_0, range49.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("referenceExpression", 16);
			LeaveRule("referenceExpression", 16);
			LeaveRule_referenceExpression();
		}
		DebugLocation(269, 1);
		} finally { DebugExitRule(GrammarFileName, "referenceExpression"); }
		return retval;

	}
	// $ANTLR end "referenceExpression"

	partial void EnterRule_range();
	partial void LeaveRule_range();
	// $ANTLR start "range"
	// formula.g:271:1: range : ( SHEETPREFIX r= ( RANGE | COLUMN_RANGE | ROW_RANGE ) -> ^( SHEET SHEETPREFIX $r) | ( RANGE | COLUMN_RANGE | ROW_RANGE ) );
	[GrammarRule("range")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> range()
	{
		EnterRule_range();
		EnterRule("range", 17);
		TraceIn("range", 17);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken r = default(CommonToken);
		CommonToken SHEETPREFIX50 = default(CommonToken);
		CommonToken RANGE51 = default(CommonToken);
		CommonToken COLUMN_RANGE52 = default(CommonToken);
		CommonToken ROW_RANGE53 = default(CommonToken);
		CommonToken set54 = default(CommonToken);

		CommonTree r_tree = default(CommonTree);
		CommonTree SHEETPREFIX50_tree = default(CommonTree);
		CommonTree RANGE51_tree = default(CommonTree);
		CommonTree COLUMN_RANGE52_tree = default(CommonTree);
		CommonTree ROW_RANGE53_tree = default(CommonTree);
		CommonTree set54_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SHEETPREFIX=new RewriteRuleITokenStream(adaptor,"token SHEETPREFIX");
		RewriteRuleITokenStream stream_RANGE=new RewriteRuleITokenStream(adaptor,"token RANGE");
		RewriteRuleITokenStream stream_COLUMN_RANGE=new RewriteRuleITokenStream(adaptor,"token COLUMN_RANGE");
		RewriteRuleITokenStream stream_ROW_RANGE=new RewriteRuleITokenStream(adaptor,"token ROW_RANGE");
		try { DebugEnterRule(GrammarFileName, "range");
		DebugLocation(271, 1);
		try
		{
			// formula.g:272:2: ( SHEETPREFIX r= ( RANGE | COLUMN_RANGE | ROW_RANGE ) -> ^( SHEET SHEETPREFIX $r) | ( RANGE | COLUMN_RANGE | ROW_RANGE ) )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==SHEETPREFIX))
			{
				alt16 = 1;
			}
			else if ((LA16_1==COLUMN_RANGE||LA16_1==RANGE||LA16_1==ROW_RANGE))
			{
				alt16 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:272:4: SHEETPREFIX r= ( RANGE | COLUMN_RANGE | ROW_RANGE )
				{
				DebugLocation(272, 4);
				SHEETPREFIX50=(CommonToken)Match(input,SHEETPREFIX,Follow._SHEETPREFIX_in_range1208);  
				stream_SHEETPREFIX.Add(SHEETPREFIX50);

				DebugLocation(272, 17);
				// formula.g:272:18: ( RANGE | COLUMN_RANGE | ROW_RANGE )
				int alt15=3;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				switch (input.LA(1))
				{
				case RANGE:
					{
					alt15 = 1;
					}
					break;
				case COLUMN_RANGE:
					{
					alt15 = 2;
					}
					break;
				case ROW_RANGE:
					{
					alt15 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:272:19: RANGE
					{
					DebugLocation(272, 19);
					RANGE51=(CommonToken)Match(input,RANGE,Follow._RANGE_in_range1213);  
					stream_RANGE.Add(RANGE51);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// formula.g:272:27: COLUMN_RANGE
					{
					DebugLocation(272, 27);
					COLUMN_RANGE52=(CommonToken)Match(input,COLUMN_RANGE,Follow._COLUMN_RANGE_in_range1217);  
					stream_COLUMN_RANGE.Add(COLUMN_RANGE52);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// formula.g:272:42: ROW_RANGE
					{
					DebugLocation(272, 42);
					ROW_RANGE53=(CommonToken)Match(input,ROW_RANGE,Follow._ROW_RANGE_in_range1221);  
					stream_ROW_RANGE.Add(ROW_RANGE53);


					}
					break;

				}
				} finally { DebugExitSubRule(15); }



				{
				// AST REWRITE
				// elements: SHEETPREFIX, r
				// token labels: r
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_r=new RewriteRuleITokenStream(adaptor,"token r",r);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 272:53: -> ^( SHEET SHEETPREFIX $r)
				{
					DebugLocation(272, 56);
					// formula.g:272:56: ^( SHEET SHEETPREFIX $r)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(272, 58);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SHEET, "SHEET"), root_1);

					DebugLocation(272, 64);
					adaptor.AddChild(root_1, stream_SHEETPREFIX.NextNode());
					DebugLocation(272, 77);
					adaptor.AddChild(root_1, stream_r.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:273:4: ( RANGE | COLUMN_RANGE | ROW_RANGE )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(273, 4);

				set54=(CommonToken)input.LT(1);
				if (input.LA(1)==COLUMN_RANGE||input.LA(1)==RANGE||input.LA(1)==ROW_RANGE)
				{
					input.Consume();
					adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set54));
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("range", 17);
			LeaveRule("range", 17);
			LeaveRule_range();
		}
		DebugLocation(274, 1);
		} finally { DebugExitRule(GrammarFileName, "range"); }
		return retval;

	}
	// $ANTLR end "range"

	partial void EnterRule_cell();
	partial void LeaveRule_cell();
	// $ANTLR start "cell"
	// formula.g:276:1: cell : ( SHEETPREFIX CELL -> ^( SHEET SHEETPREFIX CELL ) | CELL );
	[GrammarRule("cell")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> cell()
	{
		EnterRule_cell();
		EnterRule("cell", 18);
		TraceIn("cell", 18);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken SHEETPREFIX55 = default(CommonToken);
		CommonToken CELL56 = default(CommonToken);
		CommonToken CELL57 = default(CommonToken);

		CommonTree SHEETPREFIX55_tree = default(CommonTree);
		CommonTree CELL56_tree = default(CommonTree);
		CommonTree CELL57_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SHEETPREFIX=new RewriteRuleITokenStream(adaptor,"token SHEETPREFIX");
		RewriteRuleITokenStream stream_CELL=new RewriteRuleITokenStream(adaptor,"token CELL");
		try { DebugEnterRule(GrammarFileName, "cell");
		DebugLocation(276, 1);
		try
		{
			// formula.g:277:2: ( SHEETPREFIX CELL -> ^( SHEET SHEETPREFIX CELL ) | CELL )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==SHEETPREFIX))
			{
				alt17 = 1;
			}
			else if ((LA17_1==CELL))
			{
				alt17 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:277:4: SHEETPREFIX CELL
				{
				DebugLocation(277, 4);
				SHEETPREFIX55=(CommonToken)Match(input,SHEETPREFIX,Follow._SHEETPREFIX_in_cell1259);  
				stream_SHEETPREFIX.Add(SHEETPREFIX55);

				DebugLocation(277, 16);
				CELL56=(CommonToken)Match(input,CELL,Follow._CELL_in_cell1261);  
				stream_CELL.Add(CELL56);



				{
				// AST REWRITE
				// elements: SHEETPREFIX, CELL
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 277:21: -> ^( SHEET SHEETPREFIX CELL )
				{
					DebugLocation(277, 24);
					// formula.g:277:24: ^( SHEET SHEETPREFIX CELL )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(277, 26);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SHEET, "SHEET"), root_1);

					DebugLocation(277, 32);
					adaptor.AddChild(root_1, stream_SHEETPREFIX.NextNode());
					DebugLocation(277, 44);
					adaptor.AddChild(root_1, stream_CELL.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:278:4: CELL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(278, 4);
				CELL57=(CommonToken)Match(input,CELL,Follow._CELL_in_cell1276); 
				CELL57_tree = (CommonTree)adaptor.Create(CELL57);
				adaptor.AddChild(root_0, CELL57_tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cell", 18);
			LeaveRule("cell", 18);
			LeaveRule_cell();
		}
		DebugLocation(279, 1);
		} finally { DebugExitRule(GrammarFileName, "cell"); }
		return retval;

	}
	// $ANTLR end "cell"

	partial void EnterRule_nestedExpression();
	partial void LeaveRule_nestedExpression();
	// $ANTLR start "nestedExpression"
	// formula.g:281:1: nestedExpression : '(' expression ')' -> ^( PAREN expression ) ;
	[GrammarRule("nestedExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> nestedExpression()
	{
		EnterRule_nestedExpression();
		EnterRule("nestedExpression", 19);
		TraceIn("nestedExpression", 19);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal58 = default(CommonToken);
		CommonToken char_literal60 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression59 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal58_tree = default(CommonTree);
		CommonTree char_literal60_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LEFT_PAREN=new RewriteRuleITokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleITokenStream stream_RIGHT_PAREN=new RewriteRuleITokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "nestedExpression");
		DebugLocation(281, 1);
		try
		{
			// formula.g:282:2: ( '(' expression ')' -> ^( PAREN expression ) )
			DebugEnterAlt(1);
			// formula.g:282:4: '(' expression ')'
			{
			DebugLocation(282, 4);
			char_literal58=(CommonToken)Match(input,LEFT_PAREN,Follow._LEFT_PAREN_in_nestedExpression1289);  
			stream_LEFT_PAREN.Add(char_literal58);

			DebugLocation(282, 8);
			PushFollow(Follow._expression_in_nestedExpression1291);
			expression59=expression();
			PopFollow();

			stream_expression.Add(expression59.Tree);
			DebugLocation(282, 19);
			char_literal60=(CommonToken)Match(input,RIGHT_PAREN,Follow._RIGHT_PAREN_in_nestedExpression1293);  
			stream_RIGHT_PAREN.Add(char_literal60);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 282:23: -> ^( PAREN expression )
			{
				DebugLocation(282, 26);
				// formula.g:282:26: ^( PAREN expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(282, 28);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PAREN, "PAREN"), root_1);

				DebugLocation(282, 34);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nestedExpression", 19);
			LeaveRule("nestedExpression", 19);
			LeaveRule_nestedExpression();
		}
		DebugLocation(283, 1);
		} finally { DebugExitRule(GrammarFileName, "nestedExpression"); }
		return retval;

	}
	// $ANTLR end "nestedExpression"

	partial void EnterRule_function();
	partial void LeaveRule_function();
	// $ANTLR start "function"
	// formula.g:285:1: function : FUNCTION_NAME ( argumentList )? ')' -> ^( CALL FUNCTION_NAME argumentList ) ;
	[GrammarRule("function")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> function()
	{
		EnterRule_function();
		EnterRule("function", 20);
		TraceIn("function", 20);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken FUNCTION_NAME61 = default(CommonToken);
		CommonToken char_literal63 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> argumentList62 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree FUNCTION_NAME61_tree = default(CommonTree);
		CommonTree char_literal63_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FUNCTION_NAME=new RewriteRuleITokenStream(adaptor,"token FUNCTION_NAME");
		RewriteRuleITokenStream stream_RIGHT_PAREN=new RewriteRuleITokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleSubtreeStream stream_argumentList=new RewriteRuleSubtreeStream(adaptor,"rule argumentList");
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(285, 1);
		try
		{
			// formula.g:286:2: ( FUNCTION_NAME ( argumentList )? ')' -> ^( CALL FUNCTION_NAME argumentList ) )
			DebugEnterAlt(1);
			// formula.g:286:4: FUNCTION_NAME ( argumentList )? ')'
			{
			DebugLocation(286, 4);
			FUNCTION_NAME61=(CommonToken)Match(input,FUNCTION_NAME,Follow._FUNCTION_NAME_in_function1312);  
			stream_FUNCTION_NAME.Add(FUNCTION_NAME61);

			DebugLocation(286, 18);
			// formula.g:286:18: ( argumentList )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==ADD||LA18_1==CELL||LA18_1==COLUMN_RANGE||LA18_1==DEFINED_NAME||LA18_1==FALSE||LA18_1==FUNCTION_NAME||(LA18_1>=LEFT_CURLY && LA18_1<=LEFT_PAREN)||LA18_1==NUMBER||LA18_1==RANGE||LA18_1==ROW_RANGE||LA18_1==SHEETPREFIX||(LA18_1>=STRING && LA18_1<=SUB)||LA18_1==TRUE||(LA18_1>=59 && LA18_1<=65)))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:286:18: argumentList
				{
				DebugLocation(286, 18);
				PushFollow(Follow._argumentList_in_function1314);
				argumentList62=argumentList();
				PopFollow();

				stream_argumentList.Add(argumentList62.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(286, 32);
			char_literal63=(CommonToken)Match(input,RIGHT_PAREN,Follow._RIGHT_PAREN_in_function1317);  
			stream_RIGHT_PAREN.Add(char_literal63);



			{
			// AST REWRITE
			// elements: FUNCTION_NAME, argumentList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 286:36: -> ^( CALL FUNCTION_NAME argumentList )
			{
				DebugLocation(287, 3);
				// formula.g:287:3: ^( CALL FUNCTION_NAME argumentList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(287, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(287, 10);
				adaptor.AddChild(root_1, stream_FUNCTION_NAME.NextNode());
				DebugLocation(287, 24);
				adaptor.AddChild(root_1, stream_argumentList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function", 20);
			LeaveRule("function", 20);
			LeaveRule_function();
		}
		DebugLocation(288, 1);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return retval;

	}
	// $ANTLR end "function"

	partial void EnterRule_argumentList();
	partial void LeaveRule_argumentList();
	// $ANTLR start "argumentList"
	// formula.g:290:1: argumentList : expression ( ',' ! expression )* ;
	[GrammarRule("argumentList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> argumentList()
	{
		EnterRule_argumentList();
		EnterRule("argumentList", 21);
		TraceIn("argumentList", 21);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal65 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression64 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression66 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal65_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "argumentList");
		DebugLocation(290, 1);
		try
		{
			// formula.g:291:2: ( expression ( ',' ! expression )* )
			DebugEnterAlt(1);
			// formula.g:291:4: expression ( ',' ! expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(291, 4);
			PushFollow(Follow._expression_in_argumentList1340);
			expression64=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression64.Tree);
			DebugLocation(291, 15);
			// formula.g:291:15: ( ',' ! expression )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==ARG_SEPARATOR))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:291:17: ',' ! expression
					{
					DebugLocation(291, 20);
					char_literal65=(CommonToken)Match(input,ARG_SEPARATOR,Follow._ARG_SEPARATOR_in_argumentList1344); 
					DebugLocation(291, 22);
					PushFollow(Follow._expression_in_argumentList1347);
					expression66=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression66.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argumentList", 21);
			LeaveRule("argumentList", 21);
			LeaveRule_argumentList();
		}
		DebugLocation(292, 1);
		} finally { DebugExitRule(GrammarFileName, "argumentList"); }
		return retval;

	}
	// $ANTLR end "argumentList"

	partial void EnterRule_boolean();
	partial void LeaveRule_boolean();
	// $ANTLR start "boolean"
	// formula.g:294:1: boolean : ( TRUE | FALSE );
	[GrammarRule("boolean")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> boolean()
	{
		EnterRule_boolean();
		EnterRule("boolean", 22);
		TraceIn("boolean", 22);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set67 = default(CommonToken);

		CommonTree set67_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "boolean");
		DebugLocation(294, 1);
		try
		{
			// formula.g:295:2: ( TRUE | FALSE )
			DebugEnterAlt(1);
			// formula.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(295, 2);

			set67=(CommonToken)input.LT(1);
			if (input.LA(1)==FALSE||input.LA(1)==TRUE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set67));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("boolean", 22);
			LeaveRule("boolean", 22);
			LeaveRule_boolean();
		}
		DebugLocation(297, 1);
		} finally { DebugExitRule(GrammarFileName, "boolean"); }
		return retval;

	}
	// $ANTLR end "boolean"

	partial void EnterRule_errorExpression();
	partial void LeaveRule_errorExpression();
	// $ANTLR start "errorExpression"
	// formula.g:301:1: errorExpression : ( '#DIV/0!' | '#N/A' | '#NAME?' | '#NULL!' | '#REF!' | '#VALUE!' | '#NUM!' );
	[GrammarRule("errorExpression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> errorExpression()
	{
		EnterRule_errorExpression();
		EnterRule("errorExpression", 23);
		TraceIn("errorExpression", 23);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set68 = default(CommonToken);

		CommonTree set68_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "errorExpression");
		DebugLocation(301, 1);
		try
		{
			// formula.g:302:2: ( '#DIV/0!' | '#N/A' | '#NAME?' | '#NULL!' | '#REF!' | '#VALUE!' | '#NUM!' )
			DebugEnterAlt(1);
			// formula.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(302, 2);

			set68=(CommonToken)input.LT(1);
			if ((input.LA(1)>=59 && input.LA(1)<=65))
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set68));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("errorExpression", 23);
			LeaveRule("errorExpression", 23);
			LeaveRule_errorExpression();
		}
		DebugLocation(309, 1);
		} finally { DebugExitRule(GrammarFileName, "errorExpression"); }
		return retval;

	}
	// $ANTLR end "errorExpression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _EQ_in_formula798 = new BitSet(new ulong[]{0xF8B2444185015020UL,0x3UL});
		public static readonly BitSet _expression_in_formula801 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_formula803 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayExpression_in_expression813 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _scalarExpression_in_expression818 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_CURLY_in_arrayExpression830 = new BitSet(new ulong[]{0xF8B2444185015020UL,0x3UL});
		public static readonly BitSet _arrayRow_in_arrayExpression832 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _RIGHT_CURLY_in_arrayExpression834 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayColumn_in_arrayRow853 = new BitSet(new ulong[]{0x2UL,0x8UL});
		public static readonly BitSet _67_in_arrayRow857 = new BitSet(new ulong[]{0xF8B2444185015020UL,0x3UL});
		public static readonly BitSet _arrayColumn_in_arrayRow860 = new BitSet(new ulong[]{0x2UL,0x8UL});
		public static readonly BitSet _expression_in_arrayColumn874 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ARG_SEPARATOR_in_arrayColumn878 = new BitSet(new ulong[]{0xF8B2444185015020UL,0x3UL});
		public static readonly BitSet _expression_in_arrayColumn881 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _conditionalExpression_in_scalarExpression895 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenateExpression_in_conditionalExpression906 = new BitSet(new ulong[]{0x2618100002UL});
		public static readonly BitSet _set_in_conditionalExpression910 = new BitSet(new ulong[]{0xF8B2444105015020UL,0x3UL});
		public static readonly BitSet _concatenateExpression_in_conditionalExpression935 = new BitSet(new ulong[]{0x2618100002UL});
		public static readonly BitSet _termExpression_in_concatenateExpression949 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _CONCAT_in_concatenateExpression953 = new BitSet(new ulong[]{0xF8B2444105015020UL,0x3UL});
		public static readonly BitSet _termExpression_in_concatenateExpression956 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _factorExpression_in_termExpression970 = new BitSet(new ulong[]{0x20000000000022UL});
		public static readonly BitSet _set_in_termExpression974 = new BitSet(new ulong[]{0xF8B2444105015020UL,0x3UL});
		public static readonly BitSet _factorExpression_in_termExpression983 = new BitSet(new ulong[]{0x20000000000022UL});
		public static readonly BitSet _powerExpression_in_factorExpression997 = new BitSet(new ulong[]{0x800040002UL});
		public static readonly BitSet _set_in_factorExpression1001 = new BitSet(new ulong[]{0xF8B2444105015020UL,0x3UL});
		public static readonly BitSet _powerExpression_in_factorExpression1010 = new BitSet(new ulong[]{0x800040002UL});
		public static readonly BitSet _unaryExpression_in_powerExpression1024 = new BitSet(new ulong[]{0x400002UL});
		public static readonly BitSet _EXP_in_powerExpression1028 = new BitSet(new ulong[]{0xF8B2444105015020UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_powerExpression1031 = new BitSet(new ulong[]{0x400002UL});
		public static readonly BitSet _set_in_unaryExpression1045 = new BitSet(new ulong[]{0xF8B2444105015020UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression1054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _percentageExpression_in_unaryExpression1059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveExpression_in_percentageExpression1070 = new BitSet(new ulong[]{0x10000000002UL});
		public static readonly BitSet _PERCENT_in_percentageExpression1074 = new BitSet(new ulong[]{0x10000000002UL});
		public static readonly BitSet _literal_in_primitiveExpression1089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nestedExpression_in_primitiveExpression1094 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_in_primitiveExpression1099 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cell_in_primitiveExpression1104 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _referenceExpression_in_primitiveExpression1109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_literal1120 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_literal1126 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _boolean_in_literal1132 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEFINED_NAME_in_literal1138 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _errorExpression_in_literal1151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _range_in_referenceExpression1178 = new BitSet(new ulong[]{0x400000000000002UL,0x4UL});
		public static readonly BitSet _66_in_referenceExpression1184 = new BitSet(new ulong[]{0x2440000004000UL});
		public static readonly BitSet _WHITESPACE_in_referenceExpression1189 = new BitSet(new ulong[]{0x2440000004000UL});
		public static readonly BitSet _range_in_referenceExpression1194 = new BitSet(new ulong[]{0x400000000000002UL,0x4UL});
		public static readonly BitSet _SHEETPREFIX_in_range1208 = new BitSet(new ulong[]{0x440000004000UL});
		public static readonly BitSet _RANGE_in_range1213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLUMN_RANGE_in_range1217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ROW_RANGE_in_range1221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_range1238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SHEETPREFIX_in_cell1259 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _CELL_in_cell1261 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CELL_in_cell1276 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_PAREN_in_nestedExpression1289 = new BitSet(new ulong[]{0xF8B2444185015020UL,0x3UL});
		public static readonly BitSet _expression_in_nestedExpression1291 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _RIGHT_PAREN_in_nestedExpression1293 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_NAME_in_function1312 = new BitSet(new ulong[]{0xF8B2544185015020UL,0x3UL});
		public static readonly BitSet _argumentList_in_function1314 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _RIGHT_PAREN_in_function1317 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_argumentList1340 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ARG_SEPARATOR_in_argumentList1344 = new BitSet(new ulong[]{0xF8B2444185015020UL,0x3UL});
		public static readonly BitSet _expression_in_argumentList1347 = new BitSet(new ulong[]{0x202UL});
	}
	#endregion Follow sets
}

} // namespace  Infotron.FormulaParser 
